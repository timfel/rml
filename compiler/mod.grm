(* parser/mo.grm -- ML-Yacc grammar for MODELICA+ *)

fun mklst(xlst, xnil, xcons, info) =
  let fun loop([], rest) = rest
	| loop(x::xlst, rest) = loop(xlst, xcons(x,rest,info))
  in
    loop(rev xlst, xnil(info))
  end
  
fun sayErr s = TextIO.output(TextIO.stdErr, s)

exception SyntaxErrorParse
fun bug s =
    (sayErr "Internal error: "; sayErr s; sayErr "\n"; raise SyntaxErrorParse)

fun error s =
    (sayErr "Error: "; sayErr s; sayErr "\n"; raise SyntaxErrorParse)
    
fun warn s =
    (sayErr "Warning: "; sayErr s; sayErr "\n")      
  

fun makeInfo lexArg (left as (x,_,_), right as (y,_,_)) =
	let val {fileName, sline, scolumn, eline, ecolumn} = LexArg.getLoc lexArg (left, right)
		val loc = Absyn.LOC(sline, scolumn, eline, ecolumn)
	in
		Absyn.INFO(fileName, x, y, loc)
	end

fun printErrInfo lexArg (left as (x,_,_), right as (y,_,_)) =
	let val {fileName, sline, scolumn, eline, ecolumn} = LexArg.getLoc lexArg (left, right)
	in
	  sayErr(
		 fileName^":"^
		(Int.toString sline)^"."^
		(Int.toString scolumn)^"-"^
		(Int.toString eline)^":"^
		(Int.toString ecolumn)^" ")
	end

fun printInfo lexArg (left as (x,_,_), right as (y,_,_)) =
	let val {fileName, sline, scolumn, eline, ecolumn} = LexArg.getLoc lexArg (left, right)
	in
	  print (fileName);print ":";
	  print(Int.toString sline);print ".";
	  print(Int.toString scolumn);print "-";
	  print(Int.toString eline);print ":";
	  print(Int.toString ecolumn);print "\n"
	end

fun modidRML(info)= Absyn.IDENT("RML", info)
fun id_cons(info) = 
			Absyn.QUALIFIED(modidRML (info), 
				Absyn.PATHIDENT(
					Absyn.IDENT("cons",info),
					info),
				info)
fun ctor_cons(info)= SOME(id_cons(info))
fun id_nil(info) = 
			Absyn.QUALIFIED(modidRML (info), 
				Absyn.PATHIDENT(
					Absyn.IDENT("nil",info),
					info),
					info)

fun pat_nil(info) = Absyn.MCONpat(id_nil(info), info)
fun pat_cons(p,ps,info) = Absyn.MSTRUCTpat(ctor_cons(info), [p,ps], info)
fun mkpatlst(lst, info) = mklst(lst, pat_nil, pat_cons, info)

fun mktuplety([ty], _) = ty
  | mktuplety(tyseq, info) = Absyn.TUPLEty(tyseq, info)
 
fun makeELEMENT(isFinal, 
                innerouter, 
                isReplaceable, 
                classdef, 
                componentclause,  
                constraint,
                comment) = 
  (	
	case classdef of
		SOME(class_def) =>  
			Absyn.ELEMENT(
				false, 
				false, 
				Absyn.UNSPECIFIED,
				Absyn.IDENT(
					"UNSPECIFIED", 
					Absyn.dummyInfo),
				Absyn.CLASSDEF(
					isReplaceable, 
					class_def,
					Absyn.dummyInfo),
				Absyn.dummyInfo,
				NONE)
		| NONE => case componentclause of
					SOME(component_clause) => 
						Absyn.ELEMENT(
							false, 
							false, 
							Absyn.UNSPECIFIED,
							Absyn.IDENT(
								"UNSPECIFIED", 
								Absyn.dummyInfo),
							component_clause,
							Absyn.dummyInfo,
							NONE)
  )


%%

%name MOD
%header (functor MODLrValsFn(structure Token : TOKEN
			     structure Absyn : ABSYN
			     structure Cache : CACHE
			     structure LexArg : LEXARG where type poz = Cache.poz
			     sharing type Cache.restriction = LexArg.restriction
			     sharing type Cache.visibility = LexArg.visibility
			     ) : MOD_LRVALS)

%nodefault

%term	AND				(* and *)
	|	AS				(* as *)
	|	BAR				(* | *)
	(* Not used in MetaModelica
	|	CCON of char	(* #"A" *)
	*)
	|	COLON			(* : *)
	|	COLONCOLON		(* :: *)
	|	COMMA			(* , *)
	|	DOT				(* . *)
	|	END				(* end *)
	|	EOF_HARD		(* <first eof> *)
	|	EOF_SOFT		(* <second eof> *)
	|	EQ				(* = *)
	|	EQEQ			(* == *)
	|	FAIL			(* fail *)
	|	ICON of int		(* 34 *)
	|	IDENT of string	(* eval *)
	|	LBRACK			(* [ *)
	|	LPAREN			(* ( *)
	|	NOT				(* not *)
	|	OF				(* of *)
	|	RCON of real	(* 3.14 *)
	|	RBRACK			(* ] *)
	|	RPAREN			(* ) *)
	|	SCON of string	(* "foo" *)
	|	STAR			(* * *)
	|	TYPE			(* type *)
	|	WILD			(* _ *)
	(* adrpo -- start *)
	(* int operators *)
	|	ADD_INT		(* + *)
	|   SUB_INT     (* - *)
	|   NEG_INT     (* ~ *)
	(* |   MUL_INT     (* * *) *)
	|   DIV_INT       (* / *)
	|   MOD_INT     (* % *)
	|   EQEQ_INT      (* == *)
	|   GE_INT      (* >= *)
	|   GT_INT      (* > *)
	|   LE_INT      (* <= *)
	|   LT_INT      (*  < *)
	|   NE_INT      (* != OR <> *)
	(* real operators *)
	|	ADD_REAL	 (* +. *)
	|   SUB_REAL     (* -. *)
	|   NEG_REAL     (* ~. *)
	|   MUL_REAL     (* * *)
	|   DIV_REAL     (* /. *)
	|   MOD_REAL     (* %. *)
	|   POW_REAL      (* ^. *)				
	|   EQEQ_REAL      (* ==. *)
	|   GE_REAL      (* >=. *)
	|   GT_REAL      (* >. *)
	|   LE_REAL      (* <=. *)
	|   LT_REAL      (*  <. *)
	|   NE_REAL      (* !=. *)
	(* string operators *)
	|	ADD_STRING	 (* +& *)
	|	EQEQ_STRING	 (* ==& *)		
	(* list operators *)
	|	ADD_LIST	 (* @ *)	
	(* adrpo added MODELICA keywords/punctuation *)
	|	SEMICOLON	(* ; *)
	|	LBRACE		(* { *)
	|	RBRACE		(* } *)
	|	ASSIGN		(* := *)
	|	POWER		(* ^ *)
	|	ALGORITHM
	|	ANNOTATION
	|	BLOCK
	|	BOUNDARY
	|   CODE 
	|	CLASS
	|	CONNECT
	|	CONNECTOR
	|	CONSTANT
	|	DISCRETE
	|	EACH
	|	ELSE
	|	ELSEIF
	|	ELSEWHEN
	(* already there END *)
	|	ENUMERATION
	|	EQUATION
	|	ENCAPSULATED
	|	EXTENDS
	|	EXTERNAL
	|	FALSE
	|   TRUE	
	|	FINAL
	|	FLOW
	|	FOR
	|	FUNCTION
	|	IF
	|	IMPORT
	|	IN
	|	INNER
	|	INPUT
	|	LOOP
	|	MODEL
	(* already there NOT *)
	|	OUTER
	(* |	OVERLOAD *)
	|	OR
	|	OUTPUT
	|	PACKAGE
	|	PARAMETER
	|	PARTIAL
	|	PROTECTED
	|	PUBLIC
	|	RECORD
	|	REDECLARE
	|	REPLACEABLE
	|	RESULTS
	|	THEN
	(* already there TYPE *)
	(* already there UNSIGNED_REAL *)
	|	WHEN
	|	WHILE
	|	WITHIN
	(* new modelica+ constructs *)
	|   TUPLE
	|   FAILURE
	|   EQUALITY
	|	UNIONTYPE
	|	MATCH
	|   MATCHCONTINUE
	|	CASE
	|	LOCAL
	|   DOTSTAR
	|   LIST 
	|	START_MODELICA	(* <start symbol: function> *)
	|	UNARY (* define to just assign precedence to +/- *)		
	(* adrpo -- end *)

%keyword
	AND
	AS
	END
	FAIL
	NOT
	OF
	TYPE
	(* adrpo added MODELICA keywords *)
	ALGORITHM
	ANNOTATION
	BLOCK
	BOUNDARY
	(* not needed CODE *)
	CLASS
	CONNECT
	CONNECTOR
	CONSTANT
	DISCRETE
	EACH
	ELSE
	ELSEIF
	ELSEWHEN
	(* already there END *)
	ENUMERATION
	EQUATION
	ENCAPSULATED
	EXTENDS
	EXTERNAL
	FALSE 
	TRUE
	FINAL
	FLOW
	FOR
	FUNCTION
	IF
	IMPORT
	IN
	INNER
	INPUT
	LOOP
	MODEL
	(* already there NOT *)
	OUTER
	(* OVERLOAD *)
	OR
	OUTPUT
	PACKAGE
	PARAMETER
	PARTIAL
	PROTECTED
	PUBLIC
	RECORD
	REDECLARE
	REPLACEABLE
	RESULTS
	THEN
	(* already there TYPE *)
	(* already there UNSIGNED_REAL *)
	WHEN
	WHILE
	WITHIN
	(* new modelica+ constructs *)
	TUPLE
	FAILURE
	EQUALITY	
	UNIONTYPE
	MATCH
	MATCHCONTINUE
	CASE
	LOCAL
	LIST
	

%nonterm modelica of Absyn.modelica
	| pat of Absyn.Pattern
	| pat_a of Absyn.Pattern
	| pat_b of Absyn.Pattern
	| pat_c of Absyn.Pattern
	| pat_d of Absyn.Pattern
	| pat_e of Absyn.Pattern
	| seq_pat of Absyn.Pattern list
	| pat_star of Absyn.Pattern list
	| pat_comma_star of Absyn.Pattern list
	| pat_comma_plus of Absyn.Pattern list
	| ident of Absyn.ident
	| tyvar of Absyn.ident
	(* Modelica+ constructs *)
    | stored_definition of Absyn.modelica
	| optENCAPSULATED of bool
	| optPARTIAL of bool
	| optFINAL of bool	
	| optEACH of Absyn.Each
	| optSEMICOLON of bool
	| opt_within_clause of Absyn.Within
	| within_clause of Absyn.Within
	| class_definition of Absyn.Class
	| class_type of Absyn.Restriction
	| base_prefix of Absyn.ElementAttributes
	| class_specifier of Absyn.ClassDef option
	| enumeration of Absyn.ClassDef
	| enum_list of Absyn.EnumLiteral list
	| enumeration_literal of Absyn.EnumLiteral 	
	| overloading of Absyn.ClassDef
	| variability_prefix of Absyn.Variability
	| direction_prefix of Absyn.Direction
	| component_clause of Absyn.ElementSpec
	| component_clause1 of Absyn.ElementSpec
	| class_or_component of (Absyn.Class option * Absyn.ElementSpec option) 
	| composition of Absyn.ClassPart list	
	| import_clause of Absyn.ElementSpec
	| explicit_import_name of Absyn.Import 
	| implicit_import_name of Absyn.Import
	| class_definition_list of Absyn.Class list
	| composition_sublist of Absyn.ClassPart list
	| language_specification of string
	| external_clause of Absyn.ClassPart
	| external_function_call of Absyn.ExternalDecl 
	| opt_expression_list of Absyn.Exp list
	| element_list of Absyn.ElementItem list
	| local_element_list of Absyn.ElementItem list
	| element of Absyn.Element	
	| inner_outer of Absyn.InnerOuter
	| subscript of Absyn.Subscript	
	| subscript_list of Absyn.Subscript list
	| array_subscripts of Absyn.Subscript list
	| type_specifier of Absyn.TypeSpec
	| type_specifier_list of Absyn.TypeSpec list
	| component_list of Absyn.ComponentItem list	
	| component_declaration of Absyn.ComponentItem
	| declaration of Absyn.Component
	| modification of Absyn.Modification
	| opt_modification of Absyn.Modification option
	| class_modification of Absyn.ElementArg list
	| opt_class_modification of Absyn.ElementArg list option
	| argument_list of Absyn.ElementArg list
	| argument of Absyn.ElementArg
	| equation_clause of Absyn.ClassPart 
	| equation_annotation_list of Absyn.EquationItem list
	| constraining_clause of Absyn.ElementSpec
	| opt_constraining_clause of Absyn.ElementSpec option
	| extends_clause of Absyn.ElementSpec
	| algorithm_clause of Absyn.ClassPart
	| algorithm_annotation_list of Absyn.AlgorithmItem list
	| equation of Absyn.EquationItem
	| algorithm of Absyn.AlgorithmItem
	| algorithm1 of Absyn.AlgorithmItem
	| equation_elseif of (Absyn.Exp * Absyn.EquationItem list) list
	| algorithm_elseif of (Absyn.Exp * Absyn.AlgorithmItem list) list 
	| opt_equation_else of Absyn.EquationItem list
	| opt_algorithm_else of Absyn.AlgorithmItem list
	| conditional_equation_e of Absyn.Equation
	| conditional_equation_a of Absyn.Algorithm
	| for_indices of Absyn.ForIndices list
	| for_indice of Absyn.ForIndices
	| for_clause_e of Absyn.Equation
	| for_clause_a of Absyn.Algorithm
	| while_clause of Absyn.Algorithm
	| when_clause_e of Absyn.Equation
	| else_when_e of (Absyn.Exp * Absyn.EquationItem list) list
	| when_clause_a of Absyn.Algorithm
	| else_when_a of (Absyn.Exp * Absyn.AlgorithmItem list) list
	| equation_list of Absyn.EquationItem list
	| algorithm_list of Absyn.AlgorithmItem list
	| connect_clause of Absyn.Equation
	| connector_ref of Absyn.ComponentRef
	| expression of Absyn.Exp
	| code_expression of Absyn.Exp
	| code of Absyn.Exp
	| if_expression of Absyn.Exp
	| elseif_expression_list of (Absyn.Exp * Absyn.Exp) list
	| simple_expression of Absyn.Exp
	| eq_equals of (Absyn.Exp option * Absyn.Comment option)
	| alg_assign of (Absyn.Exp option * Absyn.Comment option)	
	| logical_term of Absyn.Exp
	| logical_factor of Absyn.Exp
	| relation of Absyn.Exp	
	| rel_op of Absyn.Operator
	| pow_op of Absyn.Operator
	| addsub_op of Absyn.Operator
	| muldiv_op of Absyn.Operator
	| arithmetic_expression of Absyn.Exp
	| unary_arithmetic_expression of Absyn.Exp
	| term of Absyn.Exp 
	| factor of Absyn.Exp
	| expression_matrix_list of Absyn.Exp list list
	| expression_matrix of Absyn.Exp
	| primary of Absyn.Exp
	| component_ref_function_call of Absyn.Exp
	| name_path of Absyn.Path
	| dot_name_path of Absyn.Path option
	| component_reference of Absyn.ComponentRef
	| function_arguments of Absyn.FunctionArgs
	| opt_named_arguments of Absyn.NamedArg list option
	| named_arguments of Absyn.NamedArg list
	| named_argument of Absyn.NamedArg
	| expression_list of Absyn.Exp list
	| comment of Absyn.Comment option
	| string_comment of string 
	| opt_string_comment of string option
	| string_comment_add of string
	| annotation of Absyn.Annotation
	| function_call of Absyn.FunctionArgs
	| logical_expression of Absyn.Exp
	(* new modelica+ stuff *)
	| match_expression of Absyn.Exp
	| case_stmt of Absyn.Case
	| case_list of Absyn.Case list
	| case_else of Absyn.Case list
	| match of Absyn.MatchType

%eop EOF_HARD EOF_SOFT   
%noshift EOF_HARD

(* adrpo -- start *)			     
%left ADD_INT SUB_INT ADD_STRING ADD_LIST
%left STAR DIV_INT

%left ADD_REAL SUB_REAL
%left MUL_REAL DIV_REAL

%right POW_REAL POWER

%left COMMA
%left OR AND
%left EQEQ NE_INT LT_INT GT_INT LE_INT GE_INT MOD_INT
%right UNARY
%left LBRACE LPAREN DOT
(* %left SEMICOLON *)
%left ELSE

%left COLONCOLON
%right ASSIGN EQ 
(* adrpo -- end *)	     

%pos Cache.poz
%arg (lexArg) : LexArg.lexarg
(*
	   (LexArg.poz*LexArg.poz) -> 
	   {fileName: string, sline:LexArg.poz, scolumn:LexArg.poz, eline:LexArg.poz, ecolumn:LexArg.poz}
*)
(*%pure*)
%verbose
%start modelica

%%

modelica
	: START_MODELICA stored_definition 
		( stored_definition )

(* PATTERNS *)
pat	(* patterns possibly starting with LPAREN *)
	: ident EQ pat
		( Absyn.MNAMEDARGpat(ident, pat,
			makeInfo lexArg (identleft, patright)))
	| ident AS pat
		( Absyn.MBINDpat(ident, pat,
			makeInfo lexArg (identleft, patright)))
	| pat_a
		( pat_a )

pat_a
	: pat_b COLONCOLON pat_a
		( Absyn.MSTRUCTpat(
			ctor_cons (makeInfo lexArg (COLONCOLONleft, COLONCOLONright)), 
			[pat_b, pat_a], 
			makeInfo lexArg (pat_bleft, pat_aright)) )
	| pat_b
		( pat_b )

pat_b	(* simple patterns possibly starting with LPAREN *)
	: LPAREN RPAREN
		( Absyn.MSTRUCTpat(NONE, [],
			makeInfo lexArg (LPARENleft, RPARENright)) )
	| LPAREN pat RPAREN
		( pat )
	| LPAREN pat COMMA pat_comma_plus RPAREN
		( Absyn.MSTRUCTpat(NONE, pat :: pat_comma_plus,
			makeInfo lexArg (LPARENleft, RPARENright)) )
	| pat_d
		( pat_d )

pat_c	(* patterns not starting with LPAREN *)
	: pat_d COLONCOLON pat_c
		( Absyn.MSTRUCTpat(
			ctor_cons (makeInfo lexArg (COLONCOLONleft, COLONCOLONright)), 
			[pat_d, pat_c],
			makeInfo lexArg (pat_dleft, pat_cright)) )
	| pat_d
		( pat_d )

pat_d	(* simple patterns not starting with LPAREN *)
	: name_path pat_star
		( 
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();

		if (List.length pat_star > 0)
		then
		  Absyn.MSTRUCTpat(SOME name_path, pat_star,
			makeInfo lexArg (name_pathleft, pat_starright))
		else
		  Absyn.MCONpat(
			name_path,
			makeInfo lexArg (name_pathleft, name_pathright))		   
		)
	| name_path pat_e
	( 
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();
	
		Absyn.MSTRUCTpat(SOME name_path, [pat_e],
			makeInfo lexArg (name_pathleft, pat_eright)) 
	)
	| pat_e
		( pat_e )

pat_e	(* atomic patterns not starting with LPAREN *)
	: WILD
		( Absyn.MWILDpat(makeInfo lexArg (WILDleft, WILDright)) )
	(* Not used in MetaModelica
	| CCON 
	( 
		Absyn.MLITpat(
			Absyn.CHAR(CCON,
				makeInfo lexArg (CCONleft, CCONright)),
			makeInfo lexArg (CCONleft, CCONright))
	)
	*)		
	| ICON
		( Absyn.MLITpat(
			Absyn.INTEGER(
				ICON,
				makeInfo lexArg (ICONleft, ICONright)), 
			makeInfo lexArg (ICONleft, ICONright)) )
	| RCON 
		( Absyn.MLITpat(
			Absyn.REAL(
				RCON,
				makeInfo lexArg (RCONleft, RCONright)), 
			makeInfo lexArg (RCONleft, RCONright)) )
	| SCON
		( Absyn.MLITpat(
			Absyn.STRING(
				SCON,
				makeInfo lexArg (SCONleft, SCONright)), 
			makeInfo lexArg (SCONleft, SCONright)) )
	| name_path
	( 
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();
	
		Absyn.MCONpat(
			name_path,
			makeInfo lexArg (name_pathleft, name_pathright)) 
	)
	| ident
		( Absyn.MIDENTpat(
			ident, ref(Absyn.MWILDpat(makeInfo lexArg (identleft, identright))),
			makeInfo lexArg (identleft, identright)) )
	| FALSE 
	( 
		Absyn.MIDENTpat(
			Absyn.makeIdent("false", 
				makeInfo lexArg (FALSEleft, FALSEright)),		
			ref(Absyn.MWILDpat(makeInfo lexArg (FALSEleft, FALSEright))),
			makeInfo lexArg (FALSEleft, FALSEright)) 
	)
	| TRUE 
	( 
		Absyn.MIDENTpat(
			Absyn.makeIdent("true", 
				makeInfo lexArg (TRUEleft, TRUEright)),		
			ref(Absyn.MWILDpat(makeInfo lexArg (TRUEleft, TRUEright))),
			makeInfo lexArg (TRUEleft, TRUEright)) 
	)			
	| LBRACK pat_comma_star RBRACK
		( mkpatlst(
			pat_comma_star,
			makeInfo lexArg (LBRACKleft, RBRACKright)) )
	| LBRACE pat_comma_star RBRACE
		( mkpatlst(pat_comma_star,
			makeInfo lexArg (LBRACEleft, RBRACEright)) )

seq_pat
	: (*empty*)
		( [] )
	| pat_c		(* cannot start with LPAREN *)
		( [pat_c] )
	| pat_star
		( pat_star )
	| ident AS pat
		( [Absyn.MBINDpat(ident, pat,
			makeInfo lexArg (identleft, patright))])
	| ident EQ pat
		( [Absyn.MNAMEDARGpat(ident, pat,
			makeInfo lexArg (identleft, patright))])			

pat_star
	: LPAREN pat_comma_star RPAREN
		( pat_comma_star )

pat_comma_star
	: (*empty*)
		( [] )
	| pat_comma_plus
		( pat_comma_plus )

pat_comma_plus
	: pat
		( [pat] )
	| pat COMMA pat_comma_plus
		( pat :: pat_comma_plus )

(* SHORT IDENTIFIERS *)

ident
	: IDENT
		( Absyn.makeIdent(IDENT, 
			makeInfo lexArg (IDENTleft, IDENTright)) )

(*-----------------------------------------------------------------*)
(*-----------------------------------------------------------------*)
(*                adrpo added Modelica+ grammar                    *)
(*-----------------------------------------------------------------*)
(*-----------------------------------------------------------------*)
(* modelica+ grammar is a very strip-down modelica grammar + new constructs *)
stored_definition (* only one class which corresponds with module ident in RML *)
   : class_type ident opt_string_comment composition END IDENT SEMICOLON
	 (
	  Absyn.PROGRAM(
		[Absyn.CLASS(ident,false,false, false,
				class_type,
				Absyn.PARTS(
					composition, 
					opt_string_comment,
					makeInfo lexArg (compositionleft, compositionright)),
				makeInfo lexArg (class_typeleft, SEMICOLONright))], 
		Absyn.TOP,
		Absyn.INTERFACE({modid=ident,  
				         specs=[], 
						 source=Absyn.Source.dummy},
						 makeInfo lexArg (class_typeleft, SEMICOLONright)),
		makeInfo lexArg (class_typeleft, SEMICOLONright)
	  )
    )

(*			
optPARTIAL:
		PARTIAL (true)
	|	(* empty *) (false)
*)
	
(* we don't care about final here! *)
class_definition:
	class_type ident class_specifier 
	(
		case class_type of
			Absyn.R_RECORD(_)   =>
				LexArg.addRestriction(
					lexArg, Absyn.identName ident,
					Cache.REC,
					!(LexArg.currVisibility lexArg)					
					)
		|	Absyn.R_FUNCTION(_) =>
				 LexArg.addRestriction(
					lexArg, Absyn.identName ident,
					Cache.FUN,
					!(LexArg.currVisibility lexArg))
		|	_ => ();
		
		case class_specifier of 
			SOME(class_specifier)
			=> Absyn.CLASS(ident,
				case class_type of 
					Absyn.R_FUNCTION_TYPE(_) => true
				|	_ => false,
				false,  
				false,
				class_type,
				class_specifier,
				makeInfo lexArg (class_typeleft, class_specifierright))
		|	NONE
			=> Absyn.CLASS(ident,
				false,
				false,  
				false,
				Absyn.R_TYPEVARIABLE(makeInfo lexArg (class_typeleft, class_typeright)),
				Absyn.PARTS([],NONE, makeInfo lexArg (class_typeleft, identright)),
				makeInfo lexArg (class_typeleft, identright))
	)

(* we only support these! *)
class_type:
	RECORD    ( Absyn.R_RECORD(makeInfo lexArg (RECORDleft, RECORDright)) )
|	TYPE      ( Absyn.R_TYPE(makeInfo lexArg (TYPEleft, TYPEright)) )
|	PACKAGE   ( Absyn.R_PACKAGE(makeInfo lexArg (PACKAGEleft, PACKAGEright)) )
|	PARTIAL FUNCTION ( Absyn.R_FUNCTION_TYPE(makeInfo lexArg (PARTIALleft, FUNCTIONright)) )
|	FUNCTION  ( Absyn.R_FUNCTION(makeInfo lexArg (FUNCTIONleft, FUNCTIONright)) )
|   UNIONTYPE ( Absyn.R_UNIONTYPE(makeInfo lexArg (UNIONTYPEleft, UNIONTYPEright)) )
	

class_specifier:
	opt_string_comment composition END IDENT 
	(
	  SOME(
	  Absyn.PARTS(
		composition, 
		opt_string_comment,
		makeInfo lexArg (compositionleft, IDENTright)))
	)
	| opt_string_comment 
	(
		NONE	
	)	
	| EQ type_specifier comment 
	(
		SOME(
		Absyn.DERIVED(
			type_specifier, 
			Absyn.ATTR(
			  Absyn.VAR, 
			  Absyn.BIDIR(makeInfo lexArg (EQleft, EQright)), 
			  makeInfo lexArg (EQleft, EQright)), 
			[], 
			comment,
			makeInfo lexArg (EQleft, type_specifierright))) 
		)
	| EQ enumeration ( SOME(enumeration) )

enumeration:
	ENUMERATION LPAREN enum_list RPAREN comment
		( Absyn.ENUMERATION(
			enum_list, 
			comment, 
			makeInfo lexArg (ENUMERATIONleft, RPARENright)))	
	
enum_list:
	enumeration_literal COMMA enum_list
		( enumeration_literal::enum_list )
	| enumeration_literal
		( [enumeration_literal] )
	
enumeration_literal:
	ident 
		( Absyn.ENUMLITERAL(
			ident, 
			NONE, 
			makeInfo lexArg (identleft, identright)))

(*	
base_prefix:
	variability_prefix direction_prefix
		( Absyn.ATTR(
			variability_prefix, 
			direction_prefix, 
			makeInfo lexArg (variability_prefixleft, direction_prefixright)) )
*)

(* TODO, FIXME, unite all prefixes into ONE *)
 
variability_prefix:
	PARAMETER	( Absyn.PARAM(makeInfo lexArg (PARAMETERleft, PARAMETERright)) )
|	CONSTANT	( Absyn.CONST(makeInfo lexArg (CONSTANTleft, CONSTANTright)) )
|	(* empty *)	( Absyn.VAR )


direction_prefix:
	INPUT		( Absyn.INPUT(makeInfo lexArg (INPUTleft, INPUTright)) )
|	OUTPUT		( Absyn.OUTPUT(makeInfo lexArg (OUTPUTleft, OUTPUTright)) )
|	(* empty *)	( Absyn.BIDIR(makeInfo lexArg (defaultPos,defaultPos)) )


component_clause:
	direction_prefix type_specifier component_list
	(
	Absyn.COMPONENTS(
		Absyn.ATTR(
				Absyn.VAR, 
				direction_prefix, 
				makeInfo lexArg (direction_prefixright, direction_prefixleft)),
		 type_specifier,
		 component_list,
		 makeInfo lexArg (direction_prefixleft, component_listright))
	)	
	| CONSTANT direction_prefix type_specifier component_list
	(
	Absyn.COMPONENTS(
		Absyn.ATTR(
				Absyn.CONST(makeInfo lexArg (CONSTANTleft, CONSTANTright)), 
				direction_prefix, 
				makeInfo lexArg (direction_prefixright, direction_prefixleft)),
		 type_specifier,
		 component_list,
		 makeInfo lexArg (direction_prefixleft, component_listright))
	)	
	(* input function Functype func; *)
	| direction_prefix FUNCTION type_specifier component_list
	(
		Absyn.COMPONENTS(
		 Absyn.ATTR(
			Absyn.VAR, 
			direction_prefix, 
			makeInfo lexArg (direction_prefixleft, direction_prefixright)),
		 type_specifier, 
		 component_list,
		 makeInfo lexArg (direction_prefixleft, component_listright))
	)
	(* input replaceable function func extends Functype; *)
	| direction_prefix REPLACEABLE FUNCTION component_list EXTENDS type_specifier
	(
		Absyn.COMPONENTS(
		 Absyn.ATTR(
			Absyn.VAR, 
			direction_prefix, 
			makeInfo lexArg (direction_prefixleft, direction_prefixright)),
		 type_specifier, 
		 component_list,
		 makeInfo lexArg (direction_prefixleft, type_specifierright))
	)				 	

	
component_clause1:
	variability_prefix direction_prefix
	type_specifier component_declaration
	(
		Absyn.COMPONENTS(
			Absyn.ATTR(
				variability_prefix, 
				direction_prefix, 
				makeInfo lexArg (variability_prefixleft, direction_prefixright)),
			type_specifier,
			[component_declaration],
			makeInfo lexArg (variability_prefixleft, component_declarationright))
	)

import_clause:
	IMPORT explicit_import_name comment 
		( Absyn.IMPORT(
			explicit_import_name, 
			comment, 
			makeInfo lexArg (IMPORTleft, explicit_import_nameright)) )
	| IMPORT implicit_import_name comment
		( Absyn.IMPORT(
			implicit_import_name, 
			comment,
			makeInfo lexArg (IMPORTleft, implicit_import_nameright)) )
	
explicit_import_name:
	ident EQ name_path
	( 
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();
		
		Absyn.NAMED_IMPORT(
			ident, 
			name_path,
			makeInfo lexArg (identleft, name_pathright))
	)
	

implicit_import_name:
	name_path DOTSTAR
		( 
		  LexArg.addImport(
			lexArg, 
			(Absyn.getLastPathAsString name_path)^".mo",
			name_pathleft, DOTSTARright, !(LexArg.currVisibility lexArg));
		
		  Absyn.UNQUAL_IMPORT(
			name_path,
			makeInfo lexArg (name_pathleft, DOTSTARright)))
	| name_path
		( 		  
		  LexArg.addImport 
			(lexArg, 
			 (Absyn.getLastPathAsString name_path)^".mo", 
			 name_pathleft, name_pathright, !(LexArg.currVisibility lexArg));
			
		  Absyn.QUAL_IMPORT(
			name_path,
			makeInfo lexArg (name_pathleft, name_pathright)))
	
composition:
	element_list 
	(		
		LexArg.currVisibility(lexArg) := Cache.PUBLIC;
			
		[ Absyn.PUBLIC(
			element_list,
			makeInfo lexArg (element_listleft, element_listright)) ]
	)
	| element_list composition_sublist
	(	
		LexArg.currVisibility(lexArg) := Cache.PUBLIC;	
		Absyn.PUBLIC(
			element_list,
			makeInfo lexArg (element_listleft, element_listright))::composition_sublist
	)
	
composition_sublist:
	  PUBLIC element_list composition_sublist 
	(	
		LexArg.currVisibility(lexArg) := Cache.PUBLIC;
			
		Absyn.PUBLIC(
			element_list,
			makeInfo lexArg (PUBLICleft, element_listright))::composition_sublist )
	| PROTECTED element_list composition_sublist 
	( 		
		LexArg.currVisibility(lexArg) := Cache.PROTECTED;
	
		Absyn.PROTECTED(
			element_list,
			makeInfo lexArg (PROTECTEDleft, element_listright))::composition_sublist )
	| LOCAL PROTECTED element_list composition_sublist 
	( 
		LexArg.currVisibility(lexArg) := Cache.PROTECTED;
	
		Absyn.PROTECTED(
			element_list,
			makeInfo lexArg (LOCALleft, element_listright))::composition_sublist 
	)					
	| algorithm_clause composition_sublist 
		( algorithm_clause::composition_sublist  )
	| equation_clause composition_sublist 
		( equation_clause::composition_sublist )
	| external_clause SEMICOLON
		( [external_clause]	)
	| (* empty *)
		( [] )

external_clause:
	EXTERNAL external_function_call
	(
		Absyn.EXTERNAL(
			external_function_call, 
			NONE, 
			NONE,
			makeInfo lexArg (EXTERNALleft, external_function_callright)) 	
	)
	
language_specification:
	SCON
		( SCON )

external_function_call:
	language_specification 
	(  
		Absyn.EXTERNALDECL(
			NONE,
			SOME(language_specification), 
			NONE,
			[],
			makeInfo lexArg (language_specificationleft, language_specificationright))
	)
	| language_specification component_reference EQ ident LPAREN opt_expression_list RPAREN
	(  
		Absyn.EXTERNALDECL(
			SOME(ident),
			SOME(language_specification), 
			SOME(component_reference),
			opt_expression_list,
			makeInfo lexArg (language_specificationleft, RPARENright))
	)
	
opt_expression_list:
	expression_list ( expression_list )
	| (* empty *)
		( [] )
	
element_list:
	element SEMICOLON element_list
		( Absyn.ELEMENTITEM(
				element,
				makeInfo lexArg (elementleft, SEMICOLONright))::element_list ) 		
	| (* empty *)
		( [] )
	
element:
	component_clause
		( makeELEMENT(
			false, 
			Absyn.UNSPECIFIED,  
			false,  
			NONE,  
			SOME(component_clause),  
			NONE, 
			NONE))
	| REPLACEABLE class_or_component
		( 
		  case class_or_component of
		       (SOME(class_definition), NONE) => 
				makeELEMENT(
					false, 
					Absyn.UNSPECIFIED,  
					true, 
					SOME(class_definition),  
					NONE,  
					NONE, 
					NONE)
		     | (NONE, SOME(component_clause)) => 
				makeELEMENT(
					false, 
					Absyn.UNSPECIFIED,  
					true,  
					NONE,  
					SOME(component_clause),  
					NONE, 
					NONE)
		)
	| import_clause
	(
	  Absyn.ELEMENT(
		false, 
		false, 
		Absyn.UNSPECIFIED,
		Absyn.IDENT(
			"import", 
			makeInfo lexArg (import_clauseleft, import_clauseright)),
		import_clause,
		makeInfo lexArg (import_clauseleft, import_clauseright),
		NONE)
	)
	| extends_clause
	(
	  Absyn.ELEMENT(
		false,
		false,
		Absyn.UNSPECIFIED,
		Absyn.IDENT(
			"extends",
			makeInfo lexArg (extends_clauseleft, extends_clauseright)),
		extends_clause,
		makeInfo lexArg (extends_clauseleft, extends_clauseright),
		NONE)
	)
	| class_definition
	( 
		makeELEMENT(
			false, 
			Absyn.UNSPECIFIED,  
			false, 
			SOME(class_definition),  
			NONE,  
			NONE, 
			NONE)
	)
	(*   input replaceable function func extends Functype; *)
	(*
	| INPUT REPLACEABLE class_definition extends_clause
	(
		( makeELEMENT(
			false, 
			Absyn.UNSPECIFIED,  
			true, 
			SOME(class_definition),  
			NONE,  
			NONE, 
			NONE)
	)
	*)
	
class_or_component:
		component_clause 
		( (NONE,  SOME(component_clause)) )
	| class_definition 
		( (SOME(class_definition), NONE) )
	

subscript:
	expression
	( 
		Absyn.SUBSCRIPT(
			expression,
			makeInfo lexArg (expressionleft, expressionright)) 
	)
	| COLON
	( 
		Absyn.NOSUB(
			makeInfo lexArg (COLONleft, COLONright)) 
	)	

array_subscripts:
	LBRACK subscript RBRACK
		( [subscript] )
	| (* empty *)
		( [] )	

type_specifier_list:
	  type_specifier
		( [type_specifier] )
	| type_specifier COMMA type_specifier_list
		( type_specifier::type_specifier_list )


type_specifier:
	 name_path
	(
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();
	 
		Absyn.TPATH(name_path,  
	                makeInfo lexArg (name_pathleft, name_pathright))
	)
   | name_path LT_INT type_specifier_list GT_INT
	( 
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();
	
		Absyn.TCOMPLEX(name_path, type_specifier_list,  
	                makeInfo lexArg (name_pathleft, GT_INTright))
	)
   (* MetaModelica arrays *)   
   | type_specifier LBRACK COLON RBRACK
	  ( Absyn.TCOMPLEX(
			Absyn.PATHIDENT(
				Absyn.IDENT("ARRAY",makeInfo lexArg (type_specifierleft, RBRACKright)),
				makeInfo lexArg (type_specifierleft, RBRACKright)), 
			[type_specifier],  
	        makeInfo lexArg (type_specifierleft, RBRACKright)))  

	
component_list:
	  component_declaration
		( [ component_declaration] )
	| component_declaration COMMA component_list
		( component_declaration::component_list )

component_declaration:
	declaration comment
		( Absyn.COMPONENTITEM(
			declaration, 
			comment,
			makeInfo lexArg (declarationleft, commentright)))	

declaration:
	ident opt_modification
	( 
	  Absyn.COMPONENT(
		ident, 
		opt_modification,
		makeInfo lexArg (identleft, opt_modificationright))
	)
		
modification:
	class_modification EQ expression
		( 
			Absyn.CLASSMOD(
				class_modification, 
				SOME(expression),
				makeInfo lexArg (class_modificationleft, expressionright)) 
		)
	| class_modification
		( Absyn.CLASSMOD(
			class_modification, 
			NONE,
			makeInfo lexArg (class_modificationleft, class_modificationright)) )
	| EQ expression
		( Absyn.CLASSMOD(
			[], 
			SOME(expression),
			makeInfo lexArg (EQleft, expressionright)) )
	| ASSIGN expression
		( Absyn.CLASSMOD(
			[], 
			SOME(expression),
			makeInfo lexArg (ASSIGNleft, expressionright)) )
	

opt_modification:
	modification
		( SOME(modification) )
	|
		( NONE )
	

class_modification:
	LPAREN argument_list RPAREN
		( argument_list )
	| LPAREN RPAREN
		( [] )
	

(*
opt_class_modification:
	class_modification
		( SOME(class_modification) )
	|
		( NONE )
*)	

argument_list:
	argument COMMA argument_list
		( argument::argument_list )
	|
	argument
		( [ argument ] )
	

argument:
	optEACH optFINAL component_reference opt_modification opt_string_comment
	(
	  Absyn.MODIFICATION(
		optFINAL, 
		optEACH, 
		component_reference, 
		opt_modification, 
		opt_string_comment,
		makeInfo lexArg (optEACHleft, opt_string_commentright))
	)
	| optEACH optFINAL component_reference opt_modification 
	(
	  Absyn.MODIFICATION(
		optFINAL, 
		optEACH, 
		component_reference, 
		opt_modification, 
		NONE,
		makeInfo lexArg (optEACHleft, opt_modificationright))
	)	
	| REDECLARE optEACH optFINAL REPLACEABLE class_definition opt_constraining_clause
	(
	  Absyn.REDECLARATION(
			optFINAL, 
			optEACH,
			Absyn.CLASSDEF(
				true, 
				class_definition,
				makeInfo lexArg (class_definitionleft, class_definitionright)), 
			opt_constraining_clause,
			makeInfo lexArg (REDECLAREleft, opt_constraining_clauseright))
	)
	| REDECLARE optEACH optFINAL REPLACEABLE component_clause1 opt_constraining_clause
	(
	  Absyn.REDECLARATION(
		optFINAL, 
		optEACH, 
		component_clause1, 
		opt_constraining_clause,
		makeInfo lexArg (REDECLAREleft, opt_constraining_clauseright))
	)
	| REDECLARE optEACH optFINAL class_definition
	(
	  Absyn.REDECLARATION(
		optFINAL, 
		optEACH,
		Absyn.CLASSDEF(
			false, 
			class_definition,
			makeInfo lexArg (class_definitionleft, class_definitionright)), 
		NONE,
		makeInfo lexArg (REDECLAREleft, class_definitionright))
	)
	| REDECLARE optEACH optFINAL component_clause1
	(
	  Absyn.REDECLARATION(
		optFINAL, 
		optEACH, 
		component_clause1, 
		NONE,
		makeInfo lexArg (REDECLAREleft, component_clause1right))
	)
		
equation_clause:
	EQUATION equation_annotation_list
	( 
		Absyn.EQUATIONS(
			equation_annotation_list,
			makeInfo lexArg (EQUATIONleft, equation_annotation_listright)) 
	)
	

equation_annotation_list:
	 equation SEMICOLON equation_annotation_list
		( equation::equation_annotation_list )		
	(*
	| annotation SEMICOLON equation_annotation_list
	( 
		Absyn.EQUATIONITEMANN(
			annotation,
			makeInfo lexArg (annotationleft, annotationright))::equation_annotation_list )
	*)
	| (* empty *)
		( [] )
	
constraining_clause:
	extends_clause
		( extends_clause )
	

opt_constraining_clause:
	constraining_clause
		( SOME(constraining_clause) )
	|
		( NONE )
	
extends_clause:
	EXTENDS name_path class_modification
	(
		case name_path of 
			Absyn.QUALIFIED(_) => 	
			LexArg.addExternal(
				lexArg, 
				Absyn.getPathAsString name_path, 
				name_pathleft,name_pathright)
		|	_ => ();
	
	  Absyn.EXTENDS(
		name_path, 
		class_modification,
		makeInfo lexArg (EXTENDSleft, class_modificationright))
	)
	

algorithm_clause:
	ALGORITHM algorithm_annotation_list
	( 
		Absyn.ALGORITHMS(
			algorithm_annotation_list,
			makeInfo lexArg (ALGORITHMleft, algorithm_annotation_listright)) 
	)	

algorithm_annotation_list:
	algorithm SEMICOLON algorithm_annotation_list 
		( algorithm::algorithm_annotation_list )
	(* 
	| annotation SEMICOLON algorithm_annotation_list
	( 
		Absyn.ALGORITHMITEMANN(
			annotation,
			makeInfo lexArg (annotationleft, annotationright))::algorithm_annotation_list ) 
	*)
	| (* empty *)
		( [] )
	

equation:
	simple_expression eq_equals 
	(
	 case eq_equals of
		(NONE, comment) =>
		(
		case simple_expression of 
			  Absyn.CALL(component_reference, function_call, ctxInfo) =>
				Absyn.EQUATIONITEM(
					Absyn.EQ_NORETCALL(
						component_reference, 
						function_call,
						ctxInfo), 
					comment,
					makeInfo lexArg (simple_expressionleft, eq_equalsright))
			| _ => let exception SyntaxErrorParse
					in 
					 printErrInfo lexArg(simple_expressionleft, eq_equalsright);
					 sayErr("Parse Error: Strange simple expression in equation section.\n");					 
					 raise SyntaxErrorParse 
				    end 
		)
		| (SOME(expression), comment) =>
		(
			Absyn.EQUATIONITEM(
				Absyn.EQ_EQUALS(
					simple_expression, 
					expression,
					makeInfo lexArg (eq_equalsleft, eq_equalsright)), 
				comment,
				makeInfo lexArg (simple_expressionleft, eq_equalsright))
		)
	)
	| conditional_equation_e comment
	( 
		Absyn.EQUATIONITEM(
			conditional_equation_e, 
			comment,
			makeInfo lexArg (conditional_equation_eleft, conditional_equation_eright))
	)
	| for_clause_e comment
	( 
		Absyn.EQUATIONITEM(
			for_clause_e, 
			comment,
			makeInfo lexArg (for_clause_eleft, for_clause_eright))
	)
	| connect_clause comment
	( 
		Absyn.EQUATIONITEM(
			connect_clause, 
			comment,
			makeInfo lexArg (connect_clauseleft, connect_clauseright))
	)
	| when_clause_e comment 
	( 
		Absyn.EQUATIONITEM(
			when_clause_e, 
			comment,
			makeInfo lexArg (when_clause_eleft, when_clause_eright))
	)
	| FAILURE LPAREN equation RPAREN comment
	(
		case equation of 
			Absyn.EQUATIONITEM(equation, _, _) =>
				Absyn.EQUATIONITEM(
					Absyn.EQ_FAILURE(equation, makeInfo lexArg (FAILUREleft, RPARENright)),
					comment, 
					makeInfo lexArg (FAILUREleft, RPARENright))
			| _ => equation
	)
	| EQUALITY LPAREN equation RPAREN comment
	(
		case equation of 
			Absyn.EQUATIONITEM(equation, _, _) =>
				Absyn.EQUATIONITEM(
					Absyn.EQ_EQUALITY(equation, makeInfo lexArg (EQUALITYleft, RPARENright)),
					comment, 
					makeInfo lexArg (EQUALITYleft, RPARENright))
			| _ => equation
	)
	

eq_equals:
	EQ expression comment 
		( (SOME(expression), comment) )		
  | comment
		( (NONE, comment) )

alg_assign:
	 ASSIGN expression comment 
		( (SOME(expression), comment) )		
  | comment
		( (NONE, comment) )	


algorithm:
	(* 
	   the case below treats all these versions: 
	 | component_reference function_call 
	 | component_reference function_call ASSIGN expression comment
	 | component_reference ASSIGN expression comment
     | LPAREN expression_list RPAREN ASSIGN expression comment 
    *)
	simple_expression alg_assign
	(
	 case (simple_expression, alg_assign) of
	    (Absyn.CALL(component_reference, function_call, ctxInfo), (NONE, comment)) =>
			Absyn.ALGORITHMITEM(
				Absyn.ALG_NORETCALL(
					component_reference, 
					function_call,
					ctxInfo), 
				comment,
				makeInfo lexArg (simple_expressionleft, alg_assignright))
	   | (x as Absyn.CALL(component_reference, function_call, ctxInfo), (SOME(expression), comment)) =>
			Absyn.ALGORITHMITEM(
				Absyn.ALG_ASSIGN(
					x, 
					expression,
					makeInfo lexArg (simple_expressionleft, alg_assignright)),
				comment,
				makeInfo lexArg (simple_expressionleft, alg_assignright))						
	   | (x as Absyn.CREF(component_reference), (SOME(expression), comment)) =>
			Absyn.ALGORITHMITEM(
				Absyn.ALG_ASSIGN(
					x, 
					expression,
					makeInfo lexArg (simple_expressionleft, alg_assignright)),
				comment,
				makeInfo lexArg (simple_expressionleft, alg_assignright)) 
		| (tuple as Absyn.TUPLE(_), (SOME(expression), comment)) => 		
			Absyn.ALGORITHMITEM(
				Absyn.ALG_TUPLE_ASSIGN(
					tuple,
					expression,
					makeInfo lexArg (simple_expressionleft, alg_assignright)),
				comment,
				makeInfo lexArg (simple_expressionleft, alg_assignright))
	   | (x, (SOME(expression), comment)) =>
			Absyn.ALGORITHMITEM(
				Absyn.ALG_ASSIGN(
					x, 
					expression,
					makeInfo lexArg (simple_expressionleft, alg_assignright)),
				comment,
				makeInfo lexArg (simple_expressionleft, alg_assignright))						
		| _ => let exception SyntaxErrorParse
					in 
					 printErrInfo lexArg (simple_expressionleft, alg_assignright);					 
					 sayErr("Parse Error: Strange simple expression in algorithm section.\n");
					 raise SyntaxErrorParse 
				    end 
	)
	| conditional_equation_a comment 
	( 
		Absyn.ALGORITHMITEM(
			conditional_equation_a, 
			comment,
			makeInfo lexArg (conditional_equation_aleft, conditional_equation_aright)) 
	)
	| for_clause_a comment
	( 
		Absyn.ALGORITHMITEM(
			for_clause_a, 
			comment,
			makeInfo lexArg (for_clause_aleft, for_clause_aright)) 
	)
	| while_clause comment
	( 
		Absyn.ALGORITHMITEM(
			while_clause, 
			comment,
			makeInfo lexArg (while_clauseleft, while_clauseright)) 
	)
	| when_clause_a comment 
	( 
		Absyn.ALGORITHMITEM(
			when_clause_a, 
			comment,
			makeInfo lexArg (when_clause_aleft, when_clause_aright)) 
	)
	| FAILURE LPAREN algorithm RPAREN comment
	(
		case algorithm of 
			Absyn.ALGORITHMITEM(algorithm, _, _) =>
				Absyn.ALGORITHMITEM(
					Absyn.ALG_FAILURE(algorithm, makeInfo lexArg (FAILUREleft, RPARENright)),
					comment, 
					makeInfo lexArg (FAILUREleft, RPARENright))
			| _ => algorithm
	)
	| EQUALITY LPAREN algorithm RPAREN comment
	(
		case algorithm of 
			Absyn.ALGORITHMITEM(algorithm, _, _) =>
				Absyn.ALGORITHMITEM(
					Absyn.ALG_EQUALITY(algorithm, makeInfo lexArg (EQUALITYleft, RPARENright)),
					comment, 
					makeInfo lexArg (EQUALITYleft, RPARENright))
			| _ => algorithm
	)

equation_elseif:
	ELSEIF expression THEN equation_list equation_elseif
		( (expression, equation_list)::equation_elseif )
	|
		( [] )
	

algorithm_elseif:
	ELSEIF expression THEN algorithm_list algorithm_elseif
		( (expression, algorithm_list)::algorithm_elseif )
	|
		( [] )
	

opt_equation_else:
	ELSE equation_list
		( equation_list )
	|
		( [] )
	

opt_algorithm_else:
	ELSE algorithm_list
		( algorithm_list )
	|
		( [] )
	

conditional_equation_e:
	IF expression THEN equation_list equation_elseif opt_equation_else END IF
	( 
		Absyn.EQ_IF(
			expression,
			equation_list,
			equation_elseif,
			opt_equation_else,
			makeInfo lexArg (IF1left, IF2right)) 
	)
	

conditional_equation_a:
	IF expression THEN algorithm_list algorithm_elseif opt_algorithm_else END IF
	( 
		Absyn.ALG_IF(
			expression,
			algorithm_list,
			algorithm_elseif,
			opt_algorithm_else,
			makeInfo lexArg (IF1left, IF2right)) 
	)
	
for_indices:
	for_indice COMMA for_indices
		( for_indice::for_indices )
	| for_indice
		( [for_indice] )
	
for_indice:
	ident
	( 
		Absyn.FORINDICE(
			ident, 
			NONE,
			makeInfo lexArg (identleft, identright)) 
	)
	| ident IN expression
	( 
		Absyn.FORINDICE(
			ident, 
			SOME(expression),
			makeInfo lexArg (identleft, expressionright)) 
	)

for_clause_e:
	FOR for_indices LOOP equation_list END FOR
	( 
		Absyn.EQ_FOR(
			for_indices, 
			equation_list,
			makeInfo lexArg (FOR1left, FOR2right)) 
	)	

for_clause_a:
	FOR for_indices LOOP algorithm_list END FOR
	( 
		Absyn.ALG_FOR(
			for_indices, 
			algorithm_list,
			makeInfo lexArg (FOR1left, FOR2right))
	)
	

while_clause:
	WHILE expression LOOP algorithm_list END WHILE
	( 
		Absyn.ALG_WHILE(
			expression, 
			algorithm_list,
			makeInfo lexArg (WHILE1left, WHILE2right))
	)
	

when_clause_e:
	WHEN expression THEN equation_list else_when_e END WHEN
	( 
		Absyn.EQ_WHEN_E(
			expression, 
			equation_list, 
			else_when_e,
			makeInfo lexArg (WHEN1left, WHEN2right))
	)
	

else_when_e:
	ELSEWHEN expression THEN equation_list else_when_e
		( (expression, equation_list)::else_when_e )
	|
		( [] )
	

when_clause_a:
	WHEN expression THEN algorithm_list else_when_a END WHEN
	( 
		Absyn.ALG_WHEN_A(
			expression, 
			algorithm_list, 
			else_when_a,
			makeInfo lexArg (WHEN1left, WHEN2right))
	)
	

else_when_a:
	ELSEWHEN expression THEN algorithm_list else_when_a
		( (expression, algorithm_list)::else_when_a )
	|
		( [] )
	

equation_list:
	equation SEMICOLON equation_list
		( equation::equation_list )
	|
		( [] )
	

algorithm_list:
	algorithm SEMICOLON algorithm_list
		( algorithm::algorithm_list )
	|
		( [] )
	

connect_clause:
	CONNECT LPAREN component_reference COMMA component_reference RPAREN
	( 
		Absyn.EQ_CONNECT(
			component_reference1, 
			component_reference2,
			makeInfo lexArg (CONNECTleft, RPARENright)) 
	)

local_element_list:
	LOCAL element_list
		(element_list)
	| (* empty *)
		( [] )
	
match:
	  MATCH         (Absyn.MATCH)
	| MATCHCONTINUE (Absyn.MATCHCONTINUE)
	
match_expression:
  match expression opt_string_comment 
	local_element_list 
	case_list
	case_else 
  END match 
  ( 
	Absyn.MATCHexp(
				match1,
				expression, 
				local_element_list,
				case_list @ case_else,
				opt_string_comment,
				makeInfo lexArg (match1left, match2right))
  )

case_list:
	 case_stmt case_list 
		( case_stmt::case_list )
	| case_stmt	
		( [case_stmt] )

case_stmt:
	 CASE seq_pat opt_string_comment local_element_list equation_clause THEN expression SEMICOLON 
	( 
		Absyn.CASE(
			seq_pat, 
			local_element_list, 
			equation_clause, 
			expression,
			opt_string_comment,
			makeInfo lexArg (CASEleft, SEMICOLONright)) 
	)
	| CASE seq_pat opt_string_comment local_element_list THEN expression SEMICOLON 
	( 
		Absyn.CASE(
			seq_pat, 
			[], 
			Absyn.EQUATIONS(
				[],
				makeInfo lexArg (CASEleft, SEMICOLONright)), 
			expression,
			opt_string_comment,
			makeInfo lexArg (CASEleft, SEMICOLONright)) 
	)
	
case_else:
  (* empty *)
  ( [] )  
| ELSE opt_string_comment local_element_list equation_clause THEN expression SEMICOLON
  ( 
	[Absyn.ELSE( 
		local_element_list, 
		equation_clause, 
		expression,
		opt_string_comment,
		makeInfo lexArg (ELSEleft, SEMICOLONright))] 
  )


expression:
      ident AS expression
		(
		  Absyn.MBINDexp(
			ident, 
			expression, 
			makeInfo lexArg(identleft, expressionright))
		)
	|   LPAREN ident AS expression RPAREN
		(
		  Absyn.MBINDexp(
			ident, 
			expression, 
			makeInfo lexArg(identleft, expressionright))
		)
    | if_expression
		( if_expression )
	| simple_expression
		( simple_expression )
	| match_expression
		( match_expression )

if_expression:
	IF expression THEN expression elseif_expression_list ELSE expression
	( 
		Absyn.IFEXP(
			expression1,
			expression2, 
			expression3, 
			elseif_expression_list,
			makeInfo lexArg (IFleft, expressionright)) 
	)

elseif_expression_list:
	ELSEIF expression THEN expression elseif_expression_list
		( (expression, expression)::elseif_expression_list )
	|
		( [] )
	

simple_expression:
	logical_expression
		( logical_expression )
	| logical_expression COLONCOLON simple_expression
	( 
		Absyn.MSTRUCTexp(
			SOME(
			Absyn.PATHIDENT(
				Absyn.IDENT("cons", makeInfo lexArg (COLONCOLONleft, COLONCOLONright)), 
					makeInfo lexArg (logical_expressionleft, simple_expressionright))
			), 
			Absyn.FUNCTIONARGS(
					[
					Absyn.NAMEDARG(NONE, logical_expression, 
					makeInfo lexArg (logical_expressionleft, logical_expressionright)), 
					Absyn.NAMEDARG(NONE, simple_expression,
					makeInfo lexArg (simple_expressionleft, simple_expressionright))
					],
					makeInfo lexArg (logical_expressionleft, simple_expressionright)),
			makeInfo lexArg (logical_expressionleft, simple_expressionright)) 
	)
	| logical_expression COLON logical_expression
	( 
		Absyn.RANGE(
			logical_expression1, 
			NONE, 
			logical_expression2,
			makeInfo lexArg (logical_expression1left, logical_expression2right))
	)
	| logical_expression COLON logical_expression COLON logical_expression
	( 
		Absyn.RANGE(
			logical_expression1, 
			SOME(logical_expression2), 
			logical_expression3,
			makeInfo lexArg (logical_expression1left, logical_expression3right)) 
	)

logical_expression:
	  logical_term
		( logical_term )
	| logical_term OR logical_expression
	( 
		Absyn.LBINARY(
			logical_term, 
			Absyn.OR(makeInfo lexArg (ORleft, ORright)), 
			logical_expression,
			makeInfo lexArg (logical_termleft, logical_expressionright))
	)	
	

logical_term:
	logical_factor
		( logical_factor )
	| logical_factor AND logical_term
	( 
		Absyn.LBINARY(
			logical_factor, 
			Absyn.AND(makeInfo lexArg (ANDleft, ANDright)), 
			logical_term,
			makeInfo lexArg (logical_factorleft, logical_termright))
	)
	
logical_factor:
	relation
		( relation )
	| NOT relation %prec UNARY
	( 
		Absyn.LUNARY(
			Absyn.NOT(makeInfo lexArg (NOTleft, NOTright)), 
			relation,
			makeInfo lexArg (NOTleft, relationright))
	)
	

relation:
	arithmetic_expression 
		( arithmetic_expression )
	| arithmetic_expression rel_op arithmetic_expression
	( 
		Absyn.RELATION(
			arithmetic_expression1, 
			rel_op, 
			arithmetic_expression2,
			makeInfo lexArg (arithmetic_expression1left, arithmetic_expression2right)) 
	)
	| LPAREN arithmetic_expression rel_op arithmetic_expression RPAREN
	( 
		Absyn.RELATION(
			arithmetic_expression1, 
			rel_op, 
			arithmetic_expression2,
			makeInfo lexArg (arithmetic_expression1left, arithmetic_expression2right)) 
	)
	
	
rel_op:
(* integer operators *)
	LT_INT		( Absyn.LESS      (makeInfo lexArg (LT_INTleft, LT_INTright)) )
|	LE_INT		( Absyn.LESSEQ    (makeInfo lexArg (LE_INTleft, LE_INTright)) )
|	GT_INT		( Absyn.GREATER   (makeInfo lexArg (GT_INTleft, GT_INTright)) )
|	GE_INT  	( Absyn.GREATEREQ (makeInfo lexArg (GE_INTleft, GE_INTright)) )
|	EQEQ_INT	( Absyn.EQUAL     (makeInfo lexArg (EQEQ_INTleft, EQEQ_INTright)) )
|	NE_INT		( Absyn.NEQUAL    (makeInfo lexArg (NE_INTleft, NE_INTright)) )
(* real operators *)
|	LT_REAL		( Absyn.LESS_REAL      (makeInfo lexArg (LT_REALleft, LT_REALright)) )
|	LE_REAL		( Absyn.LESSEQ_REAL    (makeInfo lexArg (LE_REALleft, LE_REALright)) )
|	GT_REAL		( Absyn.GREATER_REAL   (makeInfo lexArg (GT_REALleft, GT_REALright)) )
|	GE_REAL  	( Absyn.GREATEREQ_REAL (makeInfo lexArg (GE_REALleft, GE_REALright)) )
|	EQEQ_REAL	( Absyn.EQUAL_REAL     (makeInfo lexArg (EQEQ_REALleft, EQEQ_REALright)) )
|	NE_REAL		( Absyn.NEQUAL_REAL    (makeInfo lexArg (NE_REALleft, NE_REALright)) )
(* string operators *)
|   EQEQ_STRING ( Absyn.EQEQ_STRING    (makeInfo lexArg (EQEQ_STRINGleft, EQEQ_STRINGright)) )

addsub_op:
	ADD_INT    ( Absyn.ADD(makeInfo lexArg (ADD_INTleft, ADD_INTright)) )
|	ADD_REAL   ( Absyn.ADD_REAL(makeInfo lexArg (ADD_REALleft, ADD_REALright)) )
|	SUB_INT    ( Absyn.SUB(makeInfo lexArg (SUB_INTleft, SUB_INTright)) )
|	SUB_REAL   ( Absyn.SUB_REAL(makeInfo lexArg (SUB_REALleft, SUB_REALright)) )
|	ADD_STRING ( Absyn.ADD_STRING(makeInfo lexArg (ADD_STRINGleft, ADD_STRINGright)) )
|	ADD_LIST   ( Absyn.ADD_LIST(makeInfo lexArg (ADD_LISTleft, ADD_LISTright)) )

arithmetic_expression:
	unary_arithmetic_expression
	 ( unary_arithmetic_expression )
	| unary_arithmetic_expression addsub_op arithmetic_expression
	( 
		Absyn.BINARY(
			unary_arithmetic_expression, 
			addsub_op, 
			arithmetic_expression,
			makeInfo lexArg (unary_arithmetic_expressionleft, arithmetic_expressionright)) 
	)	

unary_arithmetic_expression:
	term ( term )
	| ADD_INT term %prec UNARY 
	( 
		Absyn.UNARY(
			Absyn.UPLUS(makeInfo lexArg (ADD_INTleft, ADD_INTright)), 
			term,
			makeInfo lexArg (ADD_INTleft, termright))
	)
	| ADD_REAL term %prec UNARY 
	( 
		Absyn.UNARY(
			Absyn.UPLUS_REAL(makeInfo lexArg (ADD_REALleft, ADD_REALright)), 
			term,
			makeInfo lexArg (ADD_REALleft, termright))
	)	
	| SUB_INT term %prec UNARY
	( 
		Absyn.UNARY(
			Absyn.UMINUS(makeInfo lexArg (SUB_INTleft, SUB_INTright)), 
			term,
			makeInfo lexArg (SUB_INTleft, termright))
	)
	| SUB_REAL term %prec UNARY
	( 
		Absyn.UNARY(
			Absyn.UMINUS_REAL(makeInfo lexArg (SUB_REALleft, SUB_REALright)), 
			term,
			makeInfo lexArg (SUB_REALleft, termright))
	)

muldiv_op:
	STAR     ( Absyn.MUL      (makeInfo lexArg (STARleft, STARright)) ) 
|   MUL_REAL ( Absyn.MUL_REAL (makeInfo lexArg (MUL_REALleft, MUL_REALright)) )
|	DIV_INT  ( Absyn.DIV      (makeInfo lexArg (DIV_INTleft, DIV_INTright)) ) 
|   DIV_REAL ( Absyn.DIV_REAL (makeInfo lexArg (DIV_REALleft, DIV_REALright)) )

	
term:
	factor ( factor )
	| factor muldiv_op term 
	( 
		Absyn.BINARY(
			factor, 
			muldiv_op, 
			term,
			makeInfo lexArg (factorleft, termright)) 
	)	

pow_op:
	POW_REAL (Absyn.POW_REAL (makeInfo lexArg (POW_REALleft, POW_REALright)))

factor:
	primary ( primary )
	| primary pow_op primary 
	( 
		Absyn.BINARY(
			primary1, 
			pow_op, 
			primary2,
			makeInfo lexArg (primary1left, primary2right)) 
	)
	
expression_matrix_list:
	expression_list SEMICOLON expression_matrix_list
		( expression_list::expression_matrix_list )
	| expression_list
		( [ expression_list ] )
	

expression_matrix:
	expression_matrix_list
	( 
		Absyn.MATRIX(
			expression_matrix_list,
			makeInfo lexArg (expression_matrix_listleft, expression_matrix_listright)) 
	)
	
primary:
	(* 	Not used in MetaModelica
	CCON 
	( 
		Absyn.CHAR(
			CCON,
			makeInfo lexArg (CCONleft, CCONright)) 
	)
	| 
	*)
	ICON 
	( 
		Absyn.INTEGER(
			ICON,
			makeInfo lexArg (ICONleft, ICONright)) 
	)
	| RCON 
	( 
		Absyn.REAL(
			RCON,
			makeInfo lexArg (RCONleft, RCONright)) 
	)
	| SCON 
	( 
		Absyn.STRING(
			SCON,
			makeInfo lexArg (SCONleft, SCONright))
	)
	| FALSE 
	( 
		Absyn.BOOL(
			false,
			makeInfo lexArg (FALSEleft, FALSEright)) 
	)
	| TRUE 
	( 
		Absyn.BOOL(
			true,
			makeInfo lexArg (TRUEleft, TRUEright))
	)
	| WILD
	(
		( Absyn.MWILDexp(makeInfo lexArg (WILDleft, WILDright)) )
	)
	| component_reference LPAREN function_arguments RPAREN	
	( 
		Absyn.CALL(
			component_reference, 
			function_arguments,
			makeInfo lexArg (component_referenceleft, RPARENright)) 
	)
	(*	
	| LIST LPAREN function_arguments RPAREN	
	( 
		Absyn.CALL(
			Absyn.CREF_IDENT(
				Absyn.IDENT(
					"list", 
					makeInfo lexArg (LISTleft, LISTright)), 
				[],
				makeInfo lexArg (LISTleft, LISTright)), 
				function_arguments,
			makeInfo lexArg (LISTleft, RPARENright)) 
	)
	*)	
	(* lists *)
	| LIST LPAREN function_arguments RPAREN	
	( 
		Absyn.ARRAY(
			function_arguments,
			makeInfo lexArg (LISTleft, RPARENright)) 
	)	
	| LBRACE function_arguments RBRACE 
	( 
		Absyn.ARRAY(
			function_arguments,
			makeInfo lexArg (LBRACEleft, RBRACEright)) 
	)
	| LBRACE RBRACE 
	( 
		Absyn.ARRAY(
			Absyn.FUNCTIONARGS(
				[], 
				makeInfo lexArg (LBRACEleft, RBRACEright)),
				makeInfo lexArg (LBRACEleft, RBRACEright)) 
	)		
	| FAIL LPAREN RPAREN	
	( 
		Absyn.CALL(
			Absyn.CREF_IDENT(
				Absyn.IDENT(
					"fail", 
					makeInfo lexArg (FAILleft, FAILright)), 
				[],
				makeInfo lexArg (FAILleft, FAILright)), 
			Absyn.FUNCTIONARGS(
				[], 
				makeInfo lexArg (LPARENleft, RPARENright)),
			makeInfo lexArg (FAILleft, RPARENright)) 
	)	
	| LPAREN RPAREN	
	( 
		Absyn.MSTRUCTexp(
			NONE,   
			Absyn.FUNCTIONARGS([], makeInfo lexArg (LPARENleft, RPARENright)), 				
			makeInfo lexArg (LPARENleft, RPARENright)) 
	)		
	| component_reference LPAREN RPAREN	
	( 
		Absyn.CALL(
			component_reference, 
			Absyn.FUNCTIONARGS(
				[], 
				makeInfo lexArg (LPARENleft, RPARENright)),
			makeInfo lexArg (component_referenceleft, RPARENright)) 
	)		
	| component_reference 
	( 
	case component_reference of 
		Absyn.CREF_IDENT(ident, arrdim, info) =>
		if (List.length arrdim = 0)
		then
			Absyn.CREF(
				component_reference,
				makeInfo lexArg (component_referenceleft, component_referenceright)) 
		else
			let val [Absyn.SUBSCRIPT(exp, infoarr)] = arrdim 
			in
				Absyn.CALL(
				Absyn.CREF_IDENT(
					Absyn.IDENT(
						"array_get", 
						makeInfo lexArg (component_referenceleft, component_referenceright)), 
					[],
					makeInfo lexArg (component_referenceleft, component_referenceright)), 
				Absyn.FUNCTIONARGS(
					[Absyn.NAMEDARG(
						NONE, 
						Absyn.CREF(Absyn.CREF_IDENT(ident, [], info), info), 
						info),
						Absyn.NAMEDARG(NONE, exp, infoarr)], 
					makeInfo lexArg (component_referenceleft, component_referenceright)),
				makeInfo lexArg (component_referenceleft, component_referenceright)
			)				 					
			end
	|	Absyn.CREF_QUAL(ident1, arrdim1, Absyn.CREF_IDENT(ident2, arrdim2, info2), info1) =>
		if (List.length arrdim2 = 0)
		then
		Absyn.CREF(
			component_reference,
			makeInfo lexArg (component_referenceleft, component_referenceright)) 
		else
			let val [Absyn.SUBSCRIPT(exp, infoarr)] = arrdim2
			in
				Absyn.CALL(
				Absyn.CREF_IDENT(
					Absyn.IDENT(
						"array_get", 
						makeInfo lexArg (component_referenceleft, component_referenceright)), 
					[],
					makeInfo lexArg (component_referenceleft, component_referenceright)), 
				Absyn.FUNCTIONARGS(
					[Absyn.NAMEDARG(
						NONE, 
						Absyn.CREF(
							Absyn.CREF_QUAL(
								ident1,
								[],
								Absyn.CREF_IDENT(ident2, [], info2),
								info1),
							info1), 
						info1),
						Absyn.NAMEDARG(NONE, exp, infoarr)], 
					makeInfo lexArg (component_referenceleft, component_referenceright)),
				makeInfo lexArg (component_referenceleft, component_referenceright))				 					
			end
	| _ => 		
		Absyn.CREF(
			component_reference,
			makeInfo lexArg (component_referenceleft, component_referenceright)) 

	)
	| LPAREN function_arguments RPAREN 
	( 
		case function_arguments of
			Absyn.FUNCTIONARGS([Absyn.NAMEDARG(NONE, exp as Absyn.MSTRUCTexp(_), info)], infoFargs) 
			=> exp
		|	_ =>	Absyn.TUPLE(
						function_arguments,
						makeInfo lexArg (LPARENleft, RPARENright)) 
	)
	| LBRACK expression_matrix RBRACK ( expression_matrix )
	(*
	| LBRACE function_arguments RBRACE 
	(  
		Absyn.CALL(
			Absyn.CREF_IDENT(
				Absyn.IDENT(
					"array",
					makeInfo lexArg (LBRACEleft, RBRACEright)), 
				[],
				makeInfo lexArg (LBRACEleft, RBRACEright)), 
			function_arguments,
			makeInfo lexArg (LBRACEleft, RBRACEright)) 
	)
	*)
	
dot_name_path:
	  DOT name_path
		( SOME(name_path) )
	| (* Empty *)
		(NONE)

name_path:
	IDENT dot_name_path 
	(
		case dot_name_path of
		SOME(name_path) =>
			Absyn.QUALIFIED(
				Absyn.IDENT(
					IDENT, 
					makeInfo lexArg (IDENTleft, IDENTright) ), 
				name_path,
				makeInfo lexArg (IDENTleft, dot_name_pathright))
	   | NONE =>	
			Absyn.PATHIDENT(		
				Absyn.IDENT(
					IDENT, 
					makeInfo lexArg (IDENTleft, IDENTright)),
				makeInfo lexArg (IDENTleft, IDENTright)) 
	)
	| TUPLE 
	( Absyn.PATHIDENT(		
		Absyn.IDENT(
			"TUPLE", 
			makeInfo lexArg (TUPLEleft, TUPLEright)),
		 makeInfo lexArg (TUPLEleft, TUPLEright)) )
	| LIST 
	( Absyn.PATHIDENT(		
		Absyn.IDENT(
			"LIST", 
			makeInfo lexArg (LISTleft, LISTright)),
		 makeInfo lexArg (LISTleft, LISTright)) )

component_reference:
	  ident 
	(
			Absyn.CREF_IDENT(
				ident, 
				[],
				makeInfo lexArg (identleft, identright))
	)
	| ident DOT component_reference
	( 
		let val cref = 		  
		Absyn.CREF_QUAL(
			ident, 
			[], 
			component_reference,
			makeInfo lexArg (identleft, component_referenceright))
			val _ = 
				LexArg.addExternal (
					lexArg,
					Absyn.getCrefAsString cref, 
					identleft, component_referenceright)
			in 
				cref 
			end
	)
	| ident array_subscripts
	( 
		Absyn.CREF_IDENT(
			ident, 
			array_subscripts,
			makeInfo lexArg (identleft, array_subscriptsright)) 
	)

(*
function_call:
	LPAREN function_arguments RPAREN
		( function_arguments )
*)	

function_arguments:
	(*
	  expression_list FOR for_indices
		( Absyn.FOR_ITER_FARG(
			expression_list, 
			for_indices,
			makeInfo lexArg (expression_listleft, for_indicesright)) )
	|
	*)
	named_arguments
		( Absyn.FUNCTIONARGS(
			named_arguments,
			makeInfo lexArg (named_argumentsleft, named_argumentsright)) )		

named_arguments:
	named_argument COMMA named_arguments
		( named_argument::named_arguments )
	| named_argument
		( [ named_argument] )

named_argument:
	(*
	LPAREN ident AS expression RPAREN
		( Absyn.NAMEDARG(
			SOME(ident), 
			expression,
			makeInfo lexArg (identleft, expressionright)))
	|
	*) 
	  ident EQ expression
		( Absyn.NAMEDARG(
			SOME(ident), 
			expression,
			makeInfo lexArg (identleft, expressionright)))			
	| expression
		( Absyn.NAMEDARG(
			NONE, 
			expression,
			makeInfo lexArg (expressionleft, expressionright)))

expression_list:
	expression 
		( [expression] )
	| expression_list COMMA expression
		( expression_list @ [expression])
	
comment:
	string_comment annotation
		( SOME(
			Absyn.COMMENT(
				SOME(annotation), 
				SOME(string_comment),
				makeInfo lexArg (string_commentleft, annotationright))))
	| string_comment 
		( SOME(
			Absyn.COMMENT(
				NONE, 
				SOME(string_comment),
				makeInfo lexArg (string_commentleft, string_commentright))))			
	| annotation 
		( SOME(
			Absyn.COMMENT(
				SOME(annotation), 
				NONE,
				makeInfo lexArg (annotationleft, annotationright))))			
	| (* EMPTY *) 
		( NONE )			

string_comment_add:
	ADD_INT string_comment
		( string_comment )
		
string_comment:
	SCON
		( SCON )
	| SCON string_comment_add
		( SCON^string_comment_add )

opt_string_comment:
	string_comment
		( SOME(string_comment) )
	| (* Empty *)
		( NONE )
		    
annotation:
	ANNOTATION class_modification
		( Absyn.ANNOTATION(
			class_modification,
			makeInfo lexArg (ANNOTATIONleft, class_modificationright)) )
	
	
