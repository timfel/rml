module Main:
  with "absyn.rml"
  with "scanparse.rml"
  with "eval.rml"
 
  relation main: string list => ()
end
 
(* our generic component *)
val GComponent = 
      Absyn.GPROG(
	   [Absyn.HOOK1("hook1"),
	    Absyn.HOOK1("hook2"),
	    Absyn.HOOK1("hook3")],
	   [Absyn.ASSIGN("i1", Absyn.INTCONST(1)),
	    Absyn.ASSIGN("i2", Absyn.INTCONST(5)),
	    Absyn.ASSIGN("i3",
		 Absyn.BINARY(Absyn.VARIABLE "i1",
		        Absyn.ADD,
	            Absyn.VARIABLE "i2")),
	   Absyn.WRITE(Absyn.VARIABLE "i3")])

relation bind =
    (* if is namedecl leave it like that *)
    rule bind(rest, hookname, x, y) => restdecl &
	     list_append([z], restdecl) => l
	     -------------------------------------
		 bind((z as Absyn.NORMAL(normaldecl))::rest, hookname, x, y) => l

	(* if is a hook, then call bindHOOK1 on it *)
    rule Absyn.bindHOOK1(hookname,x,y, Absyn.HOOK1(name)) => HookOrDecl
	     --------------------------------------------------
	     bind(Absyn.HOOK1(name)::nil, hookname, x, y) => [HookOrDecl]

	rule bind(rest, hookname, x, y) => declrest &
	     Absyn.bindHOOK1(hookname,x,y,Absyn.HOOK1(name)) => HookOrDecl &
		 list_append([HookOrDecl], declrest) => decl
	     --------------------------------
		 bind(Absyn.HOOK1(name)::rest, hookname, x, y) => decl
end

relation bind_hook1 = 
	rule bind(gdecl,hookname,x,y) => decl
	     ------------------------------------------------------------------------------
	     bind_hook1(Absyn.GPROG(gdecl, stmts),hookname,x,y) => Absyn.GPROG(decl, stmts)
end

relation instantiate_component =
	rule bind_hook1(component, "hook1","i1","integer") => component1 &
		 bind_hook1(component1, "hook2","i2","real") => component2 &
		 bind_hook1(component2, "hook3","i3","real") => component3 
		 -----------------------------------------------------------
		 instantiate_component(component) => component3
end

relation check =
    (* if is namedecl then is ok! *)

	axiom check(nil) => true

    rule check(rest) => true
	     --------------------------
		 check(Absyn.NORMAL(x)::rest) => true

    (* if I find a hook, then is a problem! *)
	rule  print "Hook :" & 
		  print name & 
		  print " not bound!"
	      ---------------------
		  check(Absyn.HOOK1(name)::_) => false
end

relation check_component =

	rule  check(gdecl) => true
		  --------------------
	      check_component(Absyn.GPROG(gdecl, _)) => true

	rule  check(gdecl) => false &
	      print "\nnot all hooks instantiated!\n" 
		  -----------------------------------
	      check_component(Absyn.GPROG(gdecl, _)) => false
end

relation buildNormalDeclList = 
	axiom buildNormalDeclList(Absyn.NORMAL(x)::nil) => [x]

	rule  buildNormalDeclList(rest) => decl &
		  list_append([x], decl) => declnormal
	      --------------------------------------------
		  buildNormalDeclList(Absyn.NORMAL(x)::rest) => declnormal

	axiom buildNormalDeclList(Absyn.HOOK1(_)::rest) => fail
end

relation buildNormalAst=
	rule  buildNormalDeclList(gdecl) => decl
	      ----------------------------------
		  buildNormalAst(Absyn.GPROG(gdecl, stmts)) => Absyn.PROG(decl, stmts)
end

relation main: string list => () =

rule    ScanParse.scanparse(filename) => genericComponent &
		instantiate_component(genericComponent) => instantiated_component &
		print "Instantiated the component, bound the hooks!\n" &
        check_component(instantiated_component) => true &
		buildNormalAst(instantiated_component) => ast	&	
        Eval.evalprog ast &
		instantiate_component(GComponent) => instantiated_component &
		print "Instantiated the component, bound the hooks!\n" &
        check_component(instantiated_component) => true &
		buildNormalAst(instantiated_component) => ast	&	
        Eval.evalprog ast
        -------------------------------
		main (filename::_)

end