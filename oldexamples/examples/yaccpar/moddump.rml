(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 dump.rml
 ** module:      Dump
 ** description: debug printing
 **
 ** RCS: $Id: dump.rml,v 1.101 2004/11/30 15:18:52 petar Exp $
 **
 ** Printing routines for debugging of the AST.  These relations do
 ** nothing but print the data structures to the standard output.
 **
 ** The implementation of the relations are excluded from the report,
 ** as they occupy a lot of space and do not convey any useful
 ** semantic information.
 **
 ** The main entrypoint for this module is the relation "dump" which
 ** takes an entire program as an argument, and prints it all in
 ** Modelica source form. The other interface relations can be used
 ** to print smaller portions of a program.
 **)

(* emica Copied to use in RML-AST->MODELICA+-AST for debugging*)


module ModDump:
  
  with "absyn.rml"
(*  with "interactive.rml" *)							  

  type Ident = string

(* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation unparse_str: Absyn.Program => string
(*  relation dump_istmt: Interactive.InteractiveStmts => () *)
  relation direction_symbol: Absyn.Direction => string
  relation print_exp: Absyn.Exp => ()
  relation print_exp_str: Absyn.Exp => string
  relation print_code_str: Absyn.Code => string 
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_component_ref_str : Absyn.ComponentRef => string
  relation print_path : Absyn.Path => ()
  relation print_subscripts : Absyn.Subscript list => ()
  relation print_arraydim: Absyn.ArrayDim => ()
  relation print_arraydim_str: Absyn.ArrayDim => string 
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list_debug : (string, 'a list, 'a => (), string) => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation print_elementspec: Absyn.ElementSpec => ()
  relation print_named_arg: Absyn.NamedArg => () 
  relation print_import : Absyn.Import => () 
  relation op_symbol : Absyn.Operator => string
  relation print_bool : bool => ()
  relation print_select: (bool,string,string) => ()
  relation print_option : (('a option),('a => ())) => () 
  relation select_string: (bool,string,string) => string
  relation get_string_list : ('a list, 'a => string, string) => string
  relation get_option_str: ('a option, 'a => string) => string 
  relation unparse_annotation_option: (int, Absyn.Annotation option) => string 
  relation unparse_within: (int, Absyn.Within) => string 
  relation indent_str: (int) => string 
  relation unparse_algorithm_str: (int, Absyn.AlgorithmItem) => string 
  relation variability_symbol: Absyn.Variability => string
end




(*!ignorecode*)

(*with "classinf.rml"*)
(*with "rtopts.rml"*)
(*with "print.rml" *)
(*with "util.rml" *)
(*with "debug.rml"*)

(* Relations *)

relation dump : Absyn.Program => () =
	
  axiom	dump Absyn.PROGRAM([],_) => ()
	
  rule	print_class c & print "\n" &
	dump Absyn.PROGRAM(cs,w)
	------------------------
	dump Absyn.PROGRAM(c::cs,w) => ()

end

relation unparse_str : Absyn.Program => string =
	
  axiom	unparse_str Absyn.PROGRAM([],_) => ""
	
  rule	unparse_within(0,w) => s1 &
	unparse_class_list(0,cs) => s2 &
	string_append(s2,s1) => s3 &
	string_append(s3,"\n") => str
	------------------------
	unparse_str Absyn.PROGRAM(cs,w) => str
end

relation unparse_class_list: (int, Absyn.Class list) => string =

  axiom	unparse_class_list(_,[]) => ""
	
  rule	unparse_class_str(i,c,"","","") => s1 &
	unparse_class_list(i,cs) => s2 &
	string_append_list([s1,";\n",s2]) => res
	---------------------
	unparse_class_list(i, c::cs) => res
end

relation unparse_within: (int, Absyn.Within) => string =

  axiom unparse_within (_, Absyn.TOP) => ""
	
  rule	indent_str(i) => s1 &
	path_string p => s2 &
	string_append_list([s1, "within ", s2, ";\n"]) => str
	------------------------------
	unparse_within (i, Absyn.WITHIN(p)) => str
end

relation unparse_class_str: (int, Absyn.Class,string,string,string) => string =
  rule	indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	int_add(i,1) => i' &
	unparse_class_part_str_lst(i',parts,true) => s4 &
	unparse_string_comment_option(optcmt) => s5 &
	string_append_list([is, s2', s1, s2, re, io, s3, " ", n, s5, "\n", s4, is, "end ", n]) => str
	-----------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,optcmt)),fi,re,io) => str

  rule	indent_str(indent) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 & 
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_elementattr_str attr => s4 &
	string_append(s1,s2) => s5 &
	path_string i => s6 &
	get_option_str(dim,print_arraydim_str) => s7 &
	unparse_mod1_str m => s8 &
	unparse_comment_option(optcmt) => s9 &
	string_append_list([is,s2',s1,s2,re,io,s3," ",n," = ",s4,s5,s6,s7,s8,s9]) 
	  => str
	------------------------------
	unparse_class_str(indent,Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED(i,dim,attr,m,optcmt)),fi,re,io) => str

(*ADDED*)	
  rule	indent_str(indent) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 & 
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	string_append(s1,s2) => s5 &
	path_string i => s6 &
        path_string_list paths => s7 &
	unparse_comment_option(optcmt) => s9 & 
	string_append_list([is,s2',s1,s2,re,io,s3," ",n," = ",s5,s6,"<",s7,">",s9]) 
	  => str
	------------------------------
	unparse_class_str(indent,Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED_TYPES(i,paths,optcmt)),fi,re,io) => str

(*END ADDED*)

  rule	indent_str(i) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_enumliterals(l) => s4 &
	unparse_comment_option(cmt) => s5 &
	string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= enumeration(",s4,")",s5]) => str
	-------------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(l,cmt)),fi,re,io) => str    

end 

relation path_string_list =

  axiom	path_string_list([]) => ""

  rule	path_string last => str
	-------------------
	path_string_list(last::[]) => str
	
  rule	path_string first => s1 &
	path_string_list rest => s2 &
	string_append_list([s1,",",s2]) => str
	------------------------------
	path_string_list(first::rest) => str

end

relation unparse_comment_option: (Absyn.Comment option) => string =

	axiom unparse_comment_option(NONE) => ""
	
  rule	unparse_annotation_option(0,annopt) => s1 &
	string_append_list([" \"",cmt,"\"", s1]) => str
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,SOME(cmt)))) => str
	
  rule	unparse_annotation_option(0,annopt) => str 
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,NONE))) => str
	
end

relation unparse_enumliterals : Absyn.EnumLiteral list => string =
	
  axiom	unparse_enumliterals([]) => ""
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_enumliterals(a::b)=> s2 &
	string_append_list([str,s1,", ",s2]) => res
	---------------------------
	unparse_enumliterals(Absyn.ENUMLITERAL(str,optcmt)::a::b) => res
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_comment_option(optcmt2) => s2 &
	string_append_list([str,s1,", ",str2,s2]) => res
	---------------------------
	unparse_enumliterals([Absyn.ENUMLITERAL(str,optcmt),Absyn.ENUMLITERAL(str2,optcmt2)]) => res
end

relation unparse_restriction_str : Absyn.Restriction => string =
	
  axiom	unparse_restriction_str Absyn.R_CLASS			=> "class"
  axiom	unparse_restriction_str Absyn.R_MODEL			=> "model"
  axiom	unparse_restriction_str Absyn.R_RECORD			=> "record"
  axiom	unparse_restriction_str Absyn.R_BLOCK			=> "block"
  axiom	unparse_restriction_str Absyn.R_CONNECTOR		=> "connector"
  axiom	unparse_restriction_str Absyn.R_TYPE			=> "type"
  axiom	unparse_restriction_str Absyn.R_PACKAGE			=> "package"
  axiom	unparse_restriction_str Absyn.R_FUNCTION		=> "function"
  axiom	unparse_restriction_str  Absyn.R_PREDEFINED_INT		=> "Integer"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_REAL		=> "Real"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_STRING	=> "string"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_BOOL		=> "Boolean"
  axiom unparse_restriction_str Absyn.R_UNIONTYPE               => "uniontype"	
end
(*
relation dump_istmt : Interactive.InteractiveStmts => () =
  rule	Print.print_buf ("IALG(") &
	print_algorithmitem(alg) => () &
	Print.print_buf ")\n" 
	--------------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IALG(alg)],_)) => ()
	
  rule	Print.print_buf ("IEXP(") &
	print_exp(expr) &
	Print.print_buf ")\n" 
	----------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IEXP(expr)],_)) => ()
	
  rule Print.print_buf "IALG(" &
	print_algorithmitem(alg) => () &
	Print.print_buf "," &
	dump_istmt(Interactive.ISTMTS(l,sc)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IALG(alg)::l,sc)) => ()
	
  rule Print.print_buf "IEXP(" &
	print_exp(expr) => () &
	Print.print_buf "," &
	dump_istmt(Interactive.ISTMTS(l,sc)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IEXP(expr)::l,sc)) => ()
	
  axiom	dump_istmt(_) => ()
end *)
(*ADDED *)
relation string_append_list : string list => string =
	
  axiom string_append_list [] => ""

  axiom	string_append_list [f] => f

  rule	string_append_list r => r' &
	string_append(f,r') => str
	---------------------------
	string_append_list f::r => str
end



relation fprint: (string, string) => () =

  rule	dummy => true & 
	print str
	-------------------
	fprint (flag, str)

  axiom	fprint (_,_)

end


relation fprintln: (string, string) => () =

  rule	dummy => true & 
	print str &
	print "\n"
	-------------------
	fprintln (flag, str)

  axiom	fprintln (_,_)

end


relation fprintl: (string, string list) => () =

  rule	dummy => true & 
	make_string strlist => str &
	print str
	-------------------
	fprintl (flag, strlist)

  axiom	fprintl (_,_)

end

relation dummy =

	
  axiom	dummy => false
end

relation make_string : string list => string =

  axiom	make_string [] => ""

  rule	make_string rest => res &
	string_append (first, res) => res'
	----------------------------------
	make_string first::rest => res'

end

relation path_string: Absyn.Path => string =

  rule	path_string2 (path, ".") => s
	-----------------------------
	path_string path => s
end

relation path_string2: (Absyn.Path, string) => string =

  axiom	path_string2(Absyn.IDENT(s),_) => s
  
  rule	path_string2(n,str) => ns &
	string_append(s,str) => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string2(Absyn.QUALIFIED(s,n), str) => ss
	
end

relation print_restr : Absyn.Restriction => () =

  rule	unparse_restriction_str restr => str &
	print str
	----------------
	print_restr restr

end

(* END ADDED *)


relation print_class: Absyn.Class => () =
	
  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print_list_debug("print_class1",parts,print_class_part,",") & print ")"
	----------------------------------------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,_))) => ()
	
  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print ") = " & print_path(i) &
	print_class_modification(m)
	----------------------------------------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED(i,_,_,m,_))) => ()
	
  rule	print_class_restriction(r) & print "(" &
	print n & print "," &
	print_select(p,"PARTIAL,","") &
	print "ENUMERATION(...)\n"
	----------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(l,_))) => ()
end

(**)

relation print_class_restriction: Absyn.Restriction => () =

  rule	print_restr re
	-----------------------
	print_class_restriction re
	
end


(**)

relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	print "(" & print_list_debug("print_class_modification",l,print_element_arg,",") & print ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

relation unparse_class_modification_str: Absyn.Modification => string =

  axiom	unparse_class_modification_str(Absyn.CLASSMOD([],_)) => ""
	
  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &	
	string_append("(",s1) => s2 &
	string_append(s2,")") => str 
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(l,NONE)) => str

  rule	print_exp_str e => s1 &
	string_append_list(["=",s1]) => str
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(_,SOME(e))) => str
end
(**)

relation print_element_arg =
	
  rule	print "ARG(" &
	print_select(f,"FINAL,",",") &
	print_component_ref(r) &
	print_opt_modification(optm) &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,each,r,optm,optcmt))

  rule	print "REDECLARATION(" &
	print_select(f,"FINAL,",",") &
	print_elementspec spec &
	print ",_)"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,each,spec,_))

end

relation unparse_element_arg_str: (Absyn.ElementArg) => string =
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","") => s2 &
	print_component_ref_str(r) => s3 &
	unparse_opt_modification_str(optm) => s4 &
	unparse_string_comment_option(optstr) => s5 &
	string_append_list([s1, s2, s3, s4, s5]) => str
	-------------------------------------------
	unparse_element_arg_str(Absyn.MODIFICATION(f,each,r,optm,optstr)) => str
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	unparse_elementspec_str(0, spec,s2,"","") => s3 &
	unparse_elementspec_str(0,constropt,"","","") => s4 &
	string_append_list([s1,s2,"redeclare ",s3," ",s4]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,each, spec,SOME(constropt))) => str

  rule	(* Since unparse_elementspec_str does not print "replaceable" we need to check for it here*)
	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	select_string(repl, "replaceable ","") => s3 &
	unparse_elementspec_str(0, spec,"",s3,"") => s4 &
	unparse_elementspec_str(0,constropt,"","","") => s5 &
	string_append_list([s1,s2,"redeclare ",s4," ",s5]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,each, spec as Absyn.CLASSDEF(repl,cl) ,SOME(constropt))) => str

  rule	(* Since unparse_elementspec_str does not print "replaceable" we need to check for it here*)
	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	select_string(repl, "replaceable ","") => s3 &
	unparse_elementspec_str(0, spec,"",s3,"") => s4 &
	string_append_list([s1,s2,"redeclare ",s4]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,each, spec as Absyn.CLASSDEF(repl,cl),NONE)) => str

  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	unparse_elementspec_str(0, spec,"","","") => s3 &
	string_append_list([s1,s2,"redeclare ",s3]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,each, spec,NONE)) => str
end

(**)

relation unparse_each_str: (Absyn.Each) => string =

  axiom	unparse_each_str(Absyn.EACH) => "each "

  axiom	unparse_each_str(Absyn.NON_EACH) => ""
end
				
relation print_class_part: Absyn.ClassPart => () =

  rule	print "PUBLIC(" & print_elementitems(el) & print ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule	print "PROTECTED(" & print_elementitems(el) & print ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule	print "EQUATIONS(" &
	print_list_debug("print_class_part",eqs,print_equationitem,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))

  rule	print "INITIALEQUATIONS(" &
	print_list_debug("print_class_part",eqs,print_equationitem,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.INITIALEQUATIONS(eqs))
	
  rule	print "ALGORITHMS(" &
	print_list_debug("print_class_part",eqs,print_algorithmitem,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(eqs))

  rule	print "INITIALALGORITHMS(" &
	print_list_debug("print_class_part",eqs,print_algorithmitem,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.INITIALALGORITHMS(eqs))

  rule	print "EXTERNAL(" &
	print_external_decl (edecl) &
	print ")"
	-------------------
	print_class_part(Absyn.EXTERNAL(edecl,_))

end

relation print_external_decl : Absyn.ExternalDecl => () =

  rule	get_option_str (id, identity) => idstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	string_append_list([idstr, ", ", crefstr, ", (",
				 expstr, ")"]) => str &
	print str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, NONE, cref, exps)

  rule	get_option_str (id, identity) => idstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	string_append_list([idstr, ", \"", lang, "\", ", crefstr, ", (",
				 expstr, ")"]) => str &
	print str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, SOME(lang), cref, exps)

end

relation unparse_class_part_str_lst: (int, Absyn.ClassPart list,bool) 
	  => string =

  axiom	unparse_class_part_str_lst (_,[],false) => ""

  rule	unparse_class_part_str(i,x,skippublic) => s1 &
	unparse_class_part_str_lst(i,xs,false) => s2 &
	string_append(s1,s2) => res
	----------------------
	unparse_class_part_str_lst(i,x::xs,skippublic) => res
end

relation unparse_class_part_str: (int, Absyn.ClassPart,bool) => string =

axiom	unparse_class_part_str(i, Absyn.PUBLIC([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.PROTECTED([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.EQUATIONS([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.INITIALEQUATIONS([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.ALGORITHMS([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.INITIALALGORITHMS([]),_) => ""

  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list([is,s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.PUBLIC(el),true) => str
	
  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list([is,"public \n",s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.PUBLIC(el),false) => str

  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list([is,"protected \n",s1]) => str 
	---------------------------------------
	unparse_class_part_str(i, Absyn.PROTECTED(el),_) => str
	
  rule	unparse_equationitem_str_lst(i,eqs,";\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list(["\n",is,"equation \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.EQUATIONS(eqs),_) => str
				
  rule	unparse_equationitem_str_lst(i,eqs,";\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list(["\n",is,"initial equation \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.INITIALEQUATIONS(eqs),_) => str

  rule	unparse_algorithm_str_lst(i,eqs,"\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list([is,"algorithm \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.ALGORITHMS(eqs),_) => str

  rule	unparse_algorithm_str_lst(i,eqs,"\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list([is,"initial algorithm \n",s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.INITIALALGORITHMS(eqs),_) => str

  rule	get_extlang_str(lang) => langstr &
	print_component_ref_str output => outputstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	indent_str(i) => is &
	unparse_annotation_option (i,ann) => annstr &
	string_append_list(["\n", is, "external ",langstr," ", outputstr, "=",ident,"(",expstr,") ",annstr,";\n"]) => str
	--------------------------------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,SOME(output),expl),ann),_)
	    => str

  rule	get_extlang_str(lang) => langstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	indent_str(i) => is &
	unparse_annotation_option (i,ann) => annstr &
	string_append_list(["\n", is, "external ", langstr," ",ident,"(",expstr,") ",annstr,";\n"]) => str
	--------------------------------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,NONE,expl),ann),_) 
	    => str

  rule	indent_str(i) => is &
	get_extlang_str(lang) => langstr &
	unparse_annotation_option (i,ann) => annstr &
	string_append_list(["\n",is,"external ",langstr," ",annstr,";\n"]) => res
	-----------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(NONE,lang,NONE,_),ann),_) 
	    => res
end

relation get_extlang_str: (string option) => string =
	
  axiom	get_extlang_str(NONE) => ""

  rule	string_append_list(["\"",str,"\""]) => res
	-------------
	get_extlang_str(SOME(str)) => res
end
(**)

relation print_elementitems: Absyn.ElementItem list => () =
  axiom print_elementitems [] => ()

  rule  print_element e
	---------------
	print_elementitems[ Absyn.ELEMENTITEM(e)]

  rule	print_annotation a
	------------------
	print_elementitems([Absyn.ANNOTATIONITEM(a)])
	
  rule	print_element e &
	print_elementitems els
	---------------
	print_elementitems Absyn.ELEMENTITEM(e)::els 

  rule	print_annotation a &
	print_elementitems els
	------------------
	print_elementitems Absyn.ANNOTATIONITEM(a)::els

  rule	print "Error print_elementitems\n"
	--------------
	print_elementitems _ 
end

relation print_annotation: Absyn.Annotation => () =	
  rule	print "ANNOTATION(" &
	print_modification Absyn.CLASSMOD(mod,NONE) &
	print ")"
	---------
	print_annotation(Absyn.ANNOTATION(mod))
end
	
relation unparse_elementitem_str_lst: (int, Absyn.ElementItem list) => string =

  axiom	unparse_elementitem_str_lst(_, []) => ""
	
  rule	unparse_elementitem_str(i, x) => s1 &
	unparse_elementitem_str_lst(i, xs) => s2 &
	string_append_list([s1, "\n", s2]) => res
	----------------
	unparse_elementitem_str_lst(i, x::xs) => res
end

relation unparse_elementitem_str: (int, Absyn.ElementItem) => string =

  rule	unparse_element_str(i, e) => str
	----------------------------
	unparse_elementitem_str (i, Absyn.ELEMENTITEM(e)) => str

  rule	unparse_annotation_option (i,SOME(a)) => s1 &
	string_append(s1,";") => str 
	-------------------------------
	unparse_elementitem_str(i, Absyn.ANNOTATIONITEM(a)) => str
	
end

relation unparse_annotation_option: (int, Absyn.Annotation option) => string =	
  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	string_append(" annotation",s1) => s2 &
	string_append(s2,"") => str
	----------------------------
	unparse_annotation_option(0, SOME(Absyn.ANNOTATION(mod))) => str

  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	indent_str(i) => is &
	string_append_list([is,"annotation",s1]) => str 
	----------------------------
	unparse_annotation_option(i, SOME(Absyn.ANNOTATION(mod))) => str

  axiom	unparse_annotation_option(_, NONE) => ""
end



relation print_element: Absyn.Element => () =
	
  rule	print "ELEMENT(" & print_select(final,"FINAL,","") &
	print_innerouter inout &
	print ", " &
	print_elementspec spec & 
	print ", " &
	print filename &
	print ", " & 
	int_string lineno => s1 &
    	print s1 &
	print ")"
	---------------------------
	print_element (Absyn.ELEMENT(final,repl,inout,_,spec,filename,lineno,constr))

end

relation unparse_element_str: (int, Absyn.Element) => string = 

  rule	select_string(final, "final ", "") => s1 &
	select_string(repl, "replaceable ", "") => s2 &
	unparse_innerouter_str inout => s3 &
	unparse_elementspec_str(i, spec,s1,s2,s3) => s4 &	
	int_string(lineno) => s5 &
	indent_str(i) => is &
        string_append_list([s4, ";"]) => str
(*	Util.string_append_list([s4, " ", filename," ", s5,";"]) => str *)
	----------------------------
	unparse_element_str(i, Absyn.ELEMENT(final,repl,inout,_,spec,filename,lineno,constr)) => str
end


relation print_innerouter: Absyn.InnerOuter => () =
   rule print "INNER"
	----------------------------
	print_innerouter(Absyn.INNER)

   rule print "OUTER"
        ----------------------------
        print_innerouter(Absyn.OUTER)

   rule print " "
        ----------------------------------
        print_innerouter(Absyn.UNSPECIFIED)
end

relation unparse_innerouter_str: Absyn.InnerOuter => string =
	
  axiom	unparse_innerouter_str(Absyn.INNER) => "inner "

  axiom	unparse_innerouter_str(Absyn.OUTER) => "outer "

  axiom	unparse_innerouter_str(Absyn.UNSPECIFIED) => ""
end
(**)

relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	print "CLASSDEF(" & print_select(repl,"REPLACEABLE,","") &
	print_class cl & print ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
	
  rule	print "EXTENDS(" & print_path p & print "," &
	print_list_debug("print_elementspec",l,print_element_arg,",") & print ")"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	print "COMPONENTS(" &
	print_elementattr(attr) & print "," &
	print_path(t) & print "," &
	print_list_debug("print_elementspec",cs, print_componentitem, ",") &
	print ")"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	print "IMPORT(" &
	print_import i &
	print ")"
	--------
	print_elementspec(Absyn.IMPORT(i,_))

  rule	print " ##ERROR## "
	-------------------
	print_elementspec(_)

end

relation unparse_elementspec_str: (int, Absyn.ElementSpec,string,string,string) => string =
	
  rule	unparse_class_str(i,cl,f,r,io) => str 
	-------------------------
	unparse_elementspec_str(i, Absyn.CLASSDEF(repl,cl),f,r,io) => str
	
  rule	path_string p => s1 &
	string_append("extends ",s1) => s2 &
	indent_str(i) => is &
	string_append_list([is,f,r,io,s2]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.EXTENDS(p,[]),f,r,io) => str

  rule	path_string p => s1 &
	string_append("extends ",s1) => s2 &
	get_string_list(l,unparse_element_arg_str,",") => s3 &
	indent_str(i) => is &
	string_append_list([is,f,r,io,s2,"(",s3,")"]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.EXTENDS(p,l),f,r,io) => str

  rule	path_string(t) => s1 &
	unparse_elementattr_str(attr) => s2 &
	unparse_arraydim_in_attr(attr) => ad &
	get_string_list(cs, unparse_componentitem_str, ",") => s3 &
	indent_str(i) => is &
	string_append_list([is, f,r,io,s2, s1,ad, " ",  s3]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.COMPONENTS(attr,t,cs),f,r,io) => str
	
  rule	unparse_import_str i => s1 &
	string_append("import ",s1) => s2 &
	indent_str(indent) => is &
	string_append_list([is,f,r,io,s2]) => str
	----------------------------
	unparse_elementspec_str(indent, Absyn.IMPORT(i,_),f,r,io) => str

  rule	print " ##ERROR## "
	-------------------
	unparse_elementspec_str(_,_,_,_,_) => ""

end

relation print_import : Absyn.Import => () =

  rule	print i & print " = " &
	print_path p
	-----------------------
	print_import(Absyn.NAMED_IMPORT(i,p))

  rule	print_path p
	-------------
	print_import(Absyn.QUAL_IMPORT(p))

  rule	print_path p & print ".*"
	--------------------------
	print_import(Absyn.UNQUAL_IMPORT(p))
		     
end
relation unparse_import_str : Absyn.Import => string =

  rule	string_append(i," = ") => s1 &
	path_string p => s2 &
	string_append(s1,s2) => str
	-----------------------
	unparse_import_str(Absyn.NAMED_IMPORT(i,p)) => str

  rule	path_string p => str
	-------------
	unparse_import_str(Absyn.QUAL_IMPORT(p)) => str

  rule	path_string p => s1 &
	string_append(s1, ".*") => str
	--------------------------
	unparse_import_str(Absyn.UNQUAL_IMPORT(p)) => str
end

relation print_elementattr: Absyn.ElementAttributes => () =

  rule	print "ATTR(" &
	select_string(fl,"FLOW,","") => fs &
	variability_symbol(var) => vs &
	direction_symbol(dir) => ds &
	let sl = [fs,vs,ds] &
	print_list_debug("print_elementattr",sl, print, ",") &
	print ")"
	-----------------------------------
	print_elementattr(Absyn.ATTR(fl,var,dir,adim))

  rule	print " ##ERROR## print_elementattr"
	-------------------
	print_elementattr(_)

end

relation unparse_elementattr_str: Absyn.ElementAttributes => string =

  rule	
	select_string(fl,"flow ","") => fs &
	unparse_variability_symbol_str(var) => vs &
	unparse_direction_symbol_str(dir) => ds &
	string_append_list([fs,vs,ds]) => str
	------------------------------------------
	unparse_elementattr_str(Absyn.ATTR(fl,var,dir,adim)) => str

  rule	print " ##ERROR## unparse_elementattr_str"
	-------------------
	unparse_elementattr_str(_) => ""

end

relation unparse_arraydim_in_attr: Absyn.ElementAttributes => string =

  rule	print_arraydim_str(adim) => str
	-----------------------------------
	unparse_arraydim_in_attr(Absyn.ATTR(_,_,_,adim)) => str
  axiom	unparse_arraydim_in_attr(_) => ""
end


relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => ""
  axiom	variability_symbol(Absyn.DISCRETE) => "DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "PARAM"
  axiom	variability_symbol(Absyn.CONST) => "CONST"

end

relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => ""
  axiom	direction_symbol(Absyn.INPUT) => "INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "OUTPUT"

end


relation unparse_variability_symbol_str: Absyn.Variability => string =

  axiom unparse_variability_symbol_str(Absyn.VAR) => ""
  axiom	unparse_variability_symbol_str(Absyn.DISCRETE) => "discrete "
  axiom	unparse_variability_symbol_str(Absyn.PARAM) => "parameter "
  axiom	unparse_variability_symbol_str(Absyn.CONST) => "constant "

end

relation unparse_direction_symbol_str: Absyn.Direction => string =

  axiom unparse_direction_symbol_str(Absyn.BIDIR) => ""
  axiom	unparse_direction_symbol_str(Absyn.INPUT) => "input "
  axiom	unparse_direction_symbol_str(Absyn.OUTPUT) => "output "

end

(**)

relation print_component: Absyn.Component => () =

  rule	print n &
	print_arraydim a &
	print_option(m,print_modification) 
	------------------------------------------
	print_component(Absyn.COMPONENT(n,a,m))

end

relation print_componentitem: Absyn.ComponentItem => () =

  rule	print "COMPONENTITEM(" &
	print_component c &
	print ",<comment>)"
	------------------------------------------
	print_componentitem(Absyn.COMPONENTITEM(c,optcmt))
end

relation unparse_component_str: Absyn.Component => string =

  rule	print_arraydim_str a => s1 &
	string_append(n,s1) => s2 &
	get_option_str(m,unparse_modification_str) => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_component_str(Absyn.COMPONENT(n,a,m)) => str
end

relation unparse_componentitem_str: Absyn.ComponentItem => string =

  rule	unparse_component_str c => s1 &
	unparse_comment_option cmtopt => s2 &
	string_append(s1,s2) => str
	------------------------------------------
	unparse_componentitem_str(Absyn.COMPONENTITEM(c,cmtopt)) => str
end

(**)

relation print_arraydim: Absyn.ArrayDim => () =

  rule	print_subscripts(s)
	-------------------
	print_arraydim(s)
	
end

relation print_arraydim_str: Absyn.ArrayDim => string =

  rule	print_subscripts_str (s) => str
	-------------------------------
	print_arraydim_str(s) => str
	
end

relation print_subscript: Absyn.Subscript => () =

  rule	print ":"
	---------
	print_subscript(Absyn.NOSUB)

  rule	print_exp(e1)
	----------
	print_subscript(Absyn.SUBSCRIPT(e1))

end

relation print_subscript_str: Absyn.Subscript => string =

  axiom	print_subscript_str (Absyn.NOSUB) => ":"

  rule	print_exp_str (e1) => s
	-----------------------
	print_subscript_str (Absyn.SUBSCRIPT(e1)) => s

end

(* Modifications *)
relation print_opt_modification: Absyn.Modification option => () =

  rule	print_modification(m)
	----------------------
	print_opt_modification(SOME(m)) => ()

  axiom	print_opt_modification(NONE) => ()
end

relation print_modification: Absyn.Modification => () =
	
  rule	print_mod1 l & print_mod2 e
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	print "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	print "(" &
	print_list_debug("print_mod1",l,print_element_arg,",") &
	print ")"
	------------------------------------
	print_mod1 l

end

relation print_mod2 : Absyn.Exp option => () =

  axiom	print_mod2 NONE

  rule	print " = " & print_exp(e)
	-------------------------
	print_mod2 SOME(e)

end

relation unparse_opt_modification_str: Absyn.Modification option => string =

  rule	unparse_modification_str(opt) => str
	-------------------
	unparse_opt_modification_str(SOME(opt)) => str

  axiom	unparse_opt_modification_str(NONE) => ""
end
relation unparse_modification_str: Absyn.Modification => string =
	(* Special case for empty modifications *)
  axiom	unparse_modification_str(Absyn.CLASSMOD([],NONE)) => "()"

  rule	unparse_mod1_str l => s1 & 
	unparse_mod2_str e => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_modification_str(Absyn.CLASSMOD(l, e)) => str
	
  rule	print " Failure MODIFICATION \n"
	-------------
	unparse_modification_str(_) => ""	
end

relation unparse_mod1_str: Absyn.ElementArg list => string =

  axiom	unparse_mod1_str [] => ""

  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str
	------------------------------------
	unparse_mod1_str l => str
end

relation unparse_mod2_str : Absyn.Exp option => string =

  axiom	unparse_mod2_str NONE => ""

  rule	print_exp_str(e) => s1 &
	string_append("=",s1) => str
	-------------------------
	unparse_mod2_str SOME(e) => str
end

(* Equations *)

relation print_equation: Absyn.Equation => () =
	

  rule	print "IF (" & print_exp(e) & print ") THEN " &
	print_list_debug("print_equation",tb, print_equationitem, ";") &
	print_list_debug("print_equation",eb, print_eq_elseif, " ") &
	print " ELSE " & print_list_debug("print_equation",fb, print_equationitem, ";")
	----------------------------------------------------
	print_equation(Absyn.EQ_IF(e,tb,eb,fb))
	
  rule	print "EQ_EQUALS(" & print_exp(e1) & print "," &
	print_exp(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	print "EQ_CONNECT(" & print_component_ref(e1) & print "," &
	print_component_ref(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list_debug("print_equation",el, print_equationitem, ";") & print "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	print " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

relation print_equationitem: Absyn.EquationItem => () =
  rule	print "EQUATIONITEM(" &
	print_equation eq &
	print ", <comment>)\n"
	-------------------------------
	print_equationitem Absyn.EQUATIONITEM(eq,_)
	
  rule	print "EQUATIONITEMANN(<annotation>)\n" 
	--------------
	print_equationitem Absyn.EQUATIONITEMANN(_)
end

relation unparse_equation_str: (int, Absyn.Equation) => string =
	

(*ADDED*)
  rule	unparse_pattern(pat) => s1 &
	print_exp_str(exp) => s2 &
	string_append_list(["let ", s1, " = ",s2]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_LET(pat,exp)) => str

  rule	print_exp_str(exp) => s1 &
	string_append_list([id, " = ", s1]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_STRUCTEQUAL(id,exp)) => str

  rule	unparse_equation_str(i,fe) => s1 &
	string_append_list(["not ", s1]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_NOT(fe::elist)) => str
	
  rule	path_string(path) => s1 &
	print_function_args_str(fargs) => s2 &
	unparse_pattern(pat) => s3 &
	indent_str(i) => is &
	string_append_list([is,s1,"(",s2,") = ",s3]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_CALL(path,fargs,pat)) => str

(*END ADDED*)
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i',tb,";\n") => s2 &
	indent_str(i) => is &
	string_append_list(["if ", s1, " then\n",is, s2,is,"end if"]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_IF(e,tb,[],[])) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i',tb,";\n") => s2 &
	unparse_eq_elseif_str_lst(i',eb, "\n") => s3 &
	unparse_equationitem_str_lst(i',fb,";\n") => s4 &
	indent_str(i) => is &
	string_append_list([is,"if ", s1, " then\n",s2, s3, "\n",is,"else\n", s4,"\n", is, "end if"]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_IF(e,tb,eb,fb)) => str
	
  rule	print_exp_str(e1) => s1 &
	print_exp_str(e2) => s2 &
	indent_str(i) => is &
	string_append_list([is,s1, "=", s2]) => str
	-------------------------------------------
	unparse_equation_str(i,Absyn.EQ_EQUALS(e1,e2)) => str
	
  rule	print_component_ref_str(e1) => s1 &
	print_component_ref_str(e2) => s2 &
	indent_str(i) => is &
	string_append_list([is,"connect(", s1, ",", s2, ")"]) => str
	-------------------------------------------
	unparse_equation_str(i, Absyn.EQ_CONNECT(e1,e2)) => str
	
  rule	print_exp_str(e) => s1 &
	unparse_equationitem_str_lst(indent,el,";\n") => s2 &
	indent_str(indent) => is &
	string_append_list([is,"for ", i, " in ", s1, " loop\n", s2, "\n",is,"end for"]) => str
	----------------------------------------------------------
	unparse_equation_str (indent,Absyn.EQ_FOR(i,e,el)) => str

  rule	print_function_args_str(fargs) => s2 &
	string_append_list([id,"(",s2,")"]) => str
	-----------------------------------------------
	unparse_equation_str(i, Absyn.EQ_NORETCALL(id,fargs)) => str

  rule	print_exp_str(exp) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i', eql, ";\n") => s2 &
	indent_str(i) => is &
	unparse_eq_elsewhen_str_lst(i',eqlelse) => s4 &
	string_append_list([is,"when ", s1, " then\n", is, s2, is, s4, "\n", is, "end when"]) => str
	-------------------
	unparse_equation_str(i, Absyn.EQ_WHEN_E(exp,eql,eqlelse)) => str

  rule	print " ** Failure! UNKNOWN EQUATION ** "
	--------------------------------
	unparse_equation_str(_,_) => ""
	
end

relation unparse_equationitem_str_lst: (int, Absyn.EquationItem list, string) 
	  => string =

  axiom	 unparse_equationitem_str_lst(_,[],_) => ""
	
  rule	unparse_equationitem_str(i, x) => s1 &
	unparse_equationitem_str_lst(i, xs, sep) => s2 &
	string_append_list([s1,sep,s2]) => res
	----------------------
	unparse_equationitem_str_lst(i,x::xs,sep) => res
end
	
relation unparse_equationitem_str: (int, Absyn.EquationItem) => string =
  rule	
	unparse_equation_str (i, eq) => s1 &
	unparse_comment_option(optcmt) => s2 &
	string_append(s1,s2) => str
	---------------------------
	unparse_equationitem_str (i, Absyn.EQUATIONITEM(eq,optcmt)) => str 
	
  rule	unparse_annotation_option(i,SOME(ann)) => str
	-------------------------------------------
	unparse_equationitem_str (i, Absyn.EQUATIONITEMANN(ann)) => str
end
	
(**)
	
relation print_eq_elseif : (Absyn.Exp * Absyn.EquationItem list) => () =
	
  rule	print " ELSEIF " & print_exp e & print " THEN " &
	print_list_debug("print_eq_elseif",el, print_equationitem, ";")
	-----------------------------------
	print_eq_elseif((e,el))
end
	
relation unparse_eq_elseif_str_lst: (int, (Absyn.Exp * Absyn.EquationItem list) list, string) => string =
	
  axiom	 unparse_eq_elseif_str_lst(_,[],_) => ""

  rule	unparse_eq_elseif_str(i,x1) => s1 &
	string_append_list([s1,sep]) => res
	-------------------------------------
	unparse_eq_elseif_str_lst(i,[x1],sep) => res

  rule	unparse_eq_elseif_str_lst(i,xs,sep) => s2 &
	unparse_eq_elseif_str(i,x) => s1 &
	string_append_list([s1,sep,s2]) => res
	--------------------
	unparse_eq_elseif_str_lst(i,x::(xs as _::_),sep) => res

  rule	unparse_eq_elseif_str(i,x1) => s1 &
	unparse_eq_elseif_str(i,x2) => s2 &
	string_append_list([s1,sep,s2]) => res
	-------------------------------------
	unparse_eq_elseif_str_lst(i,[x1,x2],sep) => res
end

relation unparse_eq_elseif_str : (int, (Absyn.Exp * Absyn.EquationItem list)) => string =
	    
  rule	print_exp_str e => s1 &
	unparse_equationitem_str_lst(i,el,";\n") => s2 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list(["\n",is,"elseif ",s1," then\n",s2]) => res
	-----------------------------------
	unparse_eq_elseif_str(i,(e,el)) => res
end

(* Algorithm clauses *)

relation print_algorithmitem: Absyn.AlgorithmItem => () =

  rule	print "ALGORITHMITEM(" &
	print_algorithm(alg)&
	print ")\n"
	-------------------
	print_algorithmitem (Absyn.ALGORITHMITEM(alg,_))

  rule	print "ALGORITHMITEMANN(<annotation>)\n"
	----------------------------------------
	print_algorithmitem(Absyn.ALGORITHMITEMANN(ann))
end

relation print_algorithm: Absyn.Algorithm => () =
(*added for modelica+*)

  rule	print "ALG_MATCH(" & print_component_ref cr &
	print " := " & print "," & print_exp(exp) & print "," &
	print_elementitems(eilist) & print "," & print_case_list(clist) & 
	print ")"
	-----------------------------------------
	print_algorithm(Absyn.ALG_MATCH(SOME(cr),exp,eilist,clist))

  rule	print "ALG_MATCH(" & 
	print_exp(exp) & print "," &
	print_elementitems(eilist) & print "," & print_case_list(clist) & 
	print ")"
	-----------------------------------------
	print_algorithm(Absyn.ALG_MATCH(NONE,exp,eilist,clist))


(*end added*)

  rule	print "ALG_ASSIGN(" & print_component_ref cr &
	print " := " & print_exp(exp) & print ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	print "ALG_TUPLE_ASSIGN(" & print_exp(e1) &
	print " := " & print_exp(e2) & print ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_TUPLE_ASSIGN(e1,e2))

  rule	print "IF (" & print_exp(e) & print ") THEN " &
	print_list_debug("print_algorithm",tb, print_algorithmitem, ";") &
	print_list_debug("print_algorithm",eb, print_alg_elseif, " ") &
	print " ELSE " & print_list_debug("print_algorithm",fb, print_algorithmitem, ";")
	----------------------------------------------------
	print_algorithm(Absyn.ALG_IF(e,tb,eb,fb))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",el, print_algorithmitem, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	print "WHILE " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
	(*  rule	Print.print_buf "WHEN_E " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	 ----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_E(e,al)
*)
  rule	print "WHEN_A " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_A(e,al,el)
	
  rule	print " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

(*ADDED*)
relation print_case =

  rule	print "CASE( " & print_pattern_list(pl) & print "," &
	print_elementitems(el) & print "," & print_class_part(cp) & print "," & 
	print_exp(exp) & print ")"
	-----------------------------------
	print_case Absyn.CASE(pl,el,cp,exp)

end

relation print_case_list =

  axiom	print_case_list([])

  rule	print_case(last) 
	---------------
	print_case_list(last::[])

  rule	print_case(first) &
	print_case_list(rest) 
	-----------------------
	print_case_list(first::rest)

end

relation print_pattern_list =

  rule	print "pattern NA"
	-----------------
	print_pattern_list(x)

end

(* END ADDED *)
relation unparse_algorithm_str_lst: (int, Absyn.AlgorithmItem list,string)
	  => string =

  axiom unparse_algorithm_str_lst (_,[],_) => ""

  rule	unparse_algorithm_str(i,x) => s1 &
	string_append(s1,sep) => res 
	------------------------------------
	unparse_algorithm_str_lst(i, [x], sep) => res
	
  rule	unparse_algorithm_str(i,x1) => s1 &
	unparse_algorithm_str(i,x2) => s2 &
	string_append_list([s1,sep,s2]) => res
	------------------------------------
	unparse_algorithm_str_lst(i, [x1,x2], sep) => res

  rule	unparse_algorithm_str(i,x) => s1 &
	unparse_algorithm_str_lst(i,xs,sep) => s2 &
	string_append_list([s1,sep,s2]) => res
	------------------------------------
	unparse_algorithm_str_lst(i, x::xs, sep) => res
end


(* ADDED *)

relation unparse_case_list =

  axiom unparse_case_list(i,[]) => ""

  rule	unparse_case(i,last) => str
	--------------------------
	unparse_case_list(i,last::[]) => str

  rule	unparse_case(i,first) => firststr & 
	unparse_case_list(i,rest) => reststr &
	string_append_list([firststr,"\n",reststr]) => str
	--------------------------------------------------
	unparse_case_list(i,first::rest) => str
		
end

relation unparse_case =

  rule	unparse_pattern_list(pl) => s1 &
	int_add(i,2) => ic &
	unparse_elementitem_str_lst(ic,el) => s2 &
	unparse_class_part_str(ic,cp,false) => s3 &
	print_exp_str(exp) => s4 &
	indent_str(i) => is1 &
	indent_str(ic) => is2 &
	string_append_list([is1,"case ",s1,s2,s3,is2,"then ",s4,";"]) => str
	-----------------------------------
	unparse_case(i, Absyn.CASE(pl,el,cp,exp)) => str

end

relation unparse_pattern_lst = 

  axiom	unparse_pattern_lst([]) => ""


  rule	unparse_pattern(last) => str
	-----------------------------
	unparse_pattern_lst(last::[]) => str

	
  rule	unparse_pattern(first) => fpat &
	unparse_pattern_list(rest) => rpat &
	string_append_list([fpat,",",rpat]) => str
	-----------------------------------
	unparse_pattern_lst(first::rest) => str

end

relation unparse_pattern_list =

  axiom	unparse_pattern_list([]) => ""
	
  rule
	unparse_pattern(last) => str
	-----------------------------
	unparse_pattern_list(last::[]) => str

  rule	unparse_pattern_lst(x) => s1 &
	string_append_list(["(",s1,")"]) => str
	------------------------------
	unparse_pattern_list(x) => str

end
relation unparse_pattern =

  axiom	unparse_pattern(Absyn.MWILDpat) => "_"

  rule	print_exp_str(exp) => str
	-------------------------------
	unparse_pattern(Absyn.MLITpat(exp)) => str
 
  rule	path_string(path) => str
	---------------------------
	unparse_pattern(Absyn.MCONpat(path)) => str
	
  rule	path_string path => s1 &
	unparse_pattern_lst(pat_list) => s2 &
	string_append_list([s1,"(",s2,")"]) => str
	-----------------------------------
	unparse_pattern(Absyn.MSTRUCTpat(SOME(path),pat_list)) => str
	
  rule	unparse_pattern_list(pat_list) => s1 &
	string_append_list([s1]) => str
	-------------------------------------
	unparse_pattern(Absyn.MSTRUCTpat(NONE,pat_list)) => str

  rule	unparse_pattern(pat) => s1 &
	string_append_list([id," as ",s1]) => str
	--------------------------------------------
	unparse_pattern(Absyn.MBINDpat(id,pat)) => str

  rule	
	----------------------------------------------
	unparse_pattern(Absyn.MIDENTpat(id,pat)) => id

end

relation unparse_algorithm_str: (int, Absyn.AlgorithmItem) => string =
	
(*ADDED*)
  rule	print_component_ref_str cr => s1 &
	print_exp_str(exp) => s2 &
	unparse_comment_option(optcmt) => s3 &
	int_add(i,2) => ic &
	unparse_elementitem_str_lst(ic,eilist) => s4 &
	unparse_case_list(ic,caselist) => s5 &
	indent_str(i) => is & 
	string_append_list([is,s1,":=\n",is,"match ",s2,s3,"\n",s4,s5,"\n",is,"end match;"]) => str
	---------------------------
	unparse_algorithm_str(i,Absyn.ALGORITHMITEM(Absyn.ALG_MATCH(SOME(cr),exp,eilist,caselist),optcmt)) => str

  rule	print_exp_str(exp) => s2 &
	unparse_comment_option(optcmt) => s3 &
        int_add(i,2) => ic &
	unparse_elementitem_str_lst(ic,eilist) => s4 &
	unparse_case_list(ic,caselist) => s5 &
	indent_str(i) => is & 
	string_append_list([is,"match ",s2,s3,"\n",s4,s5,"\n",is,"end match;"]) => str
	---------------------------
	unparse_algorithm_str(i,Absyn.ALGORITHMITEM(Absyn.ALG_MATCH(NONE,exp,eilist,caselist),optcmt)) => str

(*END ADDED*)
  rule	print_component_ref_str cr => s1 &
	print_exp_str(exp) => s2 & 
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	string_append_list([is,s1,":=",s2,s3,";"]) => str
	-------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(cr,exp),optcmt)) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i,tb,"\n") => s2 &
	unparse_alg_elseif_str_lst(i',eb,"\n") => s3 &
	unparse_algorithm_str_lst(i,fb,"\n") => s4 &
	unparse_comment_option(optcmt) => s5 &
	indent_str(i) => is &
	string_append_list([is,"if ",s1," then \n",is, s2, s3, "\n",is, "else ", s4, "\n", is, "end if" , s5, ";"]) => str
	----------------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_IF(e,tb,eb,fb),optcmt)) => str
	
  rule	print_exp_str(e)=> s1 &
	int_add(ident,1) => ident' &
	unparse_algorithm_str_lst(ident',el,"\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(ident) => is &
	string_append_list([is,"for ", i, " in ", s1, " loop\n",is, s2, "\n",is,"end for", s3, ";"]) => str
	----------------------------------------------------------
        unparse_algorithm_str (ident, Absyn.ALGORITHMITEM(Absyn.ALG_FOR(i,e,el),optcmt)) => str
				     
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i',al,"\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	string_append_list([is,"while (", s1, ") loop\n", is, s2, "\n", is, "end while", s3, ";"]) => str
	----------------------------------------------------------
	unparse_algorithm_str (i, Absyn.ALGORITHMITEM(Absyn.ALG_WHILE(e,al),optcmt)) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i', al, "\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	unparse_alg_elsewhen_str_lst(i',al2) => s4 &
	string_append_list([is,"when ", s1, " then\n", is, s2, is, s4, "\n", is, "end when", s3,";"]) => str
        ----------------------------------------------------------
	unparse_algorithm_str (i, Absyn.ALGORITHMITEM(Absyn.ALG_WHEN_A(e,al,al2),optcmt)) => str
	
  rule	print_component_ref_str(cr) => s1 &
	print_function_args_str(fargs) => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	string_append_list([is,s1,"(",s2,")",s3,";"]) => str
	-----------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(cr,fargs),optcmt)) => str

  rule	unparse_annotation_option(i, SOME(ann)) => str &
	string_append(str,";") => str'
	------------------------------------------
	unparse_algorithm_str (i,Absyn.ALGORITHMITEMANN(ann)) => str'
  
  rule	print " *Failure! UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	unparse_algorithm_str(_,_) => ""
	
end
(**)

relation unparse_alg_elsewhen_str_lst: (int,(Absyn.Exp * Absyn.AlgorithmItem list) list) => string =

  axiom	unparse_alg_elsewhen_str_lst (_,[]) => ""

  rule	unparse_alg_elsewhen_str(i,x) => res
	----------------------------
	unparse_alg_elsewhen_str_lst(i,[x]) => res

  rule	unparse_alg_elsewhen_str(i,x1) => s1 &
	unparse_alg_elsewhen_str(i,x2) => s2 &
	string_append_list([s1,"\n",s2]) => res 
	----------------------------
	unparse_alg_elsewhen_str_lst(i,[x1,x2]) => res

  rule	unparse_alg_elsewhen_str(i,x) => s1 &
	unparse_alg_elsewhen_str_lst(i,xs) => s2 &
	string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_alg_elsewhen_str_lst(i,x::(xs as _::_)) => res
end

relation unparse_alg_elsewhen_str: (int, (Absyn.Exp * Absyn.AlgorithmItem list)) => string =
	
  rule	indent_str(i) => is &
	unparse_algorithm_str_lst(i,algl,"\n") => s1 &
	print_exp_str(exp) => s2 &
	string_append_list(["elsewhen ",s2, " then\n",s1]) => res
	------------------------
	unparse_alg_elsewhen_str (i,(exp, algl)) => res
end

relation unparse_eq_elsewhen_str_lst: (int,(Absyn.Exp * Absyn.EquationItem list) list) => string =

  axiom	unparse_eq_elsewhen_str_lst (_,[]) => ""

  rule	unparse_eq_elsewhen_str(i,x) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,[x]) => res

  rule	unparse_eq_elsewhen_str(i,x1) => s1 &
	unparse_eq_elsewhen_str(i,x2) => s2 &
	string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,[x1,x2]) => res

  rule	unparse_eq_elsewhen_str(i,x) => s1 &
	unparse_eq_elsewhen_str_lst(i,xs) => s2 &
	string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,x::xs) => res
end

relation unparse_eq_elsewhen_str: (int, (Absyn.Exp * Absyn.EquationItem list)) => string =
	
  rule	indent_str(i) => is &
	unparse_equationitem_str_lst(i,eql,";\n") => s1 &
	print_exp_str(exp) => s2 &
	string_append_list(["elsewhen ",s2, " then\n",s1]) => res
	------------------------
	unparse_eq_elsewhen_str (i,(exp, eql)) => res
end

relation print_alg_elseif : (Absyn.Exp * Absyn.AlgorithmItem list) => () =

  rule	print " ELSEIF " & print_exp e & print " THEN " &
	print_list_debug("print_alg_elseif",el, print_algorithmitem, ";")
	-----------------------------------
	print_alg_elseif((e,el))

end

relation unparse_alg_elseif_str_lst: (int, (Absyn.Exp * Absyn.AlgorithmItem list) list, string) => string =
	
  axiom	 unparse_alg_elseif_str_lst(_,[],_) => ""

  rule	unparse_alg_elseif_str_lst(i,xs,sep) => s2 &
	unparse_alg_elseif_str(i,x) => s1 &
	string_append_list([s1,sep,s2]) => res
	--------------------
	unparse_alg_elseif_str_lst(i,x::(xs as _::_),sep) => res

  rule	unparse_alg_elseif_str(i,x1) => s1 &
	unparse_alg_elseif_str(i,x2) => s2 &
	string_append_list([s1,sep,s2]) => res
	-------------------------------------
	unparse_alg_elseif_str_lst(i,[x1,x2],sep) => res
end


relation unparse_alg_elseif_str : (int,(Absyn.Exp * Absyn.AlgorithmItem list)) => string =

  rule  print_exp_str e => s1 &
	unparse_algorithm_str_lst(i,el,"\n") => s2 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	string_append_list([is,"elseif ", s1, " then\n", s2]) => str
	-----------------------------------
	unparse_alg_elseif_str(i,(e,el)) => str
end

(* Component references and paths *)

(* relation: print_component_ref
 *
 * Print a `ComponentRef'.
 *)

relation print_component_ref : Absyn.ComponentRef => () =

  rule	print s &
	print_subscripts subs
	---------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	print s &
	print_subscripts subs &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

relation print_subscripts : Absyn.Subscript list => () =

  axiom	print_subscripts []

  rule	print "[" & print_list_debug("print_subscripts",l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_subscripts l

end

(* relation: print_component_ref_str
 *
 * Print a `ComponentRef' and return as a string.
 *)

relation print_component_ref_str : Absyn.ComponentRef => string =

  rule	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s'
	--------------------------------
	print_component_ref_str Absyn.CREF_IDENT(s,subs) => s'

  rule	print_component_ref_str cr => crs &
	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s' &
	string_append (s', ".") => s'' &
	string_append (s'', crs) => s'''
	--------------------------------
	print_component_ref_str Absyn.CREF_QUAL(s,subs,cr) => s'''

end


relation print_subscripts_str : Absyn.Subscript list => string =

  axiom	print_subscripts_str [] => ""

  rule	print_list_str(l,print_subscript_str,",") => s &
	string_append ("[", s) => s' & 
	string_append (s', "]") => s''
	-------------------------------------------------------
	print_subscripts_str l => s''

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path : Absyn.Path => () =

  rule	path_string p => s & print s
	----------------------------------
	print_path p

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path_str : Absyn.Path => string =

  rule	path_string p => s
	----------------------------------
	print_path_str p => s

end

(* - Expressions *)

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp : Absyn.Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	print_component_ref(c)
	---------------------
	print_exp(Absyn.CREF(c))

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	print "FALSE"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	print "TRUE"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	op_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	---------------------------------------------------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	op_symbol(op) => sym &
	print sym & print_exp e
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	op_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	op_symbol(op) => sym & print sym & print_exp e
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	op_symbol(op) => sym & print_exp(e1) & print sym & print_exp(e2)
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	print "if " & print_exp(c) &
	print " then " & print_exp(t) &
	print " else " & print_exp(f)
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f,lst))

  rule	print_component_ref(fcn) &
 	print "(" & 
	print_function_args(args) & print ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	print "ARRAY[" &
	print_list_debug("print_exp",es, print_exp, ",") &
	print "]"
	---------
	print_exp Absyn.ARRAY(es)

	(* PR. *)
  rule	print "TUPLE" &
	print "(" &
	print_list_debug("print_exp",es, print_exp, ",") &
	print ")"
	---------
	print_exp Absyn.TUPLE(es)
	
  rule	print "MATRIX[" &
	print_list_debug("print_exp",es, print_row, ";") &
	print "]"
	---------
	print_exp Absyn.MATRIX(es)

  rule	print "RANGE(" & print_exp start & print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	print "RANGE(" & print_exp start & print ":" & print_exp step &
 	print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule print "end"
    ----------------------------------
    print_exp Absyn.END

  rule	print "#UNKNOWN EXPRESSION#"
	----------------------------------
	print_exp (_)
end

relation print_function_args: Absyn.FunctionArgs => () =
	
  rule  print "FUNCTIONARGS(" &
	print_list_debug("print_exp",expargs,print_exp,", ") &
	print ", " &
	print_list_debug("print_namedarg",nargs,print_named_arg,", ") &
	print ")"
	-------------------
	print_function_args Absyn.FUNCTIONARGS(expargs,nargs)

  rule  print "FOR_ITER_FARG(" &
	print_exp exp &
	print ", " &
	print id &
	print ", " &
	print_exp iterexp &
	print ")"
	-------------------
	print_function_args Absyn.FOR_ITER_FARG (exp, id, iterexp)
end

relation print_function_args_str: Absyn.FunctionArgs => string =
	
  rule	(* Both positional and named arguments *)
	print_list_str(expargs,print_exp_str,", ") => s1 &
	string_append(s1,", ") => s2 &
	print_list_str(nargs,print_named_arg_str,", ") => s3 &
	string_append(s2,s3) => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs as _::_,nargs as _::_) => str

  rule	(* Only named arguments *)
	print_list_str(nargs,print_named_arg_str,", ") => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS([],nargs) => str

  rule	(* Only positional arguments *)
	print_list_str(expargs,print_exp_str,", ") => str 
	---------------------------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs,[]) => str

  rule	print_exp_str exp => estr &
	print_exp_str iterexp => istr &
	string_append_list([estr," for ",id," in ", istr]) => str
	--------------------------------------------------------------
	print_function_args_str Absyn.FOR_ITER_FARG(exp,id,iterexp) => str
	
end

relation print_named_arg: Absyn.NamedArg => () =

  rule	print ident &
	print "=" &
	print_exp(e) 
	------------
	print_named_arg Absyn.NAMEDARG(ident,e)
end

relation print_named_arg_str: Absyn.NamedArg => string =
  rule	string_append(ident,"=") => s1 &
	print_exp_str(e) => s2 &
	string_append(s1,s2) => str
	---------------------------
	print_named_arg_str Absyn.NAMEDARG(ident,e) => str
end	

(**)

relation print_row : Absyn.Exp list => () =

  rule	print_list_debug("print_row",es, print_exp, ",")
	------------------------------
	print_row es

end


(* relation: exp_priority
*
* Returns a priority number for an expression.
* This relation is used to output parenthesis when needed. eg 3*(1+2) should output 3*(1+2) 
* and not 3*1+2
 *)

relation exp_priority: Absyn.Exp => int =

  axiom	exp_priority(Absyn.INTEGER(_)) => 0
  axiom	exp_priority(Absyn.REAL(_)) => 0
  axiom	exp_priority(Absyn.STRING(_)) => 0
  axiom	exp_priority(Absyn.BOOL(_)) => 0
  axiom	exp_priority(Absyn.CREF(_)) => 0
  axiom	exp_priority(Absyn.END) => 0
  axiom	exp_priority(Absyn.CALL(_,_)) => 0
  axiom	exp_priority(Absyn.ARRAY(_)) => 0
  axiom	exp_priority(Absyn.MATRIX(_)) => 0

  axiom	exp_priority(Absyn.BINARY(_,Absyn.POW,_)) => 1 

  axiom	exp_priority(Absyn.BINARY(_,Absyn.DIV,_)) => 2
  axiom	exp_priority(Absyn.BINARY(_,Absyn.MUL,_)) => 3

  axiom	exp_priority(Absyn.UNARY(Absyn.UPLUS,_)) => 4
  axiom	exp_priority(Absyn.UNARY(Absyn.UMINUS,_)) => 4

  axiom	exp_priority(Absyn.BINARY(_,Absyn.ADD,_)) => 5
  axiom	exp_priority(Absyn.BINARY(_,Absyn.SUB,_)) => 5

  axiom	exp_priority(Absyn.RELATION(_,Absyn.LESS,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.LESSEQ,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.GREATER,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.GREATEREQ,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.EQUAL,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.NEQUAL,_)) => 6

  axiom	exp_priority(Absyn.LUNARY(Absyn.NOT,_)) => 7

  axiom	exp_priority(Absyn.LBINARY(_,Absyn.AND,_)) => 8

  axiom	exp_priority(Absyn.LBINARY(_,Absyn.OR,_)) => 9

  axiom	exp_priority(Absyn.RANGE(_,_,_)) => 10

  axiom	exp_priority(Absyn.IFEXP(_,_,_,_)) => 11

	(* Not valid in inner expressions, only included here for completeness *)
  axiom	exp_priority(Absyn.TUPLE(_)) => 12
	
  axiom	exp_priority(_) => 13
end

relation parenthesize: (string, 
			int, (*expressuion prio*)
			int (*parent expr prio*)
			) => string =

  rule	int_gt(pparent,pexpr) => true &
	string_append_list(["(",str,")"]) => str'
	---------------------------
	parenthesize(str,pparent,pexpr) => str'

  axiom	parenthesize(str,_,_) => str
end

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp_str : Absyn.Exp => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp_str(Absyn.INTEGER(x)) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp_str(Absyn.REAL(x)) => s

  rule	print_component_ref_str (c) => s
	---------------------
	print_exp_str(Absyn.CREF(c)) => s

  rule	string_append("\"", s) => s' &
	string_append(s', "\"") => s''
	---------------------------------
	print_exp_str(Absyn.STRING(s)) => s''

  rule	print_bool_str b => s
	---------------------
	print_exp_str(Absyn.BOOL(b)) => s

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p2,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str(e as Absyn.BINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e1 => s &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	parenthesize(s,p1,p) => s' &
	string_append (sym, s') => s''
	----------------------------
	print_exp_str(e as Absyn.UNARY(op, e1)) => s''

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p1,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str (e as Absyn.LBINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e1 => s &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &	
	parenthesize(s,p1,p) => s' &
	string_append (sym, s') => s''
	----------------------------
	print_exp_str(e as Absyn.LUNARY(op, e1)) => s''

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p1,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str(e as Absyn.RELATION(e1, op, e2)) => s'

  rule	print_exp_str c => cs &
	print_exp_str t => ts &
	print_exp_str f => fs &
	exp_priority(e) => p &
	exp_priority(c) => pc &
	exp_priority(t) => pt &
	exp_priority(f) => pf &
	parenthesize(cs,pc,p) => cs' &
	parenthesize(ts,pt,p) => ts' &
	parenthesize(fs,pf,p) => fs' &
	print_elseif_str elseif => el &		       
	string_append_list(["if ", cs', " then ", ts', el, " else ", fs']) => str
	---------------------------------
	print_exp_str(e as Absyn.IFEXP(c,t,f,elseif)) => str

  rule	print_component_ref_str(fcn) => fs &
	print_function_args_str(args) => argsstr &
	string_append(fs, "(") => s &
	string_append(s, argsstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp_str(Absyn.CALL(fcn, args)) => s''


  rule	(* Does not need parentheses *)
	print_list_str(es, print_exp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp_str Absyn.ARRAY(es) => s''

  rule	(* Does not need parentheses *)
	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp_str Absyn.TUPLE(es) => s''
	
  rule	(* Does not need parentheses *)
	print_list_str(es, print_row_str, ";") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.MATRIX(es) => s''

  rule	print_exp_str (start) => s1 &
	print_exp_str (stop) => s3 &
	exp_priority(e) => p &
	exp_priority(start) => pstart &
	exp_priority(stop) => pstop &
	parenthesize(s1,pstart,p) => s1' &
	parenthesize(s3,pstop,p) => s3' &
	string_append_list([ s1', ":", s3']) => s
	--------------------------------
	print_exp_str(e as  Absyn.RANGE(start,NONE,stop)) => s

  rule	print_exp_str (start) => s1 &
	print_exp_str (step) => s2 &
	print_exp_str (stop) => s3 &
	exp_priority(e) => p &
	exp_priority(start) => pstart &
	exp_priority(stop) => pstop &
	exp_priority(step) => pstep &
	parenthesize(s1,pstart,p) => s1' &
	parenthesize(s3,pstop,p) => s3' &
	parenthesize(s2,pstep,p) => s2' &
	string_append_list([s1',":", s2', ":", s3']) => s
	------------------------------------
	print_exp_str (e as Absyn.RANGE(start,SOME(step),stop)) => s

  rule	print_code_str(c) => res &
	string_append_list(["Code(",res,")"]) => res'
	--------------------------
	print_exp_str ( Absyn.CODE(c)) => res'

  axiom print_exp_str Absyn.END => "end"

  axiom	print_exp_str (_) =>  "#UNKNOWN EXPRESSION#"

end

relation print_code_str: Absyn.Code => string =
	
  rule	print_path_str p => s
	---------------------
	print_code_str( Absyn.C_TYPENAME(p)) => s

  rule	print_component_ref_str cr => s
	---------------------
	print_code_str( Absyn.C_VARIABLENAME(cr)) => s

  rule	select_string(b,"initial ", "") => s1 &
	unparse_equationitem_str_lst (1,eqitems,";\n") => s2 &
	string_append_list([s1, "equation ",s2]) => res
	------------------------------------------------
	print_code_str( Absyn.C_EQUATIONSECTION(b, eqitems)) => res

  rule	select_string(b,"initial ", "") => s1 &
	unparse_algorithm_str_lst (1,algitems,";\n") => s2 &
	string_append_list([s1,"algorithm ", s2]) => res
	------------------------------------------------
	print_code_str( Absyn.C_ALGORITHMSECTION(b, algitems)) => res

  rule	unparse_element_str(1,elt) => res
	------------------------------------------------
	print_code_str( Absyn.C_ELEMENT(elt)) => res

  rule	print_exp_str(exp) => res
	------------------------------------------------
	print_code_str( Absyn.C_EXPRESSION(exp)) => res

  rule	unparse_modification_str(m) => res
	------------------------------------------------
	print_code_str( Absyn.C_MODIFICATION(m)) => res

end
			       
relation print_elseif_str: (Absyn.Exp * Absyn.Exp) list => string =
  axiom print_elseif_str ([]) => ""

  rule	print_exp_str(ec) => s1 &
	print_exp_str(ee) => s2 &
	print_elseif_str(rest) => s3 &
	string_append_list([" elseif ", s1, " then ", s2, s3]) => str
	-------------------------------------------------------------
	print_elseif_str((ec,ee)::rest) => str
end

relation print_row_str : Absyn.Exp list => string =

  rule	print_list_str (es, print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end


(* relation: op_symbol
 *
 * Make a string describing different operators.
 *)

relation op_symbol : Absyn.Operator => string =
  axiom	op_symbol(Absyn.ADD) => " + "
  axiom	op_symbol(Absyn.SUB) => " - "
  axiom	op_symbol(Absyn.MUL) => "*"
  axiom	op_symbol(Absyn.DIV) => "/"
  axiom	op_symbol(Absyn.POW) => "^"

  axiom	op_symbol(Absyn.UMINUS) => "-"
  axiom	op_symbol(Absyn.UPLUS) => "+"

  axiom	op_symbol(Absyn.AND) => " and "
  axiom	op_symbol(Absyn.OR) => " or "

  axiom	op_symbol(Absyn.NOT) => "not "

  axiom	op_symbol(Absyn.LESS)      => " < "
  axiom	op_symbol(Absyn.LESSEQ)    => " <= "
  axiom	op_symbol(Absyn.GREATER)   => " > "
  axiom	op_symbol(Absyn.GREATEREQ) => " >= "
  axiom	op_symbol(Absyn.EQUAL)     => " == "
  axiom	op_symbol(Absyn.NEQUAL)    => " <> "
end

(* - Utility relations
 *
 * These are utility relations used in some of the other
 * relations. *)

relation select_string: (bool,string,string) => string =

  axiom	select_string(true,a,b) => a
  axiom	select_string(false,a,b) => b

end

relation print_select: (bool,string,string) => () =

  rule	select_string(f,yes,no) => res &
	print res
	-------------------------
	print_select(f,yes,no)

end

relation print_option : (('a option),('a => ())) => () =

  axiom	print_option(NONE,_) => ()
	
  rule	r( x )
	------
	print_option(SOME(x),r) => ()
end

relation print_list_debug : (string, 'a list, 'a => (), string) => () =

  rule	fprintln ("dumptr", "print_list_debug-1")
	-----------------------------------------------
	print_list_debug(_,[],_,_)
	
  rule	fprintl ("dumptr", ["print_list_debug-2 from ", caller, "\n"]) &
	r(h) &
	fprintln ("dumptr", "//print_list_debug-2")
	------------------
	print_list_debug(caller,[h],r,_)

  rule	string_append("print_list_debug-3 from ", caller) => s1 &
	fprintl ("dumptr", [s1, "\n"]) &
	r(h) & 
	print sep & 
	fprintln ("dumptr", "//print_list_debug-3") &
	print_list_debug(s1, rest, r, sep)
	-------------------------------------
	print_list_debug(caller, h::rest, r, sep)

end


relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep &
	print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end


relation get_string_list : ('a list, 'a => string, string) => string =

  axiom	get_string_list ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	get_string_list([h],r,_) => s

  rule	r(h) => s & 
	string_append (s, sep) => s' &
	get_string_list (t,r,sep) => srest &
	string_append (s', srest) => s''
	-------------------------------------
	get_string_list (h::t,r,sep) => s''

end

relation print_bool : bool => () =

  rule	print_select (b, "true", "false")
	---------------------------------
	print_bool b
end


relation get_option_str: ('a option, 'a => string) => string =
  rule  r (a) => str
	------------
	get_option_str (SOME(a),r) => str

  axiom	get_option_str(NONE,_) => ""
end

relation unparse_string_comment_option: string option => string =
	
  axiom unparse_string_comment_option(NONE) => ""
	
  rule	string_append_list([" \"",s,"\""])=> str 
	--------------------------
	unparse_string_comment_option(SOME(s)) => str
end

relation identity: ('a) => 'a =
  axiom identity(x) => x
end

relation print_bool_str : bool => string =

  rule	select_string (b, "true", "false") => s
	---------------------------------
	print_bool_str b => s

end

relation stringlist_append : string list => string =

	axiom stringlist_append([]) => ""

  rule	stringlist_append(xs) => s2 &
	string_append(s1,s2) => str
	-----------------------------
        stringlist_append(s1::xs) => str
end


relation indent_str: (int) => string =
  axiom	indent_str(0) => ""

  rule	int_sub(i,1) => i' &
	indent_str(i') => s1 &
	(* Indent using two whitespaces *)
	string_append(s1,"  ") => res
	--------------------
	indent_str(i) => res
end


