module RMLDump:
  with "absyn.rml"	

  relation dump: Absyn.Program => ()
  relation print_id: Absyn.RMLIdent => ()
  relation dump_type: Absyn.RMLType => ()	  
end


relation print_id =
  rule  print name
	----------------
	print_id(Absyn.RMLSHORTID(name,info)) => ()

   		
  rule  print prefix & print "." & print name
	----------------------
	print_id(Absyn.RMLLONGID(prefix,name)) => ()
end

relation print_operator =
  rule  print "+"
	-------------------
	print_operator(Absyn.ADD) => ()

  rule  print "-"
	-------------------
	print_operator(Absyn.SUB) => ()

  rule  print "*"
	-------------------
	print_operator(Absyn.MUL) => ()

  rule  print "/"
	-------------------
	print_operator(Absyn.DIV) => ()

  rule  print "-"
	------------------
	print_operator(Absyn.UMINUS) => ()
end

relation print_literal =
  (* FIXME: handle escape sequences *)
  rule  print "\"" &
	string_length(s) => l &
	print_handle_escape(s,0,l) &
	print "\""	
	--------------------------
	print_literal(Absyn.RMLLIT_STRING(s)) => ()

  rule  int_string(i) => s & print s
	--------------------------
	print_literal(Absyn.RMLLIT_INTEGER(i)) => ()

  rule  real_string(r) => s & print s
	-------------------------
	print_literal(Absyn.RMLLIT_REAL(r)) => ()

  (* RMLLIT_CHAR ? *)
end

relation print_handle_escape =

  rule  int_ge(i,l) => true
	--------------------
	print_handle_escape(s,i,l)

  rule	string_nth(s,i) => c1 &
	char_int(c1) => n &
	int_eq(n,10) => true & (* if \n  *)
	print "\\n" &
	int_add(i,1) => ic &
	print_handle_escape(s,ic,l)
	--------------------
	print_handle_escape(s,i,l) 

 rule	string_nth(s,i) => c1 &
	char_int(c1) => n &
	int_eq(n,9) => true & (* if \t  *)
	print "\\t" &
	int_add(i,1) => ic &
	print_handle_escape(s,ic,l)
	--------------------
	print_handle_escape(s,i,l) 
  
  rule	string_nth(s,i) => c1 &
	char_int(c1) => n &
	int_eq(n,8) => true & (* if \b  *)
	print "\\b" &
	int_add(i,1) => ic &
	print_handle_escape(s,ic,l)
	--------------------
	print_handle_escape(s,i,l) 

 
  rule	string_nth(s,i) => c &
	list_string([c]) => ss & 
	print ss &
	int_add(i,1) => ic &
	print_handle_escape(s,ic,l)
	--------------------
	print_handle_escape(s,i,l)
	
	
end

relation dump_expression_list =
  rule  dump_expression(last)
	-----------------------------
	dump_expression_list(last :: []) => () 

  rule  dump_expression(first) &
	print ", " &
	dump_expression_list(rest)
	------------------------------
	dump_expression_list(first :: rest) => ()

  rule  print ""
	------------------------------
	dump_expression_list([]) => () 

end 


relation dump_expression =
  rule  print_id(id) &
        print "(" &
        dump_expression_list(args) &
        print ")"
	----------------------------
	dump_expression(Absyn.RMLCALL(id,args)) => ()

  rule  print_id(id) 
	--------------
	dump_expression(Absyn.RML_REFERENCE(id)) => ()		

  rule	print "[" & dump_expression_list(exp_list) & print "]"
	-------------------------------------------
	dump_expression(Absyn.RMLLIST(exp_list)) => ()

  rule  dump_expression(left) &
	print " :: " &
	dump_expression(right)
	----------------------------
	dump_expression(Absyn.RMLCONS(left,right)) => ()

  rule  dump_expression(left) &
        print_operator(op) &
        dump_expression(right)
	-------------------------------
	dump_expression(Absyn.BINARY(left,op,right)) => ()

  rule  print_operator(op) &
        dump_expression(exp)
	-------------------------------
	dump_expression(Absyn.UNARY(op,exp)) => ()

  rule  print "cref(not supported in dump)"
        ----------
	dump_expression(Absyn.CREF(r)) => ()

  rule 	print_literal lit
	--------------------------------
	dump_expression(Absyn.RMLLIT(lit)) => ()

(* Is these 3 needed? RMLLIT IS USED INSTEAD- remove*)

(*  rule 	print "\"" & print_id(id) & print "\"" 
	---------------------------
	dump_expression(Absyn.STRING(id)) => ()	
 
  rule	int_string(i) => s & print(s)
	------------------------
	dump_expression(Absyn.INTEGER(i)) => ()

  rule  real_string(r) => s & print s
	-------------------------------
	dump_expression(Absyn.REAL(r)) => ()	
*)
  rule  print "()"
	------------------------------
	dump_expression(Absyn.RMLNIL) => ()


  rule 	RML.debug_print("Exp?", x) & 
        print "Expression uknown.."	
	--------------------------
	dump_expression(x)
	
  (* Debug *)
(*  rule  dump_expression(first) &
        print ", " &
        dump_expression(rest)
	------------------------
	dump_expression(Absyn.ARRAY(first::rest)) => () *)
end

relation dump_pattern_list =
  rule  dump_pattern(last)
	------------------------
	dump_pattern_list(last :: []) => ()

  rule  dump_pattern(first) &
	print ", " &
	dump_pattern_list(rest)
	----------------------------
	dump_pattern_list(first :: rest) => ()

  rule  print ""
	------------------------------
	dump_pattern_list([]) => ()
end


relation dump_pattern =
  rule  print_id(id) & print " as " & dump_pattern(pat)
	-----------------------------
	dump_pattern(Absyn.RMLPAT_AS(id,pat)) => ()

  rule  dump_pattern(first) & print " :: " & dump_pattern(rest)
	------------------------------
	dump_pattern(Absyn.RMLPAT_CONS(first,rest)) => ()

  rule  print "(" &
	dump_pattern_list(list) &
	print ")"
	------------------------------
	dump_pattern(Absyn.RMLPAT_STRUCT(NONE,list)) => ()

  rule  print_id(id) &
	print "(" &
	dump_pattern_list(patlist) &
	print ")"
	-----------------------------
	dump_pattern(Absyn.RMLPAT_STRUCT(SOME(id),patlist)) => ()

  rule  print "()"
	-----------------------------
	dump_pattern(Absyn.RMLPAT_NIL) => ()

  rule  print "[" & dump_pattern_list(patlist) & print "]"
	----------------------------
	dump_pattern(Absyn.RMLPAT_LIST(patlist)) => ()

  rule  print_id(id)
	-----------------------------
	dump_pattern(Absyn.RMLPAT_IDENT(id)) => ()

  rule  print "_"
	------------------------------
	dump_pattern(Absyn.RMLPAT_WILDCARD) => ()

  rule  print_literal(lit)
	------------------------------
	dump_pattern(Absyn.RMLPAT_LITERAL(lit)) => ()

  rule  print("unknown pattern")
	-----------------------
	dump_pattern(x) => ()

end


relation dump_goal =
  rule  print "not " &
	dump_goal(goal)
	------------------
	dump_goal(Absyn.RMLGOAL_NOT(goal)) => ()

  rule  dump_goal(leftgoal) &
	print " &\n        " &
	dump_goal(rightgoal)
	------------------
	dump_goal(Absyn.RMLGOAL_AND(leftgoal,rightgoal)) => ()

  rule  dump_pattern(pat)
	------------------
	dump_goal(Absyn.RMLGOAL_PAT(pat)) => ()

  rule  print "let " &
        dump_pattern(pat) &
	print " = " &
	dump_expression(exp)
	------------------------
	dump_goal(Absyn.RMLGOAL_LET(pat,exp)) => ()

  rule  print_id(id) & (*changed from exp to id*)
	print " = " &
	dump_expression(rightexp)
	------------------------
	dump_goal(Absyn.RMLGOAL_EQUAL(id,rightexp)) => ()

  rule  print_id(id) &
        print "(" &
	dump_expression_list(args) &
	print ")" 
	------------------------
	dump_goal(Absyn.RMLGOAL_RELATION(id,args,NONE)) => ()


  rule	print_id(id) &
        print "(" &
	dump_expression_list(args) &
	print ")" &
	print " => " &
	dump_pattern(pat)
	------------------------
	dump_goal(Absyn.RMLGOAL_RELATION(id,args,SOME(pat))) => ()

end


relation dump_result =
  rule	print " => fail"
	---------------------
	dump_result(Absyn.RMLResultFail) => ()

  rule  print ""
	---------------------
	dump_result(Absyn.RMLNoResult) => ()

  rule  print " => " &
	dump_expression_list(list)
	----------------------
	dump_result(Absyn.RMLResultExp(list)) => ()
end


relation dump_rule =
  rule  print "  rule  " &
        dump_goal(goal) &
        print "\n\t-------------------------------\n\t" &
	print_id(id) &
	dump_pattern(patlist) &
	dump_result(result) &
        print "\n"
	-------------------------------------------
	dump_rule(Absyn.RMLRULE(id,patlist,SOME(goal),result)) => ()

	
  rule	print "  axiom " &
	print_id(id) &
	dump_pattern(patlist) &
	dump_result(result) &
        print "\n"
	------------------------------------------
	dump_rule(Absyn.RMLRULE(id,patlist,NONE,result)) => () 

end




relation dump_rule_list =
  rule  print ""
	----------------------------
	dump_rule_list([]) => () 

  rule  dump_rule(last)
	----------------------------
	dump_rule_list(last :: []) 

  rule  dump_rule(first) &
	print "\n" &
	dump_rule_list(rest)
	----------------------------
	dump_rule_list(first :: rest) => ()
end


relation dump_type_tuple =
  rule  dump_type(last)
	-------------------------------
	dump_type_tuple(last :: []) => ()

  rule  dump_type(first) &
	print " * " &
	dump_type_tuple(rest)
	-------------------------------
	dump_type_tuple(first :: rest) => ()

end

relation dump_iotype_list =
  rule 	dump_type(last) &
	print")"
	-----------
	dump_iotype_list(last :: []) => ()

  rule	dump_type(first) &
	print"," &
	dump_iotype_list(rest)
	----------------------
	dump_iotype_list(first :: rest) => ()
end

relation dump_iotype =
  rule	dump_type(last)
	---------------
	dump_iotype(last :: []) => ()
	
  rule	print "()"
	---------------------
	dump_iotype([]) => ()
 
  rule	print "(" &
	dump_iotype_list(x)
	------------------------
	dump_iotype(x) => ()
end



relation dump_type =
  rule  print "int"
	------------------------
	dump_type(Absyn.RMLTYPE_INT) => ()

  rule  print "real"
	------------------------
	dump_type(Absyn.RMLTYPE_REAL) => ()

  rule  print "string"
	------------------------
	dump_type(Absyn.RMLTYPE_STRING) => ()

  rule  dump_iotype(intype) &
	print " => " &
	dump_iotype(outtype)
	------------------------
	dump_type(Absyn.RMLTYPE_SIGNATURE(Absyn.CALLSIGN(intype,outtype))) => ()

  rule  print "(" & 
	dump_type_tuple(typelist) &
	print ")"
	------------------------
	dump_type(Absyn.RMLTYPE_TUPLE(typelist)) => ()

  rule	dump_type(last) &
	print " " &
	print_id(id)
	----------------------------
	dump_type(Absyn.RMLTYPE_TYCONS(last::[],id)) => ()

  rule	print_id(id)
	----------------------------
	dump_type(Absyn.RMLTYPE_TYCONS([],id)) => ()
 		   

  rule  print_id(id)
	------------------------
	dump_type(Absyn.RMLTYPE_TYVAR(id)) => ()

  rule  print_id(id)
	-------------------------
	dump_type(Absyn.RMLTYPE_USERDEFINED(id)) => ()

  rule 	print "unsupported type"
	-------------------------
	dump_type(_) => ()

(*CONS NOT SUPPORTED *)
end


relation dump_comment =
  rule  print "(* " &
        print s &
	print "*)\n"
	--------------------------------------
	dump_comment(s) => ()
end

relation dump_dtmember =
  rule	print_id(id) 
	-------------------
	dump_dtmember(Absyn.DTCONS(id,[])) 
	

  rule  print_id(id) &
	print " of " &
	dump_type_tuple(typelist)
	--------------------------
	dump_dtmember(Absyn.DTCONS(id,typelist))


end


relation dump_dtmember_list =
  rule  dump_dtmember(last)
	-----------------------------
	dump_dtmember_list(last :: []) => () 

  rule  dump_dtmember(first) &
	print "\n\t\t| " &
	dump_dtmember_list(rest)
	-----------------------------
	dump_dtmember_list(first :: rest) => ()

(*  rule  print "empty" can it ever be empty?? 
	-----------------------
	dump_dtmember_list([]) => () *)	
end


relation dump_decl_signature =
  rule 	dump_iotype(intype) & 
	print " => " &
	dump_iotype(outtype) 	
	----------------------------
	dump_decl_signature(Absyn.RMLTYPE_SIGNATURE(Absyn.CALLSIGN(intype,outtype))) => () 


end

relation dump_rmldecl =
  rule  print "  relation " &
	print_id(id) &
	print ": " &
	dump_decl_signature(sign) & 
        print "\n"
	----------------------
	dump_rmldecl(Absyn.RELATION_INTERFACE(id,sign)) => ()


  rule  print "relation " &
	print_id(id) &
	print ": " &
	dump_decl_signature(sign) & 
	print " =\n" &
	dump_rule_list(rules) &
	print "end\n\n"
	--------------------------------
	dump_rmldecl(Absyn.RELATION_DEFINITION(id,SOME(sign),rules)) => ()

  rule  print "relation " &
	print_id(id) &
	print " =\n" &
	dump_rule_list(rules) &
	print "end\n\n"
	--------------------------------
	dump_rmldecl(Absyn.RELATION_DEFINITION(id,NONE,rules)) => ()


  rule  print "  datatype " &
	print_id(id) &
	print " = " &
	dump_dtmember_list(dtmlist) &
	print "\n\n" 
        --------------------------
	dump_rmldecl(Absyn.DATATYPEDECL(Absyn.DATATYPE(type_list,id,dtmlist))) => ()

  rule  print "  type " &
	print_id(id) &
	print " = " &
	dump_type(rtype) &
	print "\n\n"
	----------------------------
	dump_rmldecl(Absyn.TYPE(id,rtype)) => ()

  rule  print "  with " &
	print_literal(Absyn.RMLLIT_STRING(s)) &
	print "\n\n"
	-------------------------------
	dump_rmldecl(Absyn.WITH(s))

  rule  print "val " &
	print_id(id) &
	print ": " &
	dump_type(rtype) &
	print "\n\n"
	-------------------------------
	dump_rmldecl(Absyn.VALINTERFACE(id,rtype)) => ()

  rule  print "val " &
	print_id(id) &
	print " = " &
	dump_expression(exp) &
	print "\n\n"
	--------------------------------
	dump_rmldecl(Absyn.VALDEF(id,exp)) => ()

  rule  print "\n" &
	dump_comment(s)
	--------------------------------
	dump_rmldecl(Absyn.RMLDECLCOMMENT(s)) => ()

  rule print "NO RML ??"	
       ----------------------
	dump_rmldecl(_) => ()
end


relation dump_rmldecl_list =
  rule 	dump_rmldecl(last) 
	---------------------------
	dump_rmldecl_list(last::[]) => () 
	
  rule 	dump_rmldecl(first) &
	print "\n" &
	dump_rmldecl_list(rest) 		
	-----------------------
	dump_rmldecl_list(first::rest) => ()
  
  rule  print ""
	-----------
	dump_rmldecl_list([]) => () 

end


relation dump_interfaces =
  rule  dump_rmldecl_list(x)
	---------------------------
	dump_interfaces(x) => ()
 
end


relation dump_definitions =
  rule  dump_rmldecl_list(x)
	---------------------------
	dump_definitions (x) => ()

end
 

relation dump =
  rule  print "module " &
        print_id(id) &
        print ":\n" &
        dump_interfaces(iflist) & 
        print "end\n\n" &
        dump_definitions(deflist) & 
        print "\n"
	---------------------------
	dump(Absyn.RML_FILE(id,iflist,deflist)) => ()

  rule  print "(* Non-RML *)\n"
	---------------------
	dump(_) => () 
end
