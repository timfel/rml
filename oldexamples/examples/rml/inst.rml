(*
    Copyright PELAB, Linkoping University
 
    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)


(**
 ** file:	 inst.rml
 ** module:      Inst
 ** description: Model instantiation
 **
 ** RCS: $Id: inst.rml,v 1.194 2005/01/17 10:09:48 petar Exp $
 **
 ** This module is responsible for instantiation of Modelica
 **  models. The instantation is the process of instantiating model
 ** components, flattening inheritance and generating equations from
 ** connect statements.
 ** The instantiation process takes Modelica AST as defined in SCode
 ** and produces variables and equations and algorithms, etc. as
 ** defined in DAE.
 ** 
 ** This module uses 'Lookup' to lookup classes and variables from the
 ** environment defined in 'Env'. It uses 'Connect' for generating equations from
 ** connect statements. The type system defined in 'Types' is used for
 ** variable instantiation and type . 'Mod' is used for modifiers and
 ** merging of modifiers. 
 ** 
 **)

(** debug flags: inst *)

module Inst:
  with "classinf.rml"
  with "connect.rml"
  with "dae.rml"
  with "env.rml"
  with "exp.rml"
  with "explode.rml"
  with "mod.rml"
  with "prefix.rml"
  with "types.rml"
  with "absyn.rml"

  (* Calling scope is used to determine when unconnected flow variables 
   * should be set to zero. *)
  datatype CallingScope = TOP_CALL | INNER_CALL

  type InstDims = Exp.Subscript list

  datatype Initial = INITIAL | NON_INITIAL

  datatype DimExp = DIMINT of int
		  | DIMEXP of Exp.Subscript * Exp.Exp option

(* Instantiation *)

(** There are basically four different ways/granularities of instantiation.
 ** 1. Using partial_inst_class_in which only instantiates class definitions.
 **    This relation is used for looking up class definitions in e.g. packages.
 **    For example, if looking up the class A.B.C, a new scope is opened and 
 **    A is partially instantiated in that scope using partial_inst_class_in.
 **
 ** 2. Function implicit instantiation. is the last argument of type bool to 
 **    inst_class_in. It is needed since instantiation of functions is needed to 
 **    generate code for functions and there are cases where such instantiations differ 
 **    from standard function instantiation. For example
 **    function foo
 **      input Real x[:];
 **      ...
 **    end foo;
 **    should be possible to instantiate even though the dimension size of x is not
 **    known.
 **
 ** 3. Implicit instantiation controlled by the next last argument to inst_class_in. 
 **    This is also needed, when a DAE should not be generated. 
 **    It is not clear when this is needed, perhaps it can be removed in the future.

 ** 4. Full instantiation, which is used for standard model instantiation, when equations
 **    variables, etc., are generated. This is enabled by setting the last two booleans
 **    of inst_class_in to false.

 **
 ** Instantiation steps
 ** ===================
 ** The instantiation is done in several steps, see relation inst_classdef.
 ** 1. All local class definitions are added to the environment.
 ** 2. The inheritance structure is flattened out annotating each inherited 
 **    component with the base class it originates from (for correct lookup later on)
 ** 3. All components are added (untyped) to the environment
 ** 4. Instantiation of components occur.
 **    When a component is instantiated in inst_element it first collects all other
 **    component references from array dimensions and modifiers and recursively 
 **    (i.e. backpatching) instantiates these first. This is performed to allow using a
 **    variable before it has been declared. This is done in the update_variable_in_env 
 **    function.
**)
 


  (* Exported Relations *)
  relation instantiate: SCode.Program => DAE.DAElist
  relation instantiate_implicit: SCode.Program => DAE.DAElist
  
  relation make_binding : (Env.Env, SCode.Attributes, Types.EqMod option)
	  => Types.Binding

  relation instantiate_class : (SCode.Program,SCode.Path) => (DAE.DAElist,Env.Env)

  relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env 
  relation make_simple_env_from_program: (SCode.Program,SCode.Path) => Env.Env 

  relation inst_class: ( Env.Env, Types.Mod, Prefix.Prefix, 
			Connect.Sets, SCode.Class, InstDims,bool,CallingScope)
	  => ( DAE.Element list, Env.Env, Connect.Sets, Types.Type, ClassInf.State)


  relation inst_class_decl : ( Env.Env, Types.Mod, Prefix.Prefix,
			      Connect.Sets, SCode.Class, InstDims, bool)
	  => ( Env.Env, DAE.Element list)

  relation inst_class_in: ( Env.Env, Types.Mod, Prefix.Prefix, 
			   Connect.Sets, ClassInf.State,
			   SCode.Class, bool, InstDims, 
			   bool(*implicit inst*),
			   bool(* function implicit inst*))
	  => ( DAE.Element list, Env.Env, Connect.Sets, 
	      ClassInf.State, Types.Var list)

  relation partial_inst_class_in: ( Env.Env, Types.Mod, Prefix.Prefix, 
			   Connect.Sets, ClassInf.State,
			   SCode.Class, bool, InstDims)
	  => (Env.Env, ClassInf.State)

  relation implicit_instantiation : (Env.Env, Types.Mod, Prefix.Prefix,
				     Connect.Sets, SCode.Class,InstDims, bool)
	  => (Env.Env, DAE.Element list)
	    
  relation inst_record_constructor_elt : (Env.Env, SCode.Element) 
	 => (Types.Var)
  relation mktype : (Absyn.Path, ClassInf.State,Types.Var list) => Types.Type

  relation init_vars_modelica_output : DAE.Element list => DAE.Element list

  relation new_ident : () => Exp.ComponentRef
  relation implicit_function_instantiation : ( Env.Env, Types.Mod, 
					      Prefix.Prefix, Connect.Sets, SCode.Class,
					      InstDims, bool)
	  => ( Env.Env, DAE.Element list)
  relation package_prefix : (Env.Env, Absyn.Path) => Absyn.Path
  relation add_nomod: SCode.Element list => (SCode.Element*Types.Mod) list

end

with "debug.rml"
with "interactive.rml"							  
with "util.rml"
with "algorithm.rml"
with "builtin.rml"
with "dump.rml"
with "lookup.rml"
with "modutil.rml"
with "rtopts.rml"
with "staticexp.rml"
with "values.rml"
with "print.rml"
with "system.rml"
with "ceval.rml"

val for_scope_name = "$for loop scope$"	  
(**
 ** These type aliases are introduced to make the code a little more
 ** readable.
 **)

type Prefix = Prefix.Prefix
type Mod = Types.Mod
type Ident = Exp.Ident
type Env = Env.Env


relation print_dims: DimExp list => () =
  rule	print_dim([SOME(x)]) => () &
	print_dims(xs) => ()
	-------------------
	print_dims(x::xs) => ()

  axiom	print_dims([]) => ()
end


(** relation: new_ident
 **
 ** This relation creates a new, unique identifer.  The same name is
 ** never returned twice.
 **)

relation new_ident : () => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append("__TMP__",is) => s
	-----------------------------------------------------------------
	new_ident => Exp.CREF_IDENT(s,[])

end


(** relation: select
 **
 ** This utility relation selects one of two objects depending on a
 ** boolean variable.
 **)

relation select : (bool, 'a, 'a) => 'a =

  axiom	select (true,x,_) => x
  axiom	select (false,_,x) => x

end

(** relation: instantiate
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAElist =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l 
	-----------------------------
	instantiate(p) => DAE.DAE(l)
end

(** Implicit instantiation of a program can be used for e.g. code generation of functions, since a function must be implicitly instantiated in order to generate code from it. *)

relation instantiate_implicit: SCode.Program => DAE.DAElist =

  rule	Builtin.initial_env => env &
	Env.extend_frame_classes(env,p) => env' &
	inst_program_implicit(env',p) => l 
	-----------------------------
	instantiate_implicit(p) => DAE.DAE(l)
end


(** relation: instantiate_class
 **
 **
 ** To enable interactive instantiation, an arbitrary class in the program needs to be
 ** possible to instantiate. This relation performs the same action as `inst_program', 
 **  but given a specific class to instantiate.
 **  First all the class
 ** definitions is added to the environment without modifications, and
 ** then the specified class is instantiated in the relation `inst_class'
 **)

relation instantiate_class : (SCode.Program, SCode.Path) => (DAE.DAElist,Env.Env) =

  rule	Print.print_buf "# Empty program\n"
	------------------------------
	instantiate_class([],cr) => fail

  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path) => (env',dae1) &
 	inst_class_in_program(env',cdecls,path) => (dae,env'')
	-----------------------------
	instantiate_class(cdecls, path as Absyn.IDENT(name2)) 
	  => (DAE.DAE([DAE.COMP(name2,DAE.DAE(dae))]),env'')

  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path)=> (env',_) &
	Lookup.lookup_class(env',path,true) 
	  => (cdef as SCode.CLASS(n,_,_,_,_), env'') &
	inst_class(env'', Types.NOMOD, Prefix.NOPRE, [], cdef, [], false,TOP_CALL) 
	  => (dae,env'', _, _, _) &
	Absyn.path_string path => pathstr
	--------------------------------------------
	instantiate_class(cdecls, path as Absyn.QUALIFIED(name,_)) 
	  => (DAE.DAE([DAE.COMP(pathstr,DAE.DAE(dae))]),env'')
	

  rule	(*Debug.fprint("failtrace", "- instantiate_class failed\n")*)
	------------
	instantiate_class(_,_) => fail
end

relation inst_class_in_program: (Env, SCode.Program, SCode.Path ) => (DAE.Element list, Env.Env) =
	
  rule	name = name2 &
	inst_class(env, Types.NOMOD, Prefix.NOPRE, [], c, [], false,TOP_CALL) 
	  => (dae, env', _, _,_) 
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_,_))::cs,Absyn.IDENT(name2)) 
	  => (dae,env')

  rule	not name = name2 &
	inst_class_in_program(env,cs,path) => (dae,env)
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_,_))::cs, path as Absyn.IDENT(name2)) 
	  => (dae, env)

  axiom	inst_class_in_program(env,[],_) => ([],env)
	
  rule	(*Debug.fprint("failtrace", "inst_class_in_program failed\n")*)
	-------------------------------
	inst_class_in_program(env,_,_) => fail

end

(** relation: inst_class_decls
 ** This relation instantiated class definitions, i.e. adding the class definitions to the
 ** environment. See also partial_inst_class_in.
 **)
relation inst_class_decls:(Env, SCode.Program, SCode.Path) => ( Env.Env, DAE.Element list) =
  rule	not name = name2 &
	inst_class_decl(env, Types.NOMOD, Prefix.NOPRE, [], c, [], false) 
	  => (env', dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env'',dae)

  rule	name = name2 &      
	inst_class_decls(env,cs,ref) => (env', dae2)
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env',dae2)

  rule	name = name2 &      
	(* How should be do here ??? *)
	inst_class_decl(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae  
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.QUALIFIED(name2,_)) => (env'',dae)

  rule	not name = name2 &      
	inst_class_decl(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae  
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.QUALIFIED(name2,_)) => (env'',dae)

axiom	inst_class_decls(env,[],_) => (env,[])
	
  rule	print "inst_class_decls failed\n ref =" &
	Absyn.path_string ref => str &
	print str & print "\n" 
	--------------------
	inst_class_decls(_,_,ref) => fail
end

(** relation: make_env_from_program
 ** This relation takes a `SCode.Program' and builds an environment, excluding the class in A1.
**)

relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env = 
  rule	Builtin.initial_env => env &
	add_program_to_env(env,prog,c) => env'
	--------------------------------
	make_env_from_program (prog,c) => env'
end

relation make_simple_env_from_program: (SCode.Program,SCode.Path) => Env.Env = 
  rule	Builtin.simple_initial_env => env &
	add_program_to_env(env,prog,c) => env'
	--------------------------------
	make_simple_env_from_program (prog,c) => env'
end

relation add_program_to_env: (Env.Env,SCode.Program,SCode.Path) => Env.Env =
  rule	inst_class_decls(env,p,path) => (env' ,_) 
	-----------------------------------------
	add_program_to_env (env,p,path) => env'
end


(** relation: inst_program
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'.
 ** This is used when calling the compiler with a Modelica source code file.
 ** It is not used in the interactive environment when instantiating a class.
 **)

relation inst_program : (Env, SCode.Program) => DAE.Element list =

  rule	Print.print_buf "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail


  rule	(*Debug.fprintln ("insttr", "inst_program1") &*)
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_class(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false,TOP_CALL) 
	  => (dae,env',csets,_,_) 
	-----------------------------
	inst_program(env,[c as SCode.CLASS(n,_,_,_,_)])
	  => [DAE.COMP(n,DAE.DAE(dae))]

  rule	(*Debug.fprintln ("insttr", "inst_program2") &*)
	inst_class_decl(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (env',dae1) &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_program(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	----------------------
	inst_program(env,c::(cs as (_::_))) => dae

  rule	Print.print_buf "- inst_program failed\n" 
	------------
	inst_program(_,_) => fail
end


relation inst_program_implicit : (Env, SCode.Program) => DAE.Element list =
	
  rule	(*Debug.fprintln ("insttr", "inst_program_implicit") &*)
	implicit_instantiation(env,Types.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (env', dae1) &
	inst_program_implicit(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_program_implicit(env,(c as SCode.CLASS(n,_,_,restr,_))::cs) => dae

  rule	(*Debug.fprintln ("insttr", "inst_program_implicit (end)")*)
	----------------------------------------------------
	 inst_program_implicit(env,[]) => []

end

(** relation: inst_class
 **
 ** Instantiation of a class can be either implicit or "normal". This relation is 
 ** used in both cases. When implicit instantiation is performed, the last argument 
 ** is true, otherwise it is false.
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class : (Env, Mod, Prefix, Connect.Sets, SCode.Class, 
		       InstDims,bool,CallingScope)
	  => (DAE.Element list, Env.Env, Connect.Sets, Types.Type, ClassInf.State) =
	  
  rule	(* Classes with the keyword partial can not be instantiated.
	 They can only be inherited *)
	Print.print_buf "# Can't instantiate partial class " & 
	Print.print_buf n & Print.print_buf "\n"
	------------------------------------------------------	
	inst_class(env,mod,pre, csets, SCode.CLASS(n,true,_,_,_),_,false,_) => fail

  rule	Env.open_scope(env,encflag,SOME(n)) => env' &
	ClassInf.start(r,n) => ci_state &
	inst_class_in(env', mod, pre, csets, ci_state, c, false, inst_dims, impl,false)
	  => (dae1, env''', csets', ci_state', tys) &
	
	is_top_call(callscope) => callscope' &  
	Connect.equations csets' => dae2 &
	
	Connect.unconnected_flow_equations (csets',dae1,env''', callscope') => dae3 &
	Util.list_flatten([dae1, dae2, dae3]) => dae &
	package_prefix(env, Absyn.IDENT(n)) => typename &
	mktype(typename,ci_state',tys) => ty
	-------------------------------------------
	inst_class(env, mod, pre, csets, c as SCode.CLASS(n,_,encflag,r,_),inst_dims,impl,callscope)
	  => (dae, env''', [], ty, ci_state')

  rule	Debug.fprint("failtrace", "- inst_class ") & 
	Debug.fprint("failtrace",  n) &
	Debug.fprint("failtrace", " failed\n") 
	-----------------------------------------------------
	inst_class(_,_,_,_,SCode.CLASS(n,_,_,_,_),_,impl,_) => fail
	
end

(** relation: inst_class_in
 **
 ** This rule instantiates the contents of a class definition, with a
 ** new environment already setup.
 ** The next last boolean indicates if the class should be instantiated 
 ** implicit, i.e. without generating DAE.
 ** The last boolean is a even stronger indication of implicit instantiation,
 ** used when looking up variables in packages. This must be used because 
 ** generation of functions in implicit instanitation (according to next last 
 ** boolean) can cause circular dependencies (e.g. if a function uses a
 ** constant in its body) 
 **)

relation inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool (*Accesibility*), InstDims, 
			 bool, (*implicit instantiation*)
			 bool (* implicit function instantiation *)
			 )
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  axiom inst_class_in(env,mods,pre,csets,ci_state,
                      c as SCode.CLASS("Real",_,_,_,_),_,_, impl,packimpl)
          => ([] (* No DAE *), env, [], ci_state, [])
	  
  axiom inst_class_in(env,mods,pre,csets,ci_state,
                      c as SCode.CLASS("Integer",_,_,_,_),_,_, impl,packimpl)
          => ([] (* No DAE *), env, [], ci_state, [])
	  
  axiom inst_class_in(env,mods,pre,csets,ci_state,
                      c as SCode.CLASS("String",_,_,_,_),_,_, impl,packimpl)
          => ([] (* No DAE *), env, [], ci_state, [])
	  
 axiom inst_class_in(env,mods,pre,csets,ci_state,
                     c as SCode.CLASS("Boolean",_,_,_,_),_,_, impl,packimpl)
         => ([] (* No DAE *), env, [], ci_state, [])

  rule	(*print "inst_class_in" & print n & print "\n" &*)
	inst_classdef(env,mods,pre,csets,ci_state,d,r,prot,inst_dims
		      ,impl,packimpl)
	  => (l,env', csets', ci_state', tys) 
	-------------------------------------
	inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,_,r,d), prot, inst_dims,
		      impl,packimpl)
	  => (l,env', csets', ci_state', tys)

  rule  Debug.fprint("failtrace", "- inst_class_in failed\n")
	----------------------------------
	inst_class_in(_,_,_,csets,_,_,_,_,_,_) => fail

end

(** relation: partial_inst_class_in
**
** This relation is used when instantiating classes in lookup of other classes.
** The only work performed by this relation is to instantiate local classes and 
** inherited classes.
**)
relation partial_inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool, InstDims)
	  => (Env, ClassInf.State) =

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("Real",_,_,_,_),_,_) 
	  => (env,ci_state)

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("Integer",_,_,_,_),_,_)
	  => (env,ci_state)

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("String",_,_,_,_),_,_)
	  => (env,ci_state)

  axiom	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS("Boolean",_,_,_,_),_,_)
	  => (env,ci_state)

  rule	partial_inst_classdef(env,mods,pre,csets,ci_state,d,r,prot,inst_dims)
	  => (env',ci_state') 
	(*& Env.print_env env' & Print.get_string => s & print "env: " & print s*)
	-------------------------------------
	partial_inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,_,r,d), prot, inst_dims)
	  => (env',ci_state')
end

(** relation: inst_classdef
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 ** The last two arguments are the same as for inst_class_in: 
 ** implicit instantiation and implicit package/function instantiation
 **)

relation inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, SCode.Restriction, bool,InstDims,
			 bool, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	(*Prefix.print_prefix_str pre => prestr &*)
	(*Debug.fprintl ("insttr", ["inst_class parts: pre=",prestr,"\n"]) &*)
	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	component_elts(els) => compelts &
	extends_elts(els) => extendselts &

	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,impl) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)

	inst_extends_list(env1, mods, extendselts, ci_state,impl)
	  => (env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) &
	  (* Problem. Modifiers on inherited components are unelabed, loosing their 
	   type information. This will not work, since the modifier type can not always be found.
	   for instance. 
	   model B extends B2; end B; model B2 Integer ni=1; end B2;
	   model test
	     Integer n=2;
	      B b(ni=n);
	   end test;
	   The modifier (n=n) will be untypes when B is instantiated and the variable n can not be 
	   found, since the component b is instantiated in env of B.
	   Solution:
	   Redesign inst_extends_list to return (SCode.Element, Types.Mod) list and
	   convert other component elements to the same format, such that inst_element can 
	   handle the new format uniformely.
	   *)
	add_nomod(compelts) => compelts' &
	add_nomod(cdefelts) => cdefelts' &
	Util.list_flatten([extcomps,compelts',cdefelts']) => compelts' &	
	

	(* Add variables to env, wihtout type and binding, *)
	(* which will be added later in inst_element_list  *)
	(* (where update_variable is called) *)
	add_components_to_env(env2,emods,pre,csets,ci_state,compelts',compelts',inst_dims,impl) 
	  => env3 &
	  (* Update the modifiers of elements to typed ones, needed for modifiers
	   on components that are inherited. *)
	update_compelts_mods(env3,pre,compelts',ci_state,impl)  
	  => (compelts'',env4) &

	(* Add components from base classes to be instantiated in 3 as well. *)
	list_append(eqs,eqs2) => eqs' &
	list_append(initeqs,initeqs2) => initeqs' &
	list_append(alg,alg2) => alg' &
	list_append(initalg,initalg2) => initalg' &
	(*3. Instantiate components *)
	inst_element_list(env4, mods, pre, csets, ci_state1, compelts'', 
			  inst_dims, impl, false)
	  => (dae1,env5, csets1, ci_state2, tys) &
	inst_list(env5,mods,pre,csets1,ci_state2,inst_equation, eqs')
	  => (dae2,_,csets2, ci_state3) &
	inst_list(env5,mods,pre,csets2,ci_state3,inst_initialequation, initeqs')
	  => (dae3,_,csets3, ci_state4) &
	inst_list(env5,mods,pre,csets3,ci_state4, inst_algorithm, alg')
	  => (dae4,_,csets4, ci_state5) &
	inst_list(env5,mods,pre,csets4,ci_state5, inst_initialalgorithm, initalg')
	  => (dae5,_,csets5, ci_state6) &
	list_append(dae1,dae2) => dae6 &
	list_append(dae6,dae3) => dae7 &
	list_append(dae7,dae4) => dae8 &
	list_append(dae8,dae5) => dae 
	------------------------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims, impl, false)
	  => (dae, env5, csets5, ci_state6, tys)

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	
	(*Debug.fprintl ("insttr", ["inst_class parts: pre=",prestr,"\n"]) & *)
	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	component_elts(els) => compelts &
	extends_elts(els) => extendselts &
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,impl) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	inst_extends_list(env1, mods, extendselts, ci_state, impl)
	  => (env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) &
		
	add_nomod(compelts) => compelts' &
	add_nomod(cdefelts) => cdefelts' &
	Util.list_flatten([extcomps,compelts',cdefelts']) => compelts' &	
	
	(* Add variables to env, wihtout type and binding, *)
	(* which will be added later in inst_element_list  *)
	(* (where update_variable is called) *)
	add_components_to_env(env2,emods,pre,csets,ci_state,compelts',compelts',inst_dims,impl) => env3 &
	(* Add components from base classes to be instantiated in 3 as well. *)
	list_append(eqs,eqs2) => eqs' &
	list_append(initeqs,initeqs2) => initeqs' &
	list_append(alg,alg2) => alg' &
	list_append(initalg,initalg2) => initalg' &
	(*3. Instantiate components *)
	inst_element_list(env3,mods,pre,csets,ci_state1, compelts', 
			  inst_dims, impl, true)
	  => (dae1, env4, csets1, ci_state2, tys) 
	------------------------------------------------------
	inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims, impl, true)
	  => (dae1, env4, csets1, ci_state2, tys)


	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	(*Prefix.print_prefix_str pre => prestr &
	Absyn.path_string cn => cnstr &*)
	(*Debug.fprintl ("insttr", ["inst_class derived: ", cnstr, ", pre=",prestr,"\n"]) &*)
	Lookup.lookup_class(env,cn,true) 
	  => (c as SCode.CLASS(cn2,_,enc2,r,_), cenv) &
	Env.open_scope(cenv,enc2,SOME(cn2)) => cenv'' &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	Mod.merge(mods,m,cenv'',pre) => mods' &
	Mod.merge(mods',mod',cenv'',pre) => mods'' &
	inst_class_in(cenv'', mods'', pre, csets, new_ci_state, c,prot,inst_dims,impl,false)
	  => (dae, env'', csets', ci_state', tys) &
	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims, impl, packimpl)
	  => (dae, env'', csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn,false) => (_,_) &
	Absyn.path_string(cn) => cns &
	Print.print_buf "# unknown class: " & Print.print_buf cns & 
	Print.print_buf "\n" & Env.print_env env
	----------------------------------------
	inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims, impl, packimpl)
	  => fail
	
  rule	Debug.fprint("failtrace", "- inst_classdef failed\n")
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_,_,_,_) => fail

end	

(** relation: partial_inst_classdef
 **
 ** This relation is used by partial_inst_class_in for instantiating local class
 ** definitons and inherited class definitions only.
 **)
relation partial_inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, SCode.Restriction, bool,InstDims)
	  => ( Env, ClassInf.State ) =

  rule	
	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	extends_elts(els) => extendselts &
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,true) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	inst_extends_list(env1, mods, extendselts, ci_state, true)
	  => (env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) 
	------------------------------------------------------
	partial_inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims)
	  => (env2,ci_state1)


	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Lookup.lookup_class(env,cn,true) 
	  => (c as SCode.CLASS(cn2,_,enc2,r,_), cenv) &
	Env.open_scope(cenv,enc2,SOME(cn2)) => cenv'' &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	Mod.merge(mods,m,cenv'',pre) => mods' &
	Mod.merge(mods',mod',cenv'',pre) => mods'' &
	partial_inst_class_in(cenv'', mods'', pre, csets, new_ci_state, c,prot,inst_dims)
	  =>  (env'',new_ci_state')
	----------------------------------------
	partial_inst_classdef(env, mods, pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims)
	  => (env'',new_ci_state')

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn,false) => (_,_) &
	Absyn.path_string(cn) => cns &
	Print.print_buf "# unknown class: " & Print.print_buf cns & Print.print_buf "\n"
	& Env.print_env env
	----------------------------------------
	partial_inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims)
	  => fail
end	

relation update_compelts_mods: (Env.Env, Prefix.Prefix, (SCode.Element*Types.Mod) list,
				ClassInf.State, bool) 
	=> ((SCode.Element * Types.Mod) list, Env.Env) =

  axiom	update_compelts_mods(env,pre,[],_,_) =>([],env)

  rule	Mod.unelab_mod(cmod) => umod &
	get_cref_from_mod(umod) => crefs &
	update_variables_in_env(cmod,crefs,env,ci_state,impl) => env2 &
	Mod.update_mod(env2,pre,cmod) => cmod' &
	update_compelts_mods(env2,pre,xs,ci_state,impl) => (res,env3)
	-------------------
	update_compelts_mods(env,pre,(comp,cmod)::xs,ci_state,impl) 
	  => ((comp,cmod')::res,env3)
end

relation get_option_arraydim: (Absyn.ArrayDim option) => Absyn.ArrayDim =

  axiom	get_option_arraydim (SOME(dim)) => dim

  axiom	get_option_arraydim (NONE) => []
end

relation convert_to_instdims: (DimExp list) => InstDims =

  axiom convert_to_instdims [] => []

  rule	convert_to_instdims(xs) => res 
	-----------------------
	convert_to_instdims(DIMINT(i)::xs) => Exp.INDEX(Exp.ICONST(i))::res

  rule	convert_to_instdims(xs) => res 
	------------------------------
	convert_to_instdims(DIMEXP(sub,exp)::xs) => sub::res	

  rule	(*Debug.fprint("failtrace","- convert_to_instdims failed\n")*)
	------------------------
	convert_to_instdims(_) => fail
end

(** relation: inst_extends_list 
 ** 
 ** This relations flattens out the inheritance structure of a class.
 ** It takes an SCode.Element list and flattens out the extends nodes
 ** of that list. The result is a list of components and lists of equations
 ** and algorithms.
**)
relation	inst_extends_list:(Env.Env, Types.Mod, SCode.Element list, ClassInf.State, bool)
	  => (Env.Env, Types.Mod, (SCode.Element * Types.Mod) list, SCode.Equation list,
	      SCode.Equation list, SCode.Algorithm list, SCode.Algorithm list) 
	=
  rule	Lookup.lookup_class(env, tp, true) 
	  => (c as SCode.CLASS(cn,_,encf,r,_), cenv) &
	Mod.lookup_modification_p(mod, Absyn.IDENT(cn)) => outermod &
	inst_derived_classes(cenv, outermod, c, impl) =>
	  (cenv1, els, eq1, ieq1, alg1, ialg1) &
	fully_qualified(tp,cenv1) => tp' &
	add_inherit_scope(els,tp') => els' &
	Env.open_scope(cenv1,encf,SOME(cn)) => cenv3 &
	ClassInf.start(r, cn) => new_ci_state &
	Mod.elab_untyped_mod(emod,cenv3,Prefix.NOPRE) => mod' &
	Mod.merge(outermod,mod',cenv3,Prefix.NOPRE) => mod'' &

	inst_extends_list(cenv1(*env*), outermod, els', ci_state, impl) 
	  => (_,mods, compelts1, eq2, ieq2, alg2, ialg2) &  

	inst_extends_list(env, mod, rest, ci_state,impl)
	  => (env2, mods', compelts2, eq3, ieq3, alg3, ialg3) & 
	(* corresponding elements. But emod is Absyn.Mod and can not  *)
	(* Must merge(mod,emod) here and then apply the bindings to the *)
	(* be elaborated, because for instance extends A(x=y) can reference *)
	(* a variable y defined in A and will thus not be found. *)
	(* On the other hand: A(n=4), n might be a structural parameter that must be set to *)
	(* instantiate A. How could this be solved? *)
	(* Solution: made new relation elab_untyped_mod which transforms *)
	(* to a Mod, but set the type information to unknown. *)
	(* We can then perform the merge, and update untyped modifications *)
	(* later (using update_mod), when we are instantiating the components. *)
	Mod.elab_untyped_mod(emod,env2,Prefix.NOPRE) => emod' &
	Mod.merge(mod,mods',env2,Prefix.NOPRE) => mod' &
	Mod.merge(mod',emod',env2,Prefix.NOPRE) => mods' &
	list_append(compelts1, compelts2) => compelts &	
				      
(*	  Print.print_buf "\n compelts list: " &
	  SCode.print_element_list(compelts) &
	Print.print_buf "mod =" & 
	Mod.print_mod mods' &	
	Print.get_string() => str1 & print str1 &*)
	update_components(compelts,mods',env2) => compelts3 &
        Util.list_flatten([eq1, eq2, eq3]) => eq &
	Util.list_flatten([ieq1, ieq2, ieq3]) => ieq &
	Util.list_flatten([alg1, alg2, alg3]) => alg &
	Util.list_flatten([ialg1, ialg2,ialg3]) => ialg 
	-----------------------------------
	inst_extends_list(env, mod, SCode.EXTENDS(tp,emod)::rest, ci_state,impl)
	  => (env2, mods',compelts3, eq, ieq, alg, ialg)

  rule	not Lookup.lookup_class(env, tp, true) 
	  => (c as SCode.CLASS(cn,_,encf,r,_), cenv) &
	Debug.fprint("failtrace", "Failed lookup of inherited class ") &
	Debug.fcall("failtrace",Dump.print_path, tp) &			
	Debug.fprint("failtrace", ", env: ") &      
	Debug.fcall("failtrace",Env.print_env,env) &
	Debug.fprint("failtrace","\n") 			      
	------------------------------------------------
	inst_extends_list(env, mod, SCode.EXTENDS(tp,emod)::rest, ci_state, impl) 
	  => fail
  rule	Debug.fprint("failtrace", "Failed inst_extends_list on EXTENDS\n env:") &
	Env.print_env env 			      
	------------------------------------------------
	inst_extends_list(env, mod, SCode.EXTENDS(tp,emod)::rest, ci_state, impl) 
	  => fail

  rule	inst_extends_list(env, mod, rest, ci_state, impl)
	  => (env', mods, compelts2, eq2, initeq2, alg2, ialg2) 
	------------------------------------------------
	inst_extends_list(env, mod, elt::rest, ci_state, impl) 
	  => (env',mods, (elt,Types.NOMOD)::compelts2, eq2, initeq2, alg2, ialg2) 

  axiom	inst_extends_list(env, mod, [], ci_state, impl) 
	  => (env, mod, [], [], [], [], [])

  rule	Debug.fprint("failtrace",  "- inst_extends_list failed\n" )
	---------------------
	inst_extends_list(_,_,_,_,_) => fail
end


relation fully_qualified:(Absyn.Path,Env.Env) => Absyn.Path =

  rule	Env.get_env_path (env) => SOME(prefix) &
	Absyn.path_last_ident(tp) => last &
	Absyn.join_paths(prefix,Absyn.IDENT(last)) => res
	------------------
	fully_qualified(tp,env)=> res

  axiom	fully_qualified(tp,_) => tp

end

relation add_inherit_scope: ( SCode.Element list, Absyn.Path) 
	  => SCode.Element list =

  axiom	add_inherit_scope ([],_) => []

  rule	add_inherit_scope(xs,tp) => res
	-------------------------------
	add_inherit_scope(SCode.COMPONENT(a,b,c,d,e,f,g,_)::xs,tp)
	  => SCode.COMPONENT(a,b,c,d,e,f,g,SOME(tp))::res

  rule	add_inherit_scope(xs,tp) => res
	-------------------------------
	add_inherit_scope(SCode.CLASSDEF(a,b,c,d,_)::xs,tp)
	  => SCode.CLASSDEF(a,b,c,d,SOME(tp))::res

  rule	add_inherit_scope(xs,tp) => res
	-------------------------------
	add_inherit_scope(x::xs,tp)
	  => x::res

  rule	print "add_inherit_scope failed\n" 
	------------------
	add_inherit_scope(_,_) => fail
end

relation add_local_classes_to_env: (Env.Env, SCode.Class) => Env.Env =

  rule	add_local_classes_to_env2(env,parts) => env'
	-------------------------------------	
	add_local_classes_to_env(env,SCode.CLASS(_,_,_,_,SCode.PARTS(parts,_,_,_,_,_)))=> env'
	
  axiom	add_local_classes_to_env(env,_) => env
end

relation add_local_classes_to_env2: (Env.Env, SCode.Element list) => Env.Env =

  axiom	add_local_classes_to_env2(env,[]) => env

  rule	Env.extend_frame_c(env,c) => env' &
	add_local_classes_to_env2(env',xs) => env''
	------------------------------------------
	add_local_classes_to_env2(env,SCode.CLASSDEF(n,_,_,c,_)::xs) => env''
	
  rule	Env.extend_frame_i(env,imp) => env' &
	add_local_classes_to_env2(env',xs) => env''
	-------------------------------------------
	add_local_classes_to_env2(env,SCode.IMPORT(imp)::xs) => env''

  rule	add_local_classes_to_env2(env,xs) => env'
	--------------------------------------
	add_local_classes_to_env2(env,_::xs) => env'
end

(** relation: add_nomod 
 ** This relation takes an SCode.Element list and tranforms it into a (SCode.Element* Types.Mod) list
 ** by inserting Types.NOMOD for each element. Used to transform elements into a uniform list 
 ** combined from inherited elements and ordinary elements.
 **)
relation add_nomod: SCode.Element list => (SCode.Element*Types.Mod) list =

  axiom	add_nomod [] => []

  rule	add_nomod(xs) => res 
	--------------------
	add_nomod(x::xs) => ((x,Types.NOMOD)::res)
end

(** relation: update_components
 ** This relation takes a list of components and a Mod and returns a list of components with the modifiers updated.
 ** The relation is used when flattening the inheritance structure, resulting in a list of components to insert into
 ** the class definition. For instance model A extends B(modifiers) end A; will result in a list of components from B 
 ** which 'modifiers' should be applied to.
**)
relation update_components: ((SCode.Element*Types.Mod) list, Types.Mod,Env.Env)
	  => (SCode.Element*Types.Mod) list =

  axiom	update_components([],_,_) => []

  rule 	Mod.lookup_comp_modification(mod,id) => cmod2 &
	Mod.merge(cmod,cmod2,env,Prefix.NOPRE) => mod' &
	update_components(xs,mod,env) => res 
	--------------------------------
	update_components((comp as SCode.COMPONENT(id,_,_,_,_,_,_,_),cmod)::xs,mod,env) 
	  => ((comp,mod')::res)

  rule	update_components(xs,mod,env) => res 
	--------------------------------
	update_components(((c as SCode.EXTENDS(_,_)),emod)::xs,mod,env) 
	  => ((c,emod)::res)

  rule	update_components(xs,mod,env) => res 
	--------------------------------
	update_components(((c as SCode.CLASSDEF(_,_,_,_,_)),cmod)::xs,mod,env) 
	  => ((c,cmod)::res)

  rule	update_components(xs,mod,env) => res 
	--------------------------------
	update_components(((c as SCode.IMPORT(_)),_)::xs,mod,env) 
	  => ((c,Types.NOMOD)::res)

  rule	Debug.fprint("failtrace", "-update_components failed\n")
	----------------------
	update_components(_,_,_) => fail
end

(** relation: inst_derived_classes
 ** 
 ** This relation takes a class definition and returns the
 ** elements and equations and algorithms of the class.
 ** If the class is derived, the class is looked up and the 
 ** derived class parts are fetched.
 **)

relation inst_derived_classes: 	(Env.Env, Types.Mod, SCode.Class, bool) =>
	  (Env.Env, SCode.Element list, SCode.Equation list, 
	   SCode.Equation list, SCode.Algorithm list, SCode.Algorithm list) =
	
  axiom	inst_derived_classes(env,mod,SCode.CLASS(_,_,_,_,SCode.PARTS(elt,eq,ieq,alg,ialg,_)),_) => (env,elt,eq,ieq,alg,ialg)

  rule	Lookup.lookup_class(env,tp,true) => (c,cenv) &
	(* Mod.lookup_modification_p(mod, c) => innermod & *)
	(* We have to merge and apply modifications as well! *)
	inst_derived_classes(cenv, mod, c, impl) 
	  => (env, elt, eq, ieq, alg, ialg)
	-------------------------------------
	inst_derived_classes(env, mod, SCode.CLASS(_,_,_,_,SCode.DERIVED(tp,_,dmod)),impl) 
	  => (env, elt, eq, ieq, alg, ialg) 

  rule	Debug.fprint("failtrace", "- inst_derived_classes failed\n")
	----------------------
	inst_derived_classes(_,_,_,_) => fail
end


(** relation: inst_element_list
 **
 ** Moved to inst_classdef, FIXME: Move commments later
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 ** P.A, Modelica1.4: (enables declare before use)
 ** 1. "First names of declared local classes (and components) are found. Redeclarations are performed."
 ** This means that we first handle all CLASSDEF nodes and apply modifiers and declarations to them and 
 ** also COMPONENT nodes to add the variables to the environment.
 ** 2. Second, "base-classes are looked up, flattened and inserted into the class."
 ** This means that all EXTENDS nodes are handled.
 ** 3. Third, "Flatten the class, apply modifiers and instantiate all local elements."
 ** This handles COMPONENT nodes.
 **)

relation inst_element_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			    (SCode.Element*Types.Mod) list, InstDims, bool, bool)
	    => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
		Types.Var list) =
	
  axiom	inst_element_list(env,_,_,csets,ci_state,[],_,_,_)
	    => ([], env, csets, ci_state, [])
	
  rule  inst_element(env,mod,pre,csets,ci_state,el,inst_dims,impl, packimpl)
	  => (dae1,env',csets',ci_state',tys1) &
	inst_element_list(env',mod,pre,csets',ci_state',els,inst_dims,impl,packimpl)
	  => (dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae 
	------------------------------
	inst_element_list(env, mod, pre, csets, ci_state, el::els, inst_dims, impl, packimpl)
	  => (dae, env'', csets'', ci_state'', tys)

  rule	Debug.fprint("failtrace", "- inst_element_list failed\n")
	------------------------------------
	inst_element_list(_,_,_,_,_,els,_,_,_) => fail
end

relation classdef_elts: (SCode.Element list) => (SCode.Element list) =

  axiom classdef_elts ([]) => []
	
  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts ((cdef as SCode.CLASSDEF(_,_,_,_,_))::xs) => cdef::res

  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts((imp as SCode.IMPORT(_))::xs) => imp::res

  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts(_::xs) => res
end

relation extends_elts: (SCode.Element list) => (SCode.Element list) =

  axiom extends_elts ([]) => []
	
  rule	extends_elts(xs) => res
	------------------------
	extends_elts ((cdef as SCode.EXTENDS(_,_))::xs) => cdef::res

  rule	extends_elts(xs) => res
	------------------------
	extends_elts(_::xs) => res
end

relation component_elts: (SCode.Element list) => (SCode.Element list) =

  axiom component_elts ([]) => []
	
  rule	component_elts(xs) => res
	------------------------
	component_elts ((cdef as SCode.COMPONENT(_,_,_,_,_,_,_,_))::xs) => cdef::res

  rule	component_elts(xs) => res
	------------------------
	component_elts(_::xs) => res
end

relation add_classdefs_to_env : (Env, SCode.Element list, bool) => (Env) =

  axiom	add_classdefs_to_env(env,[],_) => env

  rule	Env.extend_frame_c(env,cl) => env' &
	add_classdefs_to_env(env',xs,impl) => env''
	------------------
	add_classdefs_to_env(env,(SCode.CLASSDEF(_,_,_,cl,_))::xs,impl) => env''

  rule	Env.extend_frame_i(env,imp) => env' &
	add_classdefs_to_env(env',xs,impl) => env''
	-------------------------
	add_classdefs_to_env(env,(SCode.IMPORT(imp))::xs,impl) => env''
end  

(** This first relation in the two stage solution changes parameters to structural parameters if they are affecting
 ** the number of variables or equations. For now by only looking at dimension sizes of components.
**)
relation add_components_to_env : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
				  (SCode.Element*Types.Mod) list, (SCode.Element*Types.Mod) list,  InstDims, bool)
	=> (Env) =

  axiom	add_components_to_env(env,_,_,_,_,[],_,_,_) => env 

  rule	(* Check if the component is a structural parameter, change it's
	 attribute to STRUCTPARAM. *)
	not ClassInf.is_function(cistate) &  (* Functions should not be considered *)
	get_crefs_from_compdims(allcomps) => crefs &
	member_crefs(Absyn.CREF_IDENT(n,[]),crefs) => true &
	SCode.is_parameter_or_const param => true &
	add_components_to_env2(env,mod,pre,csets,cistate,[(SCode.COMPONENT(n,final,repl,prot,
									  SCode.ATTR(ad,flow,acc,SCode.STRUCTPARAM,dir),t,m,bc),cmod)],instdims,impl) => env' &
	add_components_to_env(env',mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------------------------------------------------------------------------
	add_components_to_env (env, mod, pre, csets, cistate, 
			       ((comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc)),cmod)::xs, allcomps,instdims,impl) => env''

  rule	(* Not structural parameter. No Change.*)
	add_components_to_env2(env,mod,pre,csets,cistate,[(SCode.COMPONENT(n,final,repl,prot,
									  SCode.ATTR(ad,flow,acc,param,dir),t,m,bc),cmod)],instdims,impl) => env' &
	
	add_components_to_env(env',mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------------------------------------------------------------------------
	add_components_to_env (env, mod, pre, csets, cistate, 
			       ((comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc)),cmod)::xs, allcomps,instdims,impl) => env''
	
  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			       ((SCode.IMPORT(_),_))::xs, allcomps,instdims,impl) => env''

  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			       ((SCode.EXTENDS(_,_),_))::xs, allcomps,instdims,impl) => env''

  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			       ((SCode.CLASSDEF(_,_,_,_,_),_))::xs, allcomps,instdims,impl) => env''

(*  rule	add_components_to_env(env,mods,pre,csets,ci_state,
				 xs,allcomps,inst_dims,impl) => env' 
	-----------------
	add_components_to_env(env,mods,pre,csets,ci_state,
				 nocomp::xs,allcomps,inst_dims,impl) => env'*)
	
  rule	Debug.fprint("failtrace", "- add_components_to_env failed\n" ) 
	-------------------------------------
	add_components_to_env(_,_,_,_,_,comps,_,_,_) => fail
end


relation add_components_to_env2 : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			    (SCode.Element*Types.Mod) list, InstDims, bool)
	    => (Env) =

  rule	(*Debug.fprint ("decl", "got class \n") &*)

	(** PA: PROBLEM, Modifiers should be merged in this phase, but
	   since undeclared components can not be found (is done in this phase)
	   the modifiers can not be elaborated to get a variable binding.
	   Thus, we need to store the merged modifier for elaboration in the 
	   next stage. 
	   Save all modifiers in environment...
	   **)	

	(* Use type T_NOTYPE instead of as earier trying to instantiate, since instanitation might fail without having correct
	 modifications (e.g. when instanitating a partial class that must be redeclared through a modification)*)
	Env.extend_frame_v(env,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
	    prot,(Types.T_NOTYPE,NONE),Types.UNBOUND),SOME((comp,cmod)),false) => env' & 
	add_components_to_env2(env',mods,pre,csets,ci_state,xs,inst_dims,impl) 
	  => env'' 
	(*& Debug.fprint("decl", " updated env :") &
	Debug.fcall ("decl", Env.print_env, env'')*) 
	-----------------
	add_components_to_env2(env,mods,pre,csets,ci_state,
		     ((comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc),cmod))::xs,inst_dims,impl) => env''

(*  rule	add_components_to_env2(env,mods,pre,csets,ci_state,
				 xs,inst_dims,impl) => env' 
	-----------------
	add_components_to_env2(env,mods,pre,csets,ci_state,
				 nocomp::xs,inst_dims,impl) => env' *)


  axiom	add_components_to_env2(env,_,_,_,_,[],_,_) => env

  rule	Debug.fprint("failtrace", "- add_components_to_env2 failed\n") &
	Debug.fprint("failtrace", "\n\n") 
	--------------------
	add_components_to_env2(env,_,_,_,_,comps,_,_) => fail 
end

relation get_crefs_from_compdims: ((SCode.Element*Types.Mod) list) => Absyn.ComponentRef list =

  axiom	get_crefs_from_compdims([]) => []
	
  rule	get_cref_from_dim(arraydim) => crefs1 &
	(*Util.list_map(crefs1,Absyn.cref_get_first) => crefs1' &*)
	get_crefs_from_compdims(xs) => crefs2 &
	(*Util.list_map(crefs2,Absyn.cref_get_first) => crefs2' &*)
	list_append(crefs1,crefs2) => crefs
	------------------------------------
	get_crefs_from_compdims((SCode.COMPONENT(_,_,_,_,SCode.ATTR(arraydim,_,_,_,_),_,_,_),_)::xs)
	  => crefs

  rule	get_crefs_from_compdims(xs) => crefs
	------------------------------------
	get_crefs_from_compdims(_::xs) => crefs
end
(** This relation checks if a componentreferece is a member of a list of component references, disregarding subscripts.
 **)
relation member_crefs: (Absyn.ComponentRef, Absyn.ComponentRef list) => bool =

  rule	Absyn.cref_equal(cr,cr1) => true
	-------------------
	member_crefs(cr,cr1::xs) => true

  rule	Absyn.cref_equal(cr,cr1) => false &
	member_crefs(cr,xs) => res
	-------------------
	member_crefs(cr,cr1::xs) => res

  axiom	member_crefs(_,_) => false

end

(** relation: inst_element
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 ** Last two bools are implicit instanitation and implicit package instantiation
 **)

relation inst_element : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 (SCode.Element*Types.Mod), InstDims, bool, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** imports
	   ** imports are simply added to the current frame, so that the lookup rule can find them.
	   **)

  rule	Env.extend_frame_i(env,imp) => env'
	------------------------------------
	inst_element(env, mod, pre, csets, ci_state, (SCode.IMPORT(imp),_), instdims,_,_) 
	  => ([], env', csets, ci_state, [])
		 
	(* If a variable is declared multiple times, the first is used *)

  rule	Lookup.lookup_ident_local(env,n) => (_,NONE,true) 
	(*& Debug.fprint ("insttr", "variable already declared, using first def") *)
	-------------------------------------
	inst_element(env, mods, pre, csets, ci_state,
		     (SCode.COMPONENT(n,final,repl,prot,_,_,_,_),_),_,_,_)
	  => ([], env, csets, ci_state, []) 

  	  (* Illegal redeclarations *)

  rule	Lookup.lookup_ident_local(env,n) => (_,_,_) &
	Print.print_buf "# Trying to redeclare the class " & Print.print_buf n &
	Print.print_buf " as a variable\n" 
	------------------------
	inst_element(env, mods, pre, csets, ci_state,
		     (SCode.CLASSDEF(n,_,_,_,_),_),_,_,_)
 	  => fail 
	  
          (**  A new class definition
	   **
	   ** Put it in the current frame in the environment
	   **)

  rule	(* Redeclare of class definition, replaceable is true *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Types.REDECL(final, [(SCode.CLASSDEF(n2,f2,repl2,cls2,_),_)])) &
	(*Debug.fprintln ("insttr", "*--*Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "*--*All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &*)
	inst_class_decl(env, classmod, pre, csets, cls2, inst_dims, packimpl)
	  => (env', dae)
	-------------------------------------------------
	inst_element(env, mods, pre, csets, ci_state, 
		     (SCode.CLASSDEF(n,_,true,c,_),_), inst_dims, impl, packimpl)
	  => (dae, env', csets, ci_state, [])

  rule	(* Redeclare of class definition, replaceable is false *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Types.REDECL(final, [(SCode.CLASSDEF(n2,f2,repl2,cls2,_),_)])) &
	Print.print_buf "# Trying to redeclare class " & Print.print_buf n &
	Print.print_buf " but class not declared as replacable.\n" 
	-------------------------------------------------
	inst_element(env, mods, pre, csets, ci_state, 
		     (SCode.CLASSDEF(n,_,false,c,_),_),inst_dims,impl,packimpl)
	  => fail

  rule	(* Classdefinition without redeclaration *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) => classmod &
	(*Debug.fprintln ("insttr", "**Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "**All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &*)
	inst_class_decl(env,classmod,pre,csets,c,inst_dims,packimpl) 
	  => (env',dae)
	-------------------------------------------------------
	inst_element(env, mods, pre, csets, ci_state, 
		     (SCode.CLASSDEF(n,_,_,c,_),_),inst_dims,impl,packimpl)
	  => (dae, env', csets, ci_state, []) 
	  
	  (**  A component
	   **
	   ** This is the rule for instantiating a model component.  A
	   ** component can be a structured subcomponent or a variable,
	   ** parameter or constant.  All of these are treated in a
	   ** similar way.
	   **
	   ** Lookup the class name, apply modifications and add the
	   ** variable to the current frame in the environment. Then
	   ** instantiate the class with an extended prefix.
	   **)
	
  rule	(*Debug.fprint("insttr", "Instantiating component ") &
	Debug.fprint("insttr", n) & Debug.fprint("insttr", "\n") &*)
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &
	
	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation_ is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)
	(*Debug.fprint ("insttr", "Looking up class modifications") &*)
	Mod.lookup_modification_p(mods,t) => classmod &
	(*Debug.fcall ("insttr", Mod.print_mod, classmod) &*)
	(*Debug.fprint ("insttr", "\nLooking up component modifications") &*)
	Mod.lookup_comp_modification(mods,n) => mm &
	(*Debug.fcall ("insttr", Mod.print_mod, mm) & Debug.fprint ("insttr", "\n") &*)
	(* The types in the environment does not have correct Binding.
	   We must update those variables that is found in m into a new environment.*)
	let owncref = Absyn.CREF_IDENT(n,[]) &

	get_cref_from_mod(m) => crefs &
 	get_cref_from_dim(ad) => crefs2 &
		
	Util.list_flatten([crefs,crefs2]) => crefs' &
	remove_cref_from_crefs(crefs',owncref) => crefs'' &
	update_variables_in_env(mods,crefs'',env,ci_state,impl) => env2 &
	(*Debug.fprint("insttr", "updated variables in env\n") &*)
	(* Update the untyped modifiers to typed ones, and extract class *)
	(* and component modifiers again.*)
	Mod.update_mod(env2,pre,mods) => mods' &

	(*Debug.fprint("insttr", "updated modifiers to typed ones: ") &
	Debug.fcall("insttr", Mod.print_mod, mods') &
	Debug.fprint("insttr", "\n") & *)
	Mod.lookup_modification_p(mods',t) => classmod' &
	Mod.lookup_comp_modification(mods',n) => mm' &
		
	(*Debug.fprintln ("insttr", "Elaborating current modifications\n env") &
	Debug.fcall ("insttr", Env.print_env, env2)  &
	Debug.fprintln ("insttr", "\n\n") &*)
	Mod.elab_mod(env2,pre,m) => m' &
	(*Debug.fcall ("insttr", Mod.print_mod, m') &*)

	Mod.merge(classmod',mm',env2,pre) => mod &
 	Mod.merge(mod,m',env2,pre) => mod1 &
	Mod.merge(cmod,mod1,env2,pre) => mod1' &

	redeclare_type(mod1',comp,env2,pre,ci_state,impl) 
	  => (SCode.COMPONENT(n,final,repl,prot,
			      attr as SCode.ATTR(ad,flow,acc,param,dir),
			      t,m,bc),mod',env2') &
	
(*	Debug.fprint("insttr", "looking for type ") &
	Debug.fcall("insttr",Dump.print_path,t) &
	Debug.fprint("insttr"," \n") &*)
	
	get_derived_env(env,bc) => env' &
	Lookup.lookup_class(env',t,true) => (cl,cenv) & 
	
(*	Debug.fprintl ("insttr", ["found type for: ", n, "\n"]) &*)
	
	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm', vn) &

(*	Debug.fprintln ("insttr", "Protection checked") &*)

	Debug.fcall("myeqmod",Mod.print_mod, mod') & Debug.fprintln ("myeqmod", "\n") &
	Mod.mod_equation mod' => eq &

(*	Debug.fprintln ("insttr", "mod equation done, from mod:") &
	Debug.fcall("insttr",Mod.print_mod, mod') & Debug.fprintln ("insttr", "\n") &*)
	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)

	elab_arraydim(env2',owncref,ad,eq,impl,NONE) => dims &

(*	Debug.fprintln ("insttr", "arraydim elabed") &
	Debug.fprintln ("arraydim", "arraydim elabed :") &
	Debug.fcall("arraydim",print_dim2, dims) &*)

	(** Instantiate the component *)	
	(*Dump.select_string(impl,"IMPLICIT!!!\n","") => s &
	print s &*)

	inst_var(cenv,ci_state, mod', pre, csets, n, cl, attr, dims, [], inst_dims, impl)
	  => (dae, csets', ty) &
	  DAE.set_component_type(dae,t) => dae' &
	  
(*	Debug.fprintl ("insttr", ["instantiated: ", n, "\n"]) &*)

	(** The environment is extended (updated) with the new variable *)
	(** binding. *)

	make_binding (env2',attr,eq) => binding &
(*	Debug.fcall ("insttr", Types.print_binding, binding) &
	Debug.fcall ("insttr", print, "\n") &*)
	(* true in update_frame means the variable is now instantiated. *)
	Env.update_frame_v(env2',Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),true) => env' 


	(* Now we can also put the binding into the dae *)
	(** If the type is one of the simple, predifined types a *)
	(** simple variable declaration is added to the DAE. *)
					       
	(* & Debug.fprint("insttr","inst_element Component succeeded\n") *)
	-----------------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     (comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m,bc),cmod),inst_dims,impl,packimpl)
          => (dae', env',csets',ci_state,
	      [Types.VAR(n,Types.ATTR(flow,acc,param,dir), prot, ty, binding)])
	

	(** If the class lookup in the previous rule fails, this
	 ** rule catches the error and prints an error message about
	 ** the unknown class. 
	 **)

	(**  Failure *)
  rule	not Lookup.lookup_class(env,t,false) => (cl,cenv) &
	Absyn.path_string(t) => s &
	Print.print_buf "# unknown class '" & Print.print_buf s &
	Print.print_buf "' while instantiating " &
	Prefix.prefix_add(n,[],pre) => pre' &
	Prefix.print_prefix_str pre' => ns &
	Print.print_buf ns & Print.print_buf "\nenv:" &
	Env.print_env env
(*	Debug.fcall ("instdb", Env.print_env, env) *)
	--------------------------
	inst_element(env,_,pre,csets,ci_state,
		     (SCode.COMPONENT(n,final,repl,prot,_,t,_,_),_),_,_,_)
         => ([],env,csets,ci_state,[])

  rule	Debug.fprint("failtrace", "- inst_element failed\n") &
	Debug.fcall("failtrace",SCode.print_element, el) &
	Debug.fprint("failtrace", "\n") 
	-----------------------------------------------------------------
	inst_element(_,_,_,_,_,(el,_),_,_,_) => fail 

end	


relation get_derived_env: (Env.Env, Absyn.Path option) => Env.Env =

  axiom	get_derived_env(env,NONE) => env

  rule	Lookup.lookup_class(env,tp,true) => (_,env')
	---------------------------------------
	get_derived_env(env,SOME(tp)) => env'
end

relation remove_cref_from_crefs : (Absyn.ComponentRef list, Absyn.ComponentRef)
	  => Absyn.ComponentRef list =

  axiom	remove_cref_from_crefs ([],_) => []

  rule	let Absyn.CREF_IDENT(n1,[]) = cr1 &
	let Absyn.CREF_IDENT(n2,[]) = cr2 &
	n1 = n2 &
	remove_cref_from_crefs (rest, cr2) => rest'
	------------------------------------------
	remove_cref_from_crefs (cr1::rest, cr2) => rest'

  rule	remove_cref_from_crefs (rest, cr2) => rest'
	------------------------------------------
	remove_cref_from_crefs (cr1::rest, cr2) => cr1::rest'


end


(** relation: redeclare_type
 ** This relation takes a 'Mod' and an SCode.Element and if the modification contain
 ** a redeclare of that element, the type is changed and an updated element is returned
**)
relation redeclare_type: (Types.Mod, 
			  SCode.Element,
			  Env.Env,
			  Prefix.Prefix,
			  ClassInf.State,
			  bool (* Implicit instantation *)) 
	  => (SCode.Element,Types.Mod,Env.Env) =

  rule	n1=n2 &
	get_cref_from_mod(mod) => crefs &
	update_variables_in_env(Types.NOMOD (* m *),crefs,env,ci_state,impl) => env' &
	Mod.elab_mod(env',pre,mod) => m' &
	Mod.merge(rmod,m',env',pre) => m''
	--------------------------------
	redeclare_type ((m as Types.REDECL(_,((redecl as SCode.COMPONENT(n1,final,repl,prot,_,t,mod,bc)),rmod)::rest)),
			SCode.COMPONENT(n2,false,repl2,prot2,_,t2,_,_),env,pre,ci_state,impl) => (redecl,m'',env')

  rule	not n1=n2 &
	redeclare_type(Types.REDECL(redfin,rest),comp,env,pre,ci_state,impl) 
	  => (newcomp,mod,env')
	-------------
	redeclare_type (mod as Types.REDECL(redfin,((redecl as SCode.COMPONENT(n1,final,repl,prot,_,t,_,bc)),rmod)::rest),
			comp as SCode.COMPONENT(n2,false,repl2,prot2,_,t2,_,_),env,pre,ci_state,impl)
	  => (newcomp,mod,env')

  rule	redeclare_type(Types.REDECL(redfin,rest),comp,env,pre,ci_state,impl) 
	  => (newcomp,mod,env')
	  ----------------------------
	redeclare_type(Types.REDECL(redfin,_::rest),comp,env,pre,ci_state,impl) 
	  =>(newcomp,mod,env')

  axiom	redeclare_type(Types.REDECL(redfin,[]),comp,env,pre,ci_state,impl) => (comp,Types.NOMOD,env)

  axiom redeclare_type(mod,comp,env,pre,ci_state,impl) => (comp,mod,env)

  rule	Debug.fprint("failtrace", "- redeclare_type failed\n")
	------------------------------------------------------
	redeclare_type(_,_,_,_,_,_) => fail
end


(** relation: inst_var
 **
 ** A component element in a class may consist of several subcomponents
 ** or array elements.  This relation is used to instantiate a
 ** component, instantiating all subcomponents and array elements
 ** separately.
 ** P.A: Most of the implementation is moved to inst_var2. inst_var collects 
 ** dimensions for userdefined types, such that these can be correctly 
 ** handled by inst_var2 (using inst_array)
 **)

relation inst_var : (Env.Env,
		     ClassInf.State,
		     Types.Mod,
		     Prefix.Prefix,
		     Connect.Sets,
		     Ident,
		     SCode.Class,
		     SCode.Attributes,
		     DimExp list, 
		     int list,
		     InstDims,
		     bool)
	  => (DAE.Element list,Connect.Sets,Types.Type) =

  rule	(* Variables of userdefined type, e.g. Point p => Real p[3]; *)
	(* These must be handled separately since even if they do not appear to 
	 be an array, they can. Therefore we need to collect the full dimensionality
	 and call inst_var2 *)

	(* Collect dimensions *)
	get_usertype_dimensions(env,mod,pre,cl,inst_dims) => (dims' as _::_) &
	print_dims dims' &
	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dims',idxs,inst_dims,impl) 
	  => (dae,csets',ty') &
	  make_array_type(dims',ty') => ty
	--------------------------
	inst_var(env,ci_state,mod,pre,csets,n,cl as SCode.CLASS(id,_,_,SCode.R_TYPE,_),attr,dims,idxs,inst_dims,impl)
          => (dae,csets',ty)
	  
  rule	(* Generic case: fall trough *)
	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dims,idxs,inst_dims,impl) 
	  => (dae,csets',ty')
	----------------------
	inst_var(env,ci_state,mod,pre,csets,n,cl as SCode.CLASS(id,_,_,_,_),attr,dims,idxs,inst_dims,impl)
          => (dae,csets',ty')
end

relation inst_var2 : (Env.Env,
		      ClassInf.State,
		      Types.Mod,
		      Prefix.Prefix,
		      Connect.Sets,
		      Ident,
		      SCode.Class,
		      SCode.Attributes,
		      DimExp list, 
		      int list,
		      InstDims,
		      bool (* True = Implicit instantiation, should only be 
			    used when instantiating functions. Then we can 
			    not always find dimensional sizes. e.g. 
			    input Real x[:]; *)
		      )
	  => (DAE.Element list,Connect.Sets,Types.Type) =

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)


	(** LS: Removed the part which checks if modelica_output is true
	 ** and generates variables with initialization expression from the
	 ** modifications, because it cannot handle right hand side which is a
	 ** component (T_COMPLEX) anyway. This case is handled by the rule below
	 ** which generates correct equations according to the modification.
	 ** Separate code can parse the DAE and put the rhs of the latest
	 ** equation inside the variable declaration, and discard all the
	 ** equations.
	 **)

(** Rules for normal instantiation, will resolv dimensional sizes, etc. *)

  rule	(* Constants *)
	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,env',csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	(*inst_mod_equation(cr,ty,mod) => dae2 &*)
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e), 
		    inst_dims,NONE)
	  => dae3 & 
	list_append(dae1',dae3) => dae 
(*	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))*)
	--------------------------
	inst_var2(env,ci_state,mod as Types.MOD(_,_,SOME(Types.TYPED(e,_))),pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt as SCode.CONST,dir),
		 [],idxs,inst_dims,impl (*as false*))
          => (dae,csets',ty)

  rule	(* Parameters *)
	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,env',csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
(*	inst_mod_equation(cr,ty,mod) => dae2 &*)
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e),inst_dims,NONE)
	  => dae3 &  
	list_append(dae1',dae3) => dae
(*	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))*)
	--------------------------
	inst_var2(env,ci_state,mod as Types.MOD(_,_,SOME(Types.TYPED(e,_))),pre,csets,n,cl,SCode.ATTR(_,flow,acc, vt as SCode.PARAM,dir),
		 [],idxs,inst_dims,impl (*as false*))
          => (dae,csets',ty)

  rule	(* Scalar Variables *)
	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	(* This is where redeclare should be handled *)
	
        Prefix.print_prefix_str(pre') => prefix_str &
        
	Debug.fprintl ("insttr", ["instantiating var class: ", n," prefix ",prefix_str, "\n"]) &
	(*Debug.fcall ("envprint", Env.print_env, env) & *)
	
	inst_class(env,mod,pre',csets,cl,inst_dims,impl,INNER_CALL) 
	  => (dae1,_,csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	
 	(*& Debug.fcall ("insttr",DAE.dump2,DAE.DAE(dae'))*)
	
        Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	inst_mod_equation(cr,ty,mod) => dae2 &
        
        Util.list_map(idxs',int_string) => index_string &

        Debug.fprint ("insttr", "\n ******************\n ") &
        Debug.fprint ("insttr", "\n index_string ") &   Debug.fprintl ("insttr", index_string) &
        Debug.fprint ("insttr", "\n component ref ") &   Debug.fcall ("insttr", Exp.print_component_ref,cr) &
        Debug.fprint ("insttr", "\n ******************\n ") &
	Debug.fprint ("insttr", "\n ") &
	
        inst_start_binding(mod,ty,idxs') => start & 
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), NONE,
		    inst_dims, start) => dae3 &
	list_append(dae1',dae2) => daex &
	list_append(daex,dae3) => dae 
        (*	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))
	 & Debug.fprint("instvartr", "\nEnd of inst_var variables\n")*)
	--------------------------
	inst_var2(env,ci_state,mod,pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt,dir),
		  [],idxs,inst_dims,impl (*as false*))
          => (dae,csets',ty)


  rule	(* Array variables with binding in functions , e.g. input Real x[:]=Y *)
	inst_dim_exp_lst (dims,true) => dims' &
	Mod.mod_equation(mod) => SOME(Types.TYPED(e,p)) &  
	inst_class(env,mod,pre,csets,cl,inst_dims,true,INNER_CALL) 
	  => (_,_,_,ty,st) &
	make_array_type(dims,ty) => ty' &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	Types.elab_type(ty') => ty'' &
	Types.match_prop(e,Types.PROP(ty',false),p) => e' &
	make_dae_equation(Exp.CREF(cr,ty''),e',NON_INITIAL) => daeeq &
	dae_declare(cr,ty,attr,NONE,dims',NONE) => dae1 &
	list_append (dae1, [daeeq]) => dae
	-------------------------------
	inst_var2(env,ci_state as
		  ClassInf.FUNCTION(_),mod,pre,csets,n,cl,attr,dims as _::_,idxs,inst_dims,impl (*as false*))
          => (dae,csets,ty')

  rule	(* Array variables without binding in functions , e.g. input Real x[:] *)
	inst_class(env,mod,pre,csets,cl,inst_dims,true,INNER_CALL) 
	  => (_,_,_,ty,st) &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	(* Do all dimensions... *)
	inst_dim_exp_lst(dims,true) => dims' &
	dae_declare(cr,ty,attr,NONE,dims',NONE) => dae &
	make_array_type(dims,ty) => arrty 
	-------------------------------
	inst_var2(env,ci_state as ClassInf.FUNCTION(_),mod,pre,csets,n,cl,attr,dims as _::_,idxs,inst_dims,impl (*as false*))
          => (dae,csets,arrty)
	  

  rule	(* Array variables , e.g. Real x[3]*)
	inst_dim_exp (dim,impl) => dime &
	list_append(inst_dims,[dime]) => inst_dims' &
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),1,dim,dims,idxs,inst_dims',impl)
	  => (dae, csets', ty) &
	inst_dim_type dim => dimt &
	Types.lift_array(ty,dimt) => ty'
(*	& Debug.fprint("instvartr", "\nEnd of inst_var variables array non-function\n")*)
	-------------------------------
	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dim::dims,idxs,inst_dims,impl (*as false*))
          => (dae,csets',ty')

(* Rules for instantation of function variables (e.g. input and output 
  parameters and protected variables) *)

rule	Print.print_buf "!!! Error, implicit instantiation of variables\n"
	-------------------------------
	inst_var2(_,_,_,_,_,_,_,_,_,_,_,impl as true)
          => fail

  rule	Debug.fprint("failtrace", "- inst_var2 failed: ") & 
	Debug.fprint("failtrace",  n) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------
	inst_var2(_,_,_,_,_,n,_,_,_,_,_,_) => fail
	
end

(* Creates an array type from the element type given as argument and a list of 
 ** dimensional sizes*)
relation make_array_type: (DimExp list, Types.Type) 
	  => Types.Type =

  axiom	make_array_type ([],ty) => ty

  rule	make_array_type(xs,(ty,p)) => ty'
	-----------------------------
	make_array_type(DIMINT(i)::xs,(ty,p)) 
	  => ((Types.T_ARRAY(Types.DIM(SOME(i)),(ty')),p))

  rule	make_array_type(xs,(ty,p)) => ty'
	-------------------------
	make_array_type(DIMEXP(_,_)::xs,(ty,p)) 
	  => ((Types.T_ARRAY(Types.DIM(NONE),ty'),p))

  rule	Debug.fprint("failtrace", "- make_array_type failed\n")
	-------------------------------------------------------
	make_array_type(_,_) => fail
end

relation get_usertype_dimensions:(Env.Env, Types.Mod, Prefix.Prefix, SCode.Class,
				  InstDims)
	  => (DimExp list) =
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("Real",_,_,_,_),_) => []
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("Integer",_,_,_,_),_) => []
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("String",_,_,_,_),_) => []
  axiom	get_usertype_dimensions(_,_,_,SCode.CLASS("Boolean",_,_,_,_),_) => []
	
  rule	Lookup.lookup_class(env,cn,true) => (cl,cenv) &
	let owncref = Absyn.CREF_IDENT(id,[]) &
	get_option_arraydim(ad) => ad' &
	Mod.elab_mod(env,pre,mod) => mod' &
	Mod.merge(mods,mod',env,pre) => mods'' &
	Mod.mod_equation mods'' => eq &
	Mod.lookup_comp_modification(mods'',id) => mods''' &
	get_usertype_dimensions(cenv,mods''',pre,cl,dims) => dim1 &
	elab_arraydim(env,owncref,ad',eq,false,NONE) => dim2 &
	list_append(dim2,dim1) => res
	------------------------------
	get_usertype_dimensions(env,mods,pre,
				SCode.CLASS(id,_,_,SCode.R_TYPE,
					    SCode.DERIVED(cn,ad,mod)),dims) 
	  => res

  rule	Debug.fprint("failtrace", "- get_usertype_dimensions failed\n")
	--------------
	get_usertype_dimensions(_,_,_,_,_) => fail
end

relation get_cref_from_mod: SCode.Mod => Absyn.ComponentRef list =

  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_mod(SCode.REDECL(b,xs)) => res1 &
	get_cref_from_mod(m) => res2 &
	list_append(res1,res2) => res 
	(*&Util.list_map(res,Absyn.cref_get_first) => res'*)
	-----------------------------
	get_cref_from_mod(SCode.REDECL(b, SCode.COMPONENT(n,_,_,_,_,_,m,_)::xs)) 
	  => res
  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_mod(SCode.REDECL(b,xs)) => res
	-----------------------------
	get_cref_from_mod(SCode.REDECL(b, _::xs)) 
	  => res

  axiom	get_cref_from_mod(SCode.REDECL(b,[])) => []

  rule	(* Find in sub modifications e.g A(B=3) find B *)
	get_cref_from_submods(submods) => l1 &
	Absyn.get_cref_from_exp(e) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_mod(mod as SCode.MOD(_,submods,SOME(e))) => res

  rule	get_cref_from_submods(submods) => res
	-------------------------------------
	get_cref_from_mod(SCode.MOD(_,submods,NONE)) => res 
	
  axiom	get_cref_from_mod(_) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_mod failed\n")
	----------
	get_cref_from_mod(_) => fail
end

relation get_cref_from_dim: Absyn.ArrayDim => Absyn.ComponentRef list =
	
  rule	get_cref_from_dim(rest) => l1 &
	Absyn.get_cref_from_exp(exp) => l2 &
	list_append(l1,l2) => res
	----------------------
	get_cref_from_dim(Absyn.SUBSCRIPT(exp)::rest) => res
	
  rule	get_cref_from_dim(rest) => res
	------------------------------
	get_cref_from_dim(Absyn.NOSUB::rest) => res

  axiom	 get_cref_from_dim([]) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_dim failed\n")
	------------
	get_cref_from_dim(_) => fail
end

relation get_cref_from_submods: (SCode.SubMod list) => Absyn.ComponentRef list =

  rule	get_cref_from_mod(mod) => res1 &
	get_cref_from_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_submods(SCode.NAMEMOD(_,mod)::rest) => res
	   
	axiom get_cref_from_submods([]) => []
end

relation get_cref_from_elabed_mod: Types.Mod => Absyn.ComponentRef list =

  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_elabed_mod(Types.REDECL(b,xs)) => res1 &
	get_cref_from_mod(m) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_cref_from_elabed_mod(Types.REDECL(b, (SCode.COMPONENT(n,_,_,_,_,_,m,_),_)::xs)) 
	  => res
  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_elabed_mod(Types.REDECL(b,xs)) => res
	-----------------------------
	get_cref_from_elabed_mod(Types.REDECL(b, _::xs)) 
	  => res

  axiom	get_cref_from_elabed_mod(Types.REDECL(b,[])) => []

  rule	(* Find in sub modifications e.g A(B=3) find B *)
	get_cref_from_elabed_submods(submods) => l1 &
	get_cref_from_elabed_eqmod(e) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_elabed_mod(mod as Types.MOD(_,submods,SOME(e))) => res

  rule	get_cref_from_elabed_submods(submods) => res
	-------------------------------------
	get_cref_from_elabed_mod(Types.MOD(_,submods,NONE)) => res 
	
  axiom	get_cref_from_elabed_mod(_) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_mod failed\n")
	----------
	get_cref_from_elabed_mod(_) => fail
end

relation get_cref_from_elabed_eqmod: (Types.EqMod) => Absyn.ComponentRef list =
	
  rule	Absyn.get_cref_from_exp(exp) => res
	---------------------------------
	get_cref_from_elabed_eqmod(Types.UNTYPED(exp)) => res

	(* Otherwise, empty list, since typed expressions does not need to be updated *)
  axiom	get_cref_from_elabed_eqmod(_) => []
end

relation get_cref_from_elabed_submods: (Types.SubMod list) => Absyn.ComponentRef list =

  rule	get_cref_from_elabed_mod(mod) => res1 &
	get_cref_from_elabed_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_elabed_submods(Types.NAMEMOD(_,mod)::rest) => res
	   
  rule	get_cref_from_elabed_mod(mod) => res1 &
	get_cref_from_elabed_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_elabed_submods(Types.IDXMOD(_,mod)::rest) => res

	axiom get_cref_from_elabed_submods([]) => []
end

relation update_variables_in_env:(Types.Mod,
				  Absyn.ComponentRef list,
				  Env.Env, 
				  ClassInf.State, 
				  bool (* Implicit instantiation*)) 
	=> Env.Env =
	
  rule	update_variable_in_env(mods,cr,env,ci_state,impl) => env' &
	update_variables_in_env(mods,rest,env',ci_state,impl) => env''
	-------------------------------------------
	update_variables_in_env(mods,cr::rest,env,ci_state,impl) => env'' 

  rule (*	Debug.fprint("decl", "update_variables_in_env finished\n")*)
	---------------
	update_variables_in_env(_,[],env,ci_state,impl) => env
end

relation update_variable_in_env: (Types.Mod,Absyn.ComponentRef, Env.Env, ClassInf.State, bool) 
	  => Env.Env =
	
  rule	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME((SCode.COMPONENT(n,final,repl,prot,
				   attr as SCode.ATTR(ad,flow,acc,param,dir),
				   t,m,bc),cmod)),_) &

	Lookup.lookup_class(env,t,false) => (cl,cenv) & 

	get_cref_from_mod(m) => crefs &
 	get_cref_from_dim(ad) => crefs2 &
	list_append(crefs,crefs2) => crefs' &
	remove_cref_from_crefs(crefs',cref) => crefs'' &
	update_variables_in_env(mods,crefs'',env,ci_state,impl) => env2 &
	(* Prefix does not matter, since we only update types in env, and does
	   not make any dae elements, etc.. *)
	Mod.elab_mod(env2,Prefix.NOPRE,m) => m' &

	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.merge(classmod,mm,env2,Prefix.NOPRE) => mod &
	Mod.merge(mod,m',env2,Prefix.NOPRE) => mod' &
	Mod.merge(cmod,mod',env2,Prefix.NOPRE) => mod'' &

	Mod.update_mod(env2,Prefix.NOPRE,mod'') => mod''' &

	Mod.mod_equation mod''' => eq &
	
	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	elab_arraydim(env2,cref,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(cenv,ci_state, mod''', Prefix.NOPRE, [], n, cl, attr,
		 dims, [], [], false)
	  => (dae1, csets', ty) &
	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env2,attr,eq) => binding &
	Env.update_frame_v(env2,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),false) => env' 
(*	& Debug.fprint("insttr","Updated variable ") &
	Debug.fprint("insttr", id) &
	Debug.fprint("insttr"," in env.\n ") *)
	----------------------------------
	update_variable_in_env (mods,cref as Absyn.CREF_IDENT(id,subscr),env,ci_state, impl) => env'

  rule	Lookup.lookup_ident(env,id) => (ty,NONE,_) 
	----------------------------------
	update_variable_in_env (mods,cref as Absyn.CREF_IDENT(id,subscr),env,ci_state, impl) => env
	
  rule	(* If first part of ident is a class, e.g StateSelect.None, nothing to update *)
	Lookup.lookup_class(env,Absyn.IDENT(id),false) => (cl,cenv)
	--------------------------------------------------------------------
	update_variable_in_env(mods, Absyn.CREF_QUAL(id,_,_),env,ci_state, impl) => env

  rule	(* Nothing to update. *)
	Lookup.lookup_ident(env,id) => (ty,NONE,_) 
	----------------------------------
	update_variable_in_env (mods, Absyn.CREF_QUAL(id,_,_),env,ci_state,impl) => env

  rule	(* For qualified names, e.g. a.b.c, instanitate component a *)
	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME((SCode.COMPONENT(n,final,repl,prot,
				   attr as SCode.ATTR(ad,flow,acc,param,dir),
				   t,m,_),cmod)),_) &
	Lookup.lookup_class(env,t,false) => (cl,cenv) & 

	get_cref_from_mod(m) => crefs &
 	update_variables_in_env(mods,crefs,env,ci_state,impl) => env2' &
	
	get_cref_from_dim(ad) => crefs2 &
	update_variables_in_env(mods,crefs2,env2',ci_state,impl) => env2 &
	(* Prefix does not matter, since we only update types in env, and does
	   not make any dae elements, etc.. *)
	Mod.elab_mod(env2,Prefix.NOPRE,m) => m' &

	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.merge(classmod,mm,env2,Prefix.NOPRE) => mod &
	Mod.merge(mod,m',env2,Prefix.NOPRE) => mod' &
	Mod.merge(cmod,mod',env2,Prefix.NOPRE) => mod'' &

	Mod.update_mod(env2,Prefix.NOPRE,mod'') => mod''' &
	Mod.mod_equation mod''' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	let owncref = Absyn.CREF_IDENT(n,[]) &
	elab_arraydim(env2,owncref,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(cenv, ci_state, mod''', Prefix.NOPRE, [], n, cl, attr,
		 dims, [], [], false)
	  => (dae1, csets', ty) &

	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env2,attr,eq) => binding &

	Env.update_frame_v(env2,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),false) => env' 
	------------
	update_variable_in_env(mods, Absyn.CREF_QUAL(id,_,_),env,ci_state, impl) 
	  => env'

  rule	Debug.fprint("failtrace", "-update_variable_in_env failed, ident = ") &
	Debug.fcall("failtrace", Dump.print_component_ref, cref) &
	Debug.fprint("failtrace","\n mods:") &
	Debug.fcall("failtrace", Mod.print_mod , mod) &
	Debug.fprint("failtrace", "\n   env:   " ) &
	Debug.fcall("failtrace", Env.print_env , env) &
	Debug.fprint("failtrace","\n") 
	---------------------------
	update_variable_in_env(mod,cref,env,ci_state,impl) => env
end

relation inst_dim_exp_lst : (DimExp list, bool) => Exp.Subscript list =
  axiom	inst_dim_exp_lst ([],_) => []

  rule	inst_dim_exp_lst(xs,b) => res &
	inst_dim_exp(x,b) => r 
	----------------
	inst_dim_exp_lst(x::xs,b) => r::res
end

relation inst_dim_exp : (DimExp, bool) => Exp.Subscript =

  rule	Print.print_buf "# Error, can not determine size of array.\n"
	-------------------------------------------
	inst_dim_exp (DIMEXP(Exp.WHOLEDIM,_),false) => fail

  rule	Print.print_buf "# Error, can not determine size of array. SLICE\n"
	-------------------------------------------
	inst_dim_exp (DIMEXP(Exp.SLICE(_),_),false) => fail

  axiom	inst_dim_exp (DIMEXP(e as Exp.WHOLEDIM,_),true) => e
  axiom	inst_dim_exp (DIMINT(i),_) => Exp.INDEX(Exp.ICONST(i))

  axiom	inst_dim_exp (DIMEXP(e as Exp.INDEX(_),_),_) => e

end

relation inst_dim_type : DimExp => int option =

  axiom	inst_dim_type DIMINT(i) => SOME(i)
  axiom	inst_dim_type DIMEXP(_,_) => NONE

end

(** relation: fix_direction
 ** Updates the direction of a DAE element list.
 ** If a component has prefix input, all variables of the component 
 ** should be input.
 ** Similarly if a component has prefix output.
 ** If the component is bidirectional, the original direction is kept
 **)
relation fix_direction : (DAE.Element list, Absyn.Direction)
	  => DAE.Element list =
	  (* Component that is bidirectional does not change direction on subcomponents  *)
  axiom	fix_direction(lst,Absyn.BIDIR) => lst 
	
  axiom	fix_direction ([],_) => []

  rule	(* bidirectional variables are changed to input or output if component has such
	 * prefix.
	 *)
	absyn_dir_to_dae_dir dir => dir' &
	fix_direction (r,dir) => r'
	-----------------------------
	fix_direction (DAE.VAR(cr,vk,DAE.BIDIR,t,e,id,start,flow,class)::r,dir) 
	  => DAE.VAR(cr,vk,dir',t,e,id,start,flow,class)::r'

  rule	(* Error, component declared as input or output  when containing variable that
	 * has prefix input. 
	 *)
	Print.print_buf "#Error, component declared as " & Dump.direction_symbol dir => str &
	Print.print_buf str & Print.print_buf " when having the variable " & 
	Exp.print_component_ref cr & Print.print_buf " declared as input\n"
 	-----------------------------
	fix_direction (DAE.VAR(cr,vk,DAE.INPUT,t,e,id,start,flow,class)::r,dir) 
	  => fail


  rule	(* Error, component declared as input or output  when containing variable that
	 * has prefix output 
	 *)
	Print.print_buf "#Error, component declared as " & Dump.direction_symbol dir => str &
	Print.print_buf str & Print.print_buf " when having the variable " & 
	Exp.print_component_ref cr & Print.print_buf " declared as input\n"
 	-----------------------------
	fix_direction (DAE.VAR(cr,vk,DAE.OUTPUT,t,e,id,start,flow,class)::r,dir) 
	  => fail

  rule	fix_direction(lst,dir) => lst' &
 	fix_direction(r,dir) => r'
 	-------------------------------
 	fix_direction(DAE.COMP(id,DAE.DAE(lst))::r,dir) 
 	  => DAE.COMP(id,DAE.DAE(lst'))::r'

  rule	fix_direction(r,dir) => r'
	---------------------------
	fix_direction (x::r,dir) => x::r'

end

relation absyn_dir_to_dae_dir : Absyn.Direction => DAE.VarDirection =
	
  axiom	absyn_dir_to_dae_dir Absyn.INPUT  => DAE.INPUT
  axiom	absyn_dir_to_dae_dir Absyn.OUTPUT => DAE.OUTPUT
  axiom	absyn_dir_to_dae_dir Absyn.BIDIR  => DAE.BIDIR

end

(** relation: inst_array
 **
 ** When an array is instantiated by `inst_var', this relation is used
 ** to go through all the array elements and instantiate each array
 ** element separately.
 **)

relation inst_array : (Env.Env,
		       ClassInf.State,
		       Types.Mod,
		       Prefix.Prefix,
		       Connect.Sets,
		       Ident,
		       (SCode.Class*SCode.Attributes),
		       int,
		       DimExp,
		       DimExp list,
		       int list,
		       InstDims,
		       bool
		       )
	  => (DAE.Element list, Connect.Sets, Types.Type) =
	  
  rule	(* If is a function var.*)
	Mod.mod_equation(mod) => SOME(Types.TYPED(e,p)) &  (* Which has an 
							  expression binding *)
	inst_class(env,mod,pre,csets,cl,inst_dims,true,INNER_CALL) 
	  => (_,_,_,ty,st) &
	(* Check their types... *)
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	Types.elab_type(ty) => ty' &
	Types.match_prop(e,Types.PROP(ty,false),p) => e' &
	make_dae_equation(Exp.CREF(cr,ty'),e',NON_INITIAL) => dae 
	---------------------------------------------------
	inst_array(env,ci_state as ClassInf.FUNCTION(_),mod,pre,csets,n,(cl,attr),i,DIMEXP(_,_),dims,idxs,inst_dims,impl)
	  => ([dae],[],ty)

  rule	inst_var2(env,ci_state,mod,pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl)
	  => (dae,csets,ty)
	-----------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,DIMEXP(_,_),dims,idxs,inst_dims,impl)
	  => (dae,csets,ty)

  rule	int_gt(i,stop) => true
	----------------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl)
	  => ([], csets, (Types.T_NOTYPE,NONE))

  rule	(* Modifiers of arrays that are functioncall, eg. Real x[:]=foo(...) *)
	(* Should only generate -one- functioncall *)
	Mod.mod_equation(mod) => SOME(Types.TYPED(e,p)) &
	Exp.contain_functioncall(e) => true &
	inst_var2(env,ci_state,Types.NOMOD,pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl)
	  => (dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,ci_state,Types.NOMOD,pre,csets',n,(cl,attr),i',DIMINT(stop),dims,idxs,inst_dims,impl)
	  => (dae2, csets'',arrty) &
	(* Make the equation containing the functioncall *)
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => cr &
	Types.elab_type(arrty) => arrty' &
	make_dae_equation(Exp.CREF(cr,arrty'),e,NON_INITIAL) => dae3 &
	Util.list_flatten([dae1,dae2,[dae3]]) => dae
	-----------------------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl)
          => (dae,csets',ty)

  rule	Mod.lookup_idx_modification(mod,i) => mod' &
	inst_var2(env,ci_state,mod',pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl)
	  => (dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,ci_state,mod,pre,csets',n,(cl,attr),i',DIMINT(stop),dims,idxs,inst_dims,impl)
	  => (dae2, csets'',_) &

	list_append(dae1,dae2) => dae
	-----------------------------
	inst_array(env,ci_state,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl)
          => (dae,csets'',ty)

  rule	Debug.fprint("failtrace", "- inst_array failed: ") &
	Debug.fcall("failtrace", Print.print_buf,  n) &
	Debug.fprint("failtrace", "\n") 
	--------------------------------------------------
	inst_array(_,_,_,_,_,n,(_,_),_,_,_,_,_,_) => fail
	
end

(** relation: elab_arraydim
 **
 ** This relations examines both an `Absyn.ArrayDim' and an `Types.EqMod
 ** option' argument to find out the dimensions af a component.  If
 ** no equation modifications is given, only the declared dimension is
 ** used.
 **
 ** When the size of a dimension in the type is undefined, the
 ** corresponding size in the type of the modification is used.
 **
 ** All this is accomplished by examining the two arguments separately
 ** and then using `complete_arraydime' or `compatible_arraydim' to
 ** check that that the dimension sizes are compatible and complete.
 **)

relation elab_arraydim : (Env.Env, Absyn.ComponentRef, Absyn.ArrayDim, Types.EqMod option, bool,Interactive.InteractiveSymbolTable option)
	  => DimExp list =

  rule	elab_arraydim_decl(env,cref,ad,impl,cf) => dim &
	complete_arraydim(dim) => dim'
	------------------------------
	elab_arraydim(env,cref,ad,NONE,impl,cf) => dim'

  rule	elab_arraydim_decl(env,cref,ad,impl,cf) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3 
	---------------------------------
	elab_arraydim(env,cref,ad,SOME(Types.TYPED(e,Types.PROP(t,c))),impl,cf) => dim3

  rule	Static.elab_exp(env,e,impl,cf) => (e',Types.PROP(t,c),_) &
	elab_arraydim_decl(env,cref,ad,impl,cf) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3 
	---------------------------------
	elab_arraydim(env,cref,ad,SOME(Types.UNTYPED(e)),impl,cf) => dim3


  rule	elab_arraydim_decl(env,cref,ad,impl,cf) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	not compatible_arraydim(dim1,dim2) => dim3 &
	Print.print_buf "# Array dimension mismatch\n" &
	Print.print_buf "    expression " & Exp.print_exp e &
	Print.print_buf " has type " & Types.print_type t & Print.print_buf "\n" &
	Print.print_buf "    expected array dimensions [" &
	print_dim dim1 & Print.print_buf "]\n"
	---------------------------------
	elab_arraydim(env,cref,ad,SOME(Types.TYPED(e,Types.PROP(t,c))),impl,cf) => fail


  rule	Debug.fprint("failtrace", "- elab_arraydim failed\n cref:") &
	Debug.fcall("failtrace", Dump.print_component_ref, cref) &
	Debug.fprint("failtrace", " dim: " )  &
	Debug.fcall("failtrace", Dump.print_arraydim, ad) &
	Debug.fprint("failtrace", "\n" ) 
	-------------------------------------
	elab_arraydim(_,cref,ad,_,_,_) => fail

end

(** relation: print_dim
 **
 ** This relation prints array dimensions.  The code is not included
 ** in the report.
 **)

(*!ignorecode*)
relation print_dim : (DimExp option) list => () =

  rule	Print.print_buf ":"
	---------
	print_dim [NONE]

  rule	int_string x => s & Print.print_buf s
	---------------------------
	print_dim [SOME(DIMINT(x))]

  rule	Exp.print_subscript x
	---------------------------
	print_dim [SOME(DIMEXP(x,_))]

  rule	Print.print_buf ":," & print_dim xs
	-------------------------
	print_dim NONE::xs

  rule	int_string x => s & Print.print_buf s & Print.print_buf "," & print_dim xs
	------------------------------------------------
	print_dim SOME(DIMINT(x))::xs

rule	Exp.print_subscript x & Print.print_buf "," & print_dim xs
	------------------------------------------------
	print_dim SOME(DIMEXP(x,_))::xs

end

relation print_dim2 : DimExp  list => () =

  rule	int_string x => s & Print.print_buf s
	---------------------------
	print_dim2 [DIMINT(x)]

  rule	Exp.print_subscript x
	---------------------------
	print_dim2 [DIMEXP(x,_)]

  rule	int_string x => s & Print.print_buf s & Print.print_buf "," & print_dim2 xs
	------------------------------------------------
	print_dim2 DIMINT(x)::xs

rule	Exp.print_subscript x & Print.print_buf "," & print_dim2 xs
	------------------------------------------------
	print_dim2 DIMEXP(x,_)::xs
  axiom	print_dim2[] => ()

end
(*!includecode*)

(** relation: elab_arraydim_decl
 **
 ** Given an `Absyn.ArrayDim', this relation evaluates all dimension
 ** size specifications, creating a list of (optional) integers.  When
 ** the array dimension size is specified as `:', the result will
 ** contain `NONE'.
 **)

relation elab_arraydim_decl : (Env.Env, Absyn.ComponentRef, Absyn.ArrayDim, bool, Interactive.InteractiveSymbolTable option)
	    => (DimExp option) list =

  axiom	elab_arraydim_decl(_,_,[],_,_) => []

  rule	(*Print.print_buf "NOSUB in elab_arraydim_decl\n" & *)
	elab_arraydim_decl(env,cref,ds,impl,cf) => l 	
	-------------------------------
	elab_arraydim_decl(env,cref,Absyn.NOSUB::ds,impl,cf) => NONE::l

  rule	(* For functions, this can occur: Real x[:,size(x,1)] ,i.e. referencing 
	 the variable itself but a different dimension.*)
	Absyn.cref_equal(cref,cr) => true &
	elab_arraydim_decl(env,cref,ds,impl,cf) => l 	
	-------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(Absyn.CALL(Absyn.CREF_IDENT("size",_),Absyn.FUNCTIONARGS([Absyn.CREF(cr),_],_)))::ds,impl,cf) => NONE::l

  rule	Static.elab_exp(env, d,impl,st)
	    => (e,Types.PROP((Types.T_INTEGER(_),_),_),_) &  
	    (* _ Was true, but structural parameters must be given 
	       the numerical value in order to instantiate successfully.
	       PA: This is true for normal models, e.g. model test Real x[n]; end test;
	       It is NOT true for functions, or other implicit instantiated models. 
	     *)
	Ceval.ceval(env,e,impl,st,NONE) => (Values.INTEGER(i),_) &
 	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl,st) => SOME(DIMINT(i))::l

  rule	Static.elab_exp(env, d,impl,st)
	    => (e,Types.PROP((Types.T_INTEGER(_),_),true),_) &  
	    (* _ Was true, but structural parameters must be given 
	       the numerical value in order to instantiate successfully.
	       PA: This is true for normal models, e.g. model test Real x[n]; end test;
	       It is NOT true for functions, or other implicit instantiated models. 
	     *)
	Ceval.ceval(env,e,impl,st,NONE) => (Values.INTEGER(i),_) &
 	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl as true,st) => SOME(DIMINT(i))::l

  rule	Static.elab_exp(env, d,impl,st) => (e,Types.PROP((Types.T_INTEGER(_),_),false),_) &
	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl,st) 
	  => SOME(DIMEXP(Exp.INDEX(e),NONE))::l 

  rule	(* Size(x,1) in e.g. functions => Unknown dimension *)
	Static.elab_exp(env,d,impl,st)
	  => (e as Exp.SIZE(_,_),Types.PROP(t,_),_) &
	elab_arraydim_decl(env,cref,ds,impl,st) => l
	-------------------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl,st) 
	  => SOME(DIMEXP(Exp.INDEX(e),NONE))::l

  rule	Static.elab_exp(env,d,impl,st)
	  => (e,Types.PROP(t,_),_) &
	Print.print_buf "# Array dimensions must be integer\n" &
	Print.print_buf "    expression: " & Exp.print_exp e &
 	Print.print_buf " (" & Types.print_type t & Print.print_buf ")\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,cref,Absyn.SUBSCRIPT(d)::ds,impl,st) => fail

  rule	print "elab_arraydim_decl failed\n" &
	Debug.fprint("failtrace", "- elab_arraydim_decl failed\n")
	-------------------------------------
	elab_arraydim_decl(_,_,_,_,_) => fail     
end

(** relation: complete_arraydim
 **
 ** This relation converts a list of optional integers to a list of
 ** integers.  If one element of the list is `NONE', this relation
 ** will fail.
 **
 ** This is used to check that an array specification contain fully
 ** specified array dimension sizes.
 **)

relation complete_arraydim : (DimExp option) list => DimExp list =

  axiom	complete_arraydim [] => []

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim SOME(x)::xs => x::xs'

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim NONE::xs => DIMEXP(Exp.WHOLEDIM,NONE)::xs'

end

(** relation: compatible_arraydim
 **
 ** Given two, possibly incomplete, array dimension size
 ** specifications as list of optional integers, this relation checks
 ** whether they are compatible.  Being compatible means that they
 ** have the same number of dimension, and for every dimension at
 ** least one of the lists specifies its size.  If both lists specify
 ** a dimension size, they have to specify the same size.
 **)

relation compatible_arraydim : ((DimExp option) list,(DimExp option) list)
	  => DimExp list =

  axiom	compatible_arraydim([],[]) => []

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(SOME(x)::xs,NONE::ys) => x::l

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(NONE::xs,SOME(y)::ys) => y::l

  rule	x = y &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMINT(y))::ys) 
	  => DIMINT(x)::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(x)),NONE),DIMEXP(y,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMEXP(y,e))::ys)
	  => de::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(y)),NONE),DIMEXP(x,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e))::xs,SOME(DIMINT(y))::ys) 
	  => de::l

  rule	arraydim_condition(DIMEXP(x,e1),DIMEXP(y,e2))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e1))::xs,SOME(DIMEXP(y,e2))::ys)
	  => de::l


  rule	compatible_arraydim(xs,ys) => l
	--------------------------------
	compatible_arraydim (NONE::xs,NONE::ys) 
	  => DIMEXP(Exp.WHOLEDIM,NONE)::l

  rule	Print.print_buf "-compatible_arraydim failed\n" &
	Debug.fprint("failtrace", "- compatible_arraydim failed\n")
	--------------------------------------
	compatible_arraydim (_,_) => fail

end

relation arraydim_condition : (DimExp, DimExp) => DimExp =
	
  axiom arraydim_condition (de,_) => de

end
(** relation: elab_arraydim_type
 **
 ** Find out the dimension sizes of a type.  The second argument is
 ** used to know how many dimensions should be extracted from the
 ** type.
 **)

relation elab_arraydim_type : (Types.Type, Absyn.ArrayDim)
	  => DimExp option list =

  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type((Types.T_ARRAY(Types.DIM(NONE),t),_), _::ad) 
	  => NONE::l
	
  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type((Types.T_ARRAY(Types.DIM(SOME(i)),t),_), _::ad) 
	  => SOME(DIMINT(i))::l
	
 axiom elab_arraydim_type(_,[]) => []

 (* PR, for debugging *)
  rule 	Debug.fprint("failtrace", "Undefined!") &
	Debug.fprint("failtrace", " The type detected: ") &
  	Debug.fcall("failtrace", Types.print_type, t)
       --------------------
	elab_arraydim_type(t,_::ad) => fail
end

(** relation: inst_class_decl
 **
 ** The class definition is instantiated although no variable
 ** is declared with it.  After instantiating it, it is
 ** checked to see if it can be used as a package, and if it
 ** can, then it is added as a variable under the same name as
 ** the class.  This makes it possible to use a unified lookup
 ** mechanism.  And since packages only can contain constants
 ** and class definition, instantiating a package does not do
 ** anything else.
 **)

relation inst_class_decl : (Env.Env, Types.Mod, Prefix.Prefix,
			    Connect.Sets, SCode.Class,InstDims, bool)
	  => (Env.Env, DAE.Element list) =

  rule	(*Debug.fprint("insttr","+\tinst_class_decl called\n") &*)
	Env.extend_frame_c(env,c) => env' &
(*	Debug.fprint("insttr","+\textended frame\n") &*)
	implicit_instantiation(env',Types.NOMOD,pre,csets,c,inst_dims,packimpl) 
	  => (env'',dae) 
(*	Debug.fprint("insttr","+\timplicit instantiation of ") &
	Debug.fprint("insttr",n) & Debug.fprint("insttr", " finshed\n\n") *)
	----------------------------------
	inst_class_decl(env,mod,pre,csets,c as SCode.CLASS(n,_,_,restr,_),inst_dims,packimpl)
	  => (env'', dae)

  rule	Debug.fprint("failtrace",  "- inst_class_decl failed\n") 
	----------------------------------
	inst_class_decl(env,_,_,_,_,_,_) => fail
end

(** relation implicit_instantiation
 ** This relation adds types to the environment.
 **
 ** If a class definition is a function or a package or an enumeration , 
 ** it is implicitly instantiated and added as a type binding under the
 ** same name as the class name.
 **)

relation implicit_instantiation : (Env.Env, Types.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims, bool)
	  => (Env.Env, DAE.Element list) =

(* LS:This rule extends the frame with the package as a type, but
inst_class also extends the frame with the package as a class. Is this
correct?
* PA: No, since we have now a special relation for looking up variables, first checking 
* the types and thereafter checking classes.
*)
(* Removed
  rule	Prefix.prefix_add(n,[],pre) => pre' &
	Debug.fprint ("insttr","implicit_instantiation called.\n") &
 	print "implicit_instantiation  of " & print n & print " called.\n" &
 	inst_class(env,mod,pre',csets,c,inst_dims,true,INNER_CALL) 
 	 => (dae, _, csets', ty, st) &
 	Debug.fprint ("insttr","implicit_instantiation inst class done.\n") &
 	print "implicit_instantiation of " & print n & print " class done.\n" &
 	Env.extend_frame_t(env, n, ty) => env' &
	Debug.fprintl ("insttr", ["implicit_instantiation done:", n, "\n"])
 	--------------------------------------
 	implicit_instantiation(env, mod, pre, csets,
 			       c as SCode.CLASS(n,_,_,SCode.R_PACKAGE,_),
 			       inst_dims)
 	  => (env', dae)
 Removed *)

(* LS: changed from returning empty dae to returning a DAE.FUNCTION *)
(* LS: removed prefix because function elements shouldn't have
   one. They will contain the elements locally *)

  rule 	inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
 	  => (dae, _, csets', ty, st) &
 	Env.extend_frame_t(env, n, ty) => env' &
         package_prefix (env, Absyn.IDENT(n)) => fpath
 	--------------------------------------
 	implicit_instantiation(env, mod, pre, csets,
 			       c as SCode.CLASS(n,_,_,SCode.R_FUNCTION,_),
 			       inst_dims, false)
 	  => (env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])


   rule inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
 	  => (dae, _, csets', ty, st) &
 	
 	Env.extend_frame_t(env, n, ty) => env'	&
	package_prefix (env, Absyn.IDENT(n)) => fpath &
	let prot = false & 
	inst_classdef (env, mod, pre, csets, ClassInf.UNKNOWN(n), parts, restr, 
		       prot, inst_dims, true, false) 
	  =>(_, tempenv,_,_,_) &

	inst_ext_decl(tempenv, n, parts) => extdecl
	--------------------------------------
	implicit_instantiation(env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_, restr as SCode.R_EXT_FUNCTION, 
			       parts as SCode.PARTS(els,_,_,_,_,_)),
			       inst_dims, false)
	  => (env', [DAE.EXTFUNCTION(fpath,DAE.DAE(dae), ty, extdecl)])


  rule	(*let ty = Types.T_ENUMERATION(l) &
	Env.extend_frame_t(env,n,ty) => env' & *)
	inst_enumeration(n,l) => enumclass &
	Env.extend_frame_c(env,enumclass) => env'' 
	-----------------------------------
	implicit_instantiation(env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_TYPE, SCode.ENUMERATION(l)),inst_dims,_)
	=> (env'', [])

  axiom	implicit_instantiation(env, mod, pre, csets, c, _, _) => (env, [])
	
  rule	Debug.fprint("failtrace", "- implicit_instantiation failed\n")
	----------------
	implicit_instantiation(_,_,_,_,_,_,_) => fail
end


relation package_prefix : (Env.Env, Absyn.Path) => Absyn.Path =

  rule	Env.get_env_path env => NONE
	----------------------------
	package_prefix (env,path) => path

  rule	Env.get_env_path env => SOME(path') &
	Absyn.join_paths(path',path) => path''
	--------------------------------------
	package_prefix (env,path) => path''

end


relation implicit_function_instantiation : (Env.Env, Types.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims, bool)
	  => (Env.Env, DAE.Element list) =

rule	(*Prefix.prefix_add(n,[],pre) => pre' &*)
	inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
	  => (dae, _, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
        package_prefix (env, Absyn.IDENT(n)) => fpath
	--------------------------------------
	implicit_function_instantiation(env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_FUNCTION,_),
			       inst_dims, false)
	  => (env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])


  rule	(* External functions should also have their type in env, but no dae! *)
	inst_class(env, mod, pre, csets, c, inst_dims, true,INNER_CALL) 
	  => (dae, _, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env'	&
        package_prefix (env, Absyn.IDENT(n)) => fpath &
        let prot = false & (* how to get this? *)
 	inst_classdef (env', mod, pre, csets, ClassInf.FUNCTION(n), parts, 
		       restr, prot, inst_dims, true, false) 
	  =>(_, tempenv,_,_,_) &
	inst_ext_decl(tempenv, n, parts) => extdecl 
	--------------------------------------
	implicit_function_instantiation(env, mod, pre, csets,
		       c as SCode.CLASS(n,_,_, restr as SCode.R_EXT_FUNCTION, 
			       parts as SCode.PARTS(els,_,_,_,_,_)),
			       inst_dims, false)
	  => (env', [DAE.EXTFUNCTION(fpath,DAE.DAE(dae), ty, extdecl)])
				
  rule        (* Overloaded functions *)
        inst_overloaded_functions(env,n,funcnames) => (env',daefuncs)
	-----------------------------
         implicit_function_instantiation(env,mod,pre,csets,
                              c as SCode.CLASS(n,_,_, restr as SCode.R_FUNCTION
,
                              SCode.OVERLOAD(funcnames)),
                              inst_dims, false)
         => (env', daefuncs)

  rule	(*Debug.fprint("failtrace", "#-- implicit_function_instantiation failed\n")*)
	------------------------------------------------------------------------
	implicit_function_instantiation(_,_,_,_,_,_,_) => fail 

end

(** relation: inst_overloaded_functions
 ** This relation instantiates the functions in the overload list of a overloading
 ** function definition and register the function types using the overloaded name.
 ** It also creates dae elements for the functions 
**)
relation inst_overloaded_functions: (Env.Env, Absyn.Ident, Absyn.Path list)
	=> (Env.Env, DAE.Element list) =

  axiom	inst_overloaded_functions(env,_,[]) => (env, [])

  rule	(* Instantiate each function, add its FQ name to the type, needed when deoverloading *)
	Lookup.lookup_class(env,fn,true) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_FUNCTION,_),cenv) &
	inst_class(cenv, Types.NOMOD, Prefix.NOPRE, [], c, [], true,INNER_CALL) 
	  => (dae, _, _, (Types.T_FUNCTION(args,tp),_), st) &
        package_prefix (env, Absyn.IDENT(overloadname)) => fpath &
	package_prefix (cenv, Absyn.IDENT(id)) => ovlfpath &
	let ty = ((Types.T_FUNCTION(args,tp),SOME(ovlfpath))) &
	Env.extend_frame_t(env, overloadname, ty) => env' &
	inst_overloaded_functions(env',overloadname,fns) => (env'', dae1) 	
	-----------------------------------------------------------------
	inst_overloaded_functions(env,overloadname,fn::fns) 
	  => (env'', DAE.FUNCTION(fpath, DAE.DAE(dae), ty)::dae1 )

  rule	Debug.fprint("failtrace", "inst_overloaded_functions failed\n" )
	--------------------------
	inst_overloaded_functions(env,_,_) => fail
end


(** relation: inst_ext_decl
 **
 ** This relation handles the external declaration. If there is an explicit call
 ** of the external function, the component references are looked up and
 ** inserted in the argument list, otherwise the input and output parameters are
 ** inserted in the argument list with their order. The return type is
 ** determined according to the specification; if there is a explicit call and a
 ** lhs, which must be an output parameter, the type of the function is that
 ** type. If no explicit call and only one output parameter exists, then this
 ** will be the return type of the function, otherwise the return type will be
 ** void. 
 **)

relation inst_ext_decl: (Env.Env, Ident, SCode.ClassDef) => DAE.ExternalDecl =
	
  rule	is_ext_explicit_call (extdecl) &
	inst_ext_get_fname (extdecl, n) => fname &
	inst_ext_get_fargs (env, extdecl) => fargs &
	inst_ext_get_rettype (env, extdecl) => rettype &
	inst_ext_get_lang (extdecl) => lang &
	let daeextdecl = DAE.EXTERNALDECL(fname,fargs,rettype,lang)
	-------------------------------------
	inst_ext_decl (env, n, SCode.PARTS(_,_,_,_,_,SOME(extdecl))) => daeextdecl

  rule	not is_ext_explicit_call (orgextdecl) &
	inst_ext_make_externaldecl (n, els, orgextdecl) => extdecl &
	inst_ext_get_fname (extdecl, n) => fname &
	inst_ext_get_fargs (env, extdecl) => fargs &
	inst_ext_get_rettype (env, extdecl) => rettype &
	inst_ext_get_lang (extdecl) => lang &
	let daeextdecl = DAE.EXTERNALDECL(fname,fargs,rettype,lang)
	-------------------------------------
	inst_ext_decl (env, n, SCode.PARTS(els,_,_,_,_,SOME(orgextdecl))) => daeextdecl

  rule	Debug.fprint("failtrace",  "#-- inst_ext_decl failed" )
	--------------------------
	inst_ext_decl (env, _, _) => fail
end


(** relation: is_ext_explicit_call
 ** 
 ** If the external function id is present, then a function call must
 ** exist, i.e. explicit call was written in the external clause.
 **)

relation is_ext_explicit_call : Absyn.ExternalDecl => () =

  axiom is_ext_explicit_call Absyn.EXTERNALDECL(SOME(id),_,_,_)

end

(** relation: inst_ext_make_externaldecl
 **
 ** This relation generates a default explicit function call, 
 ** when it is omitted. If only one output variable exists, the 
 ** implicit call is equivalent to 
 ** 
 **    external "C" output_var=func(input_var1, input_var2,...)
 **
 ** with the input_vars in their declaration order. If several output 
 ** variables exists, the implicit call is equivalent to
 **
 **    external "C" func(var1, var2, ...)
 **
 ** where each var can be input or output.
 **)

relation inst_ext_make_externaldecl: (Ident, SCode.Element list, Absyn.ExternalDecl) 
	  => Absyn.ExternalDecl = 

  (* the case with only one output var, and that cannot be array, otherwise
      inst_ext_make_crefs outvar will fail *)
  rule	Util.list_matching (els, is_output_var) => outvar::[] &
(*	is_not_array_type_var outvar & *)
	Util.list_matching (els, is_input_var) => invars &
	Util.list_map (invars, inst_ext_make_crefs) => explists &
	Util.list_flatten explists => exps &
	inst_ext_make_crefs outvar => [Absyn.CREF(retcref)] &
	let extdecl = Absyn.EXTERNALDECL(SOME(id),lang,SOME(retcref),exps)
	------------------------------------------------
	inst_ext_make_externaldecl (id, els, Absyn.EXTERNALDECL(_,lang,_,_)) 
	  => extdecl

  rule	Util.list_matching (els, is_inout_var) => inoutvars &
	Util.list_map (inoutvars, inst_ext_make_crefs) => explists &
	Util.list_flatten explists => exps &
	let extdecl = Absyn.EXTERNALDECL(SOME(id),lang,NONE,exps)
	------------------------------------------------
	inst_ext_make_externaldecl (id, els, Absyn.EXTERNALDECL(_,lang,_,_)) 
	  => extdecl

  rule	Debug.fprint("failtrace", "#-- inst_ext_make_externaldecl failed\n")
	---------------------------------------------------------
	inst_ext_make_externaldecl (_,_,_) => fail

end	

relation is_inout_var : SCode.Element => () =

  rule is_output_var e
       --------------
       is_inout_var e

  rule is_input_var e
       --------------
       is_inout_var e
end

relation is_output_var : SCode.Element => () =
  axiom	is_output_var SCode.COMPONENT(_,_,_,_,SCode.ATTR(_,_,_,_,Absyn.OUTPUT),_,_,_)
end

(* subscript list is empty => not an array type *)
relation is_not_array_type_var : SCode.Element => () =
  axiom	is_not_array_type_var SCode.COMPONENT(_,_,_,_,SCode.ATTR([],_,_,_,_),_,_,_)
end

relation is_input_var : SCode.Element => () =
  axiom	is_input_var SCode.COMPONENT(_,_,_,_,SCode.ATTR(_,_,_,_,Absyn.INPUT),_,_,_)
end

relation inst_ext_make_crefs : SCode.Element => Absyn.Exp list =

  rule	inst_ext_make_crefs_2 (id,dims,1) => sizelist &
	let crlist = Absyn.CREF(Absyn.CREF_IDENT(id,[]))::sizelist
	-----------------------------------------------
	inst_ext_make_crefs SCode.COMPONENT(id,fi,re,pr,SCode.ATTR(dims,_,_,_,_),path,mod,_)
	  => crlist
end

relation inst_ext_make_crefs_2 : (SCode.Ident, Absyn.ArrayDim, int) => Absyn.Exp list =

  axiom	inst_ext_make_crefs_2 (id, [], _) => []

  rule	int_add(dimno,1) => nextdimno &
	inst_ext_make_crefs_2 (id, restdim, nextdimno) => restlist &
	let exps = Absyn.CALL(Absyn.CREF_IDENT("size",[]),
			      Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(id,[])),
						  Absyn.INTEGER(dimno)], []))::restlist
	---------------------------------------
	inst_ext_make_crefs_2 (id,dim::restdim,dimno) => exps

end

relation inst_ext_get_fname : (Absyn.ExternalDecl, Ident) => Ident =

  axiom	inst_ext_get_fname (Absyn.EXTERNALDECL(SOME(id),_,_,_), fid) => id
  axiom	inst_ext_get_fname (Absyn.EXTERNALDECL(NONE,_,_,_), fid) => fid

end

(* Default is "C", so if no language specified, return "C" *)
relation inst_ext_get_lang : Absyn.ExternalDecl => string =

  axiom	inst_ext_get_lang Absyn.EXTERNALDECL(_,SOME(lang),_,_) => lang
  axiom	inst_ext_get_lang Absyn.EXTERNALDECL(_,NONE,_,_) => "C"

end

(* special elab_exp for explicit external calls. This special relation calls 
   elab_exp_ext which handles size builtin calls specially, and uses the ordinary 
   Static.elab_exp for other expressions  *)
relation elab_exp_list_ext : (Env.Env, Absyn.Exp list, bool,
			      Interactive.InteractiveSymbolTable option) =>
	(Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option) =

  axiom	elab_exp_list_ext (_,[],impl,st) => ([],[],st)

  rule	elab_exp_ext (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list_ext (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list_ext (env, e::rest,impl,st) => (exp::exps, p::props,st'') 

end

(* special elab_exp for explicit external calls. This special relation calls 
   elab_exp_ext which handles size builtin calls specially, and uses the ordinary 
   Static.elab_exp for other expressions  *)

relation elab_exp_ext : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

  rule	(*Print.print_buf "// elab_exp_ext success for " &*)
(*	Static.elab_builtin_size(env,args) => (e,prop) & *)
	Static.elab_exp(env,dim,impl,NONE) => (dimp, Types.PROP(dimty,dim_const),_) &
	Static.elab_exp(env,arraycr,impl,NONE) => (arraycrefe, arraycrprop,_) &
	let exp = Exp.SIZE(arraycrefe,SOME(dimp)) 
	(*& Exp.print_exp exp &
	Print.print_buf "\n" *)
	----------------------------------------------------	
	elab_exp_ext (env,
		      call as Absyn.CALL(Absyn.CREF_IDENT("size",_),
					 Absyn.FUNCTIONARGS(args as [arraycr,dim],nargs)),impl,st) 
	  => (exp,Types.PROP((Types.T_INTEGER([]),NONE),false),st)

  rule	(*Print.print_buf "// elab_exp_ext failed for " & 
	Absyn.print_absyn_exp exp &
	Print.print_buf " calling Static.elab_exp: " & *)
	Static.elab_exp (env,exp,impl,st) => (e,prop,st) 
(*	& Exp.print_exp e &
	Print.print_buf "\n"*)
	---------------------------------------------------
	elab_exp_ext (env,exp,impl,st) => (e,prop,st)


  rule	Debug.fprint("failtrace", "-elab_exp_ext failed\n")
	-------------------
	elab_exp_ext (env,exp,impl,st) => fail
end

relation inst_ext_get_fargs : (Env.Env, Absyn.ExternalDecl) => DAE.ExtArg list =

  rule	elab_exp_list_ext (env, absexps, false, NONE) => (exps,props,_) &
	inst_ext_get_fargs2 (env, exps, props) => extargs	
	---------------------------------------------------------
	inst_ext_get_fargs (env, Absyn.EXTERNALDECL(id,lang,retcr,absexps)) => extargs

  rule	Debug.fprint("failtrace", "- inst_ext_get_fargs failed\n")
	-------------------------------------------------
	inst_ext_get_fargs (_,_) => fail
	
end

relation inst_ext_get_fargs2 : (Env.Env, Exp.Exp list, Types.Properties list) => DAE.ExtArg list =

  axiom	inst_ext_get_fargs2 (_,[],_) => []

  rule	inst_ext_get_fargs2 (env,exps,props) => extargs &
	inst_ext_get_fargs_single (env,e,p) => extarg
	-----------------------------------------
	inst_ext_get_fargs2 (env, e::exps,p::props) => extarg::extargs
end


relation inst_ext_get_fargs_single : (Env.Env, Exp.Exp, Types.Properties) => DAE.ExtArg =

  rule	Lookup.lookup_var_local (env, cref) => (attr, ty, bnd) 
	(*& Print.print_buf "inst_ext_get_fargs_single lookup_var_local success\n"*)
	--------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.CREF(cref,crty), Types.PROP(ty,cnst)) => DAE.EXTARG(cref,attr,ty)

  rule	not Lookup.lookup_var_local (env, cref) => (attr, ty, bnd) &
	Print.print_buf "inst_ext_get_fargs_single lookup_var_local failed\n" &
	Exp.print_component_ref_str cref => crefstr &
	Util.string_append_list (["#-- Unknown component ", crefstr, " in external clause\n"]) => str &
	Print.print_buf str
	--------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.CREF(cref,crty), Types.PROP(ty,cnst)) => fail

  rule	Lookup.lookup_var_local (env, cref) => (attr, varty, bnd)
	------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.SIZE(Exp.CREF(cref,crty), SOME(dim)), Types.PROP(ty,cnst)) 
	  => DAE.EXTARGSIZE(cref,attr,varty,dim)
				   
  axiom	inst_ext_get_fargs_single (env, exp, Types.PROP(ty,cnst)) => DAE.EXTARGEXP(exp,ty)

  rule	Debug.fprint("failtrace", "#-- inst_ext_get_fargs_single failed\n") &
	Debug.fcall("failtrace", Exp.print_exp, exp) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------------
	inst_ext_get_fargs_single (_,exp,prop) => fail
end


relation inst_ext_get_rettype : (Env.Env, Absyn.ExternalDecl) => DAE.ExtArg =

  axiom	inst_ext_get_rettype (_, Absyn.EXTERNALDECL(_,_,NONE,_)) => DAE.NOEXTARG

  rule	Static.elab_cref (env,cref) => (exp,prop,acc) &
	inst_ext_get_fargs_single (env, exp,prop) => extarg
	-----------------------------------------
	inst_ext_get_rettype (env,Absyn.EXTERNALDECL(n,lang,SOME(cref),args)) => extarg

  rule	Debug.fprint("failtrace", "#-- inst_ext_rettype failed\n")
	--------------------------------------------------------
	inst_ext_get_rettype (_,_) => fail

end

(** relation: inst_enumeration
 ** This relation takes an 'Ident' and list of strings, and returns an enumeration class.
**)
relation inst_enumeration: (SCode.Ident, string list) => SCode.Class =
  rule	make_enum_components(l) => comp
	--------------------------------
	inst_enumeration(n,l) => SCode.CLASS(n,false,false,SCode.R_ENUMERATION,SCode.PARTS(comp,[],[],[],[],NONE))
end

(** LS: false for replaceable added **)

(** relation: make_enum_components
 ** This relation takes a list of strings and returns the elements of 
 ** type 'EnumType' each corresponding to one of the enumeration values.
 **)
relation make_enum_components: string list => SCode.Element list =
  axiom make_enum_components ([str]) 
	  =>  [SCode.COMPONENT(str,true,false,false,SCode.ATTR([],false,SCode.RO,SCode.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD,NONE)]
	  
  rule	make_enum_components(x) => els
	----------------------------
	make_enum_components (str::(x as (_::_)))
	  => SCode.COMPONENT(str,true,false,false,SCode.ATTR([],false,SCode.RO,SCode.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD,NONE):: els
end

(** relation: dae_declare
 **
 ** Given a global component name, a type, and a set of attributes,
 ** this relation declares a component for the DAE result.  Altough
 ** this relation returns a list of `DAE.Element's, only one component
 ** is actually declared.
 **
 ** The relations `dae_declare2' and `dae_declare3' below are helper
 ** relations that perform parts of the task.
 **)

(* LS: Added direction so that function elements can be defined
   correctly *)
relation dae_declare : (Exp.ComponentRef,
			Types.Type, 
			SCode.Attributes, 
			Exp.Exp option,
			InstDims,
			DAE.StartValue
			) 
	  => DAE.Element list =

  rule	(*Debug.fprint( "insttr", "dae_declare(") &
	Debug.fcall ( "insttr", Exp.print_component_ref,vn) &
	Debug.fprint ( "insttr", ",") &
	Debug.fcall ( "insttr", Types.print_type,ty)  &
	Debug.fprint ("insttr", "...)\n") &*)
	DAE.to_flow flow => flow' &
	dae_declare2 (vn, ty, flow', par, dir, e, inst_dims, start) => dae
	-----------------------------------
	dae_declare (vn, ty, SCode.ATTR(_,flow,_,par,dir), e, inst_dims,start) 
	  => dae

  rule	Debug.fprint("failtrace", "- dae_declare failed\n")
	------------------------------
	dae_declare(_,_,_,_,_,_) => fail

end

(**)
(* LS: Added direction so that function elements can be defined
   correctly *)
relation dae_declare2 : (Exp.ComponentRef, Types.Type, DAE.Flow, SCode.Variability,
			 Absyn.Direction, Exp.Exp option, 
			 InstDims, DAE.StartValue)
	  => DAE.Element list =

  rule	dae_declare3 (vn, ty, flow, DAE.VARIABLE, dir, e, 
		      inst_dims,start) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.VAR, dir, e, inst_dims,start) => dae

  rule	dae_declare3 (vn, ty, flow,  DAE.DISCRETE, dir, e,  
		      inst_dims,start) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.DISCRETE, dir, e, inst_dims,start) => dae

  rule	dae_declare3 (vn, ty, flow, DAE.PARAM, dir, e,  
		      inst_dims,start) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.PARAM, dir, e, inst_dims,start) 
	  => dae

  rule	dae_declare3 (vn, ty, flow, DAE.CONST, dir, e,  
		      inst_dims,start) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.CONST, dir, e, inst_dims,start) 
	  => dae

  rule	dae_declare3 (vn, ty, flow, DAE.CONST, dir, e, 
		      inst_dims,start) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, flow, SCode.STRUCTPARAM, dir, e, inst_dims,start) 
	  => dae

  rule	Debug.fprint("failtrace", "- dae_declare2 failed\n")
	------------------------------
	dae_declare2(_,_,_,_,_,_,_,_) => fail

end



relation dae_declare3 : (Exp.ComponentRef, Types.Type, DAE.Flow, DAE.VarKind,
			 Absyn.Direction, Exp.Exp option, 
			 InstDims, DAE.StartValue)
	  => DAE.Element list =

  rule	dae_declare4 (vn, ty, fl, vk, DAE.INPUT, e, inst_dims,start) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, fl, vk, Absyn.INPUT, e, inst_dims,start) 
	  => dae

  rule	dae_declare4 (vn, ty, fl, vk, DAE.OUTPUT, e, inst_dims,start) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, fl, vk, Absyn.OUTPUT, e, inst_dims,start) => dae

  rule	dae_declare4 (vn, ty, fl, vk, DAE.BIDIR, e, inst_dims,start) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, fl, vk, Absyn.BIDIR, e, inst_dims,start) => dae

  rule	Debug.fprint("failtrace", "#- dae_declare3 failed\n")
	------------------------------
	dae_declare3(_,_,_,_,_,_,_,_) => fail

end



(**)

relation dae_declare4 : (Exp.ComponentRef, Types.Type, DAE.Flow, DAE.VarKind,
			 DAE.VarDirection, Exp.Exp option, InstDims, 
			 DAE.StartValue)
	  => DAE.Element list =

  axiom	dae_declare4 (vn, (Types.T_INTEGER(_),_), fl, kind, dir, e,  
		      inst_dims,start)
	  => [DAE.VAR(vn, kind, dir, DAE.INT, e,  inst_dims,start,fl,Absyn.IDENT(""))]
	
  axiom	dae_declare4 (vn, (Types.T_REAL(_),_), fl, kind, dir, e, 
		      inst_dims,start)
	  => [DAE.VAR(vn, kind, dir, DAE.REAL, e, inst_dims,start,fl,Absyn.IDENT(""))]

  axiom	dae_declare4 (vn, (Types.T_BOOL(_),_), fl, kind, dir, e, 
		      inst_dims,start)
	  => [DAE.VAR(vn, kind, dir, DAE.BOOL, e, inst_dims,start,fl,Absyn.IDENT(""))]
	
  axiom	dae_declare4 (vn, (Types.T_STRING(_),_), fl, kind, dir, e, 
		      inst_dims,start)
	  => [DAE.VAR(vn, kind, dir, DAE.STRING, e, inst_dims,start,fl,Absyn.IDENT(""))]

axiom dae_declare4 (vn, (Types.T_ENUM,_), fl, kind, dir, e, inst_dims,start)
	=> []
	(* We should not declare each enumeration value of an enumeration when instantiating,e.g Myenum my !=> constant EnumType my.enum1,... *)
	(*[DAE.VAR(vn, kind, dir, DAE.ENUM, e, inst_dims)]*)

  axiom	dae_declare4 (vn, (Types.T_ENUMERATION(l,_),_), fl, kind, dir, e,
		      inst_dims,start)
	  => [DAE.VAR(vn, kind, dir, DAE.ENUMERATION(l), e, inst_dims,start,fl,Absyn.IDENT(""))]

  axiom	dae_declare4 (c,ty,_,_,_,_,_,_) => []

end

(** LS & ELN 
 **
 ** Calls inst_equation_common with Inital set to NON_INITIAL. 
 ** 
 ** Has the same interface and semantics as the old inst_equation
 **)

relation inst_equation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	(* Equation inherited from base class *)
	get_derived_env(env,bc) => env' &
	inst_equation_common (env',mods,pre,csets,ci_state,eq,NON_INITIAL)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_equation (env,mods,pre,csets,ci_state,SCode.EQUATION(eq,bc))
	  => (dae,env,csets',ci_state')

  rule	Debug.fprint("failtrace", "- inst_equation failed\n")
	----------------------------------
	inst_equation (_,_,_,_,_,_) => fail

end


(* For EEquation, used in for loops and if-equations *)
relation inst_e_equation: (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.EEquation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_equation_common (env,mods,pre,csets,ci_state,eq,NON_INITIAL)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_e_equation (env,mods,pre,csets,ci_state,eq)
	  => (dae,env,csets',ci_state')
end

(** LS & ELN 
 **
 ** Calls inst_equation_common with Inital set to INITIAL
 **)

relation inst_initialequation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	(* Equation inherited from base class *)
	get_derived_env(env,bc) => env' &
	inst_equation_common (env',mods,pre,csets,ci_state,eq,INITIAL)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_initialequation (env,mods,pre,csets,ci_state,SCode.EQUATION(eq,bc))
	  => (dae,env,csets',ci_state')

  rule	Debug.fprint("failtrace", "- inst_initialequation failed\n")
	----------------------------------
	inst_initialequation (_,_,_,_,_,_) => fail

end

(* For EEquation used in for loops and if equations *)
relation inst_e_initialequation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.EEquation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_equation_common (env,mods,pre,csets,ci_state,eq,INITIAL)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_e_initialequation (env,mods,pre,csets,ci_state,eq)
	  => (dae,env,csets',ci_state')
end

(** LS & ELN 
 **
 ** Old inst_equation was renamed to inst_equation_common and 
 ** the Initial parameter was added.
 **)

(** relation: inst_equation_common
 **
 ** The DAE output of the translation contains equations which
 ** in most cases directly corresponds to equations in the source.
 ** Some of them are also generated from `connect' clauses.
 **
 ** This relation takes an equation from the source and generates DAE
 ** equations and connection sets.
 ** 
 **)

relation inst_equation_common : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.EEquation, Initial)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

	(**  connect
	 **
	 ** Handle connct statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2) => (csets',dae) &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	------------------------------------------------------------
	inst_equation_common(env,mods,pre, csets, ci_state, 
			     SCode.EQ_CONNECT(c1,c2), 
			     initial)
	  => (dae,env,csets',ci_state')
	  
	(** The following rule handles shadowed (replaced) equations. *)
	(** If an equation has a simple name on the left-hand side, *)
	(** and that component has an equation modifier, this equation *)
	(** is discarded. *)
  rule	Lookup.lookup_ident_local(env,n)
	  => (Types.VAR(_,_,_,_,Types.EQBOUND(_,_)),_,_) &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	------------------------------------------------------
	inst_equation_common(env,mods,pre,csets,ci_state,
			     SCode.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2),
			     initial)
	  => ([],env,csets,ci_state')

  rule	(* 
	 Do static analysis and constant evaluation of expressions. 
	 Gives expression and properties 
	 (Type * bool | (Type * Const as (bool | Const list))).
	 For a function, it checks the funtion name. 
	 Also the function call's in parameters are type checked with
	 the functions definition's inparameters. This is done with
	 regard to the position of the input arguments.

	 Returns the output parameters from the funktion.
	*)

	Static.elab_exp(env,e1,false,NONE) => (e1',prop1,c1) &
	Static.elab_exp(env,e2,false,NONE) => (e2',prop2,c2) &

	Prefix.prefix_exp(env,e1',pre) => e1'' &
	Prefix.prefix_exp(env,e2',pre) => e2'' &
(*	Debug.print("\nDebug: did prefixes.") &*)
(*
 put params-> in front of parameters
 doesn't work after prefix_exp, because of lookup failure

 prefix_params (env, e1'') => e1''' &
 prefix_params (env, e2'') => e2''' & 
*)
	(*PR. Check that the lefthandside and the righthandside get along. *)
	inst_eq_equation(e1'',prop1,e2'',prop2,initial) => dae &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' 
	--------------------------------------------------------------
	inst_equation_common(env, mods, pre, csets, ci_state,
			     SCode.EQ_EQUALS(e1,e2), 
			     initial)
	  => (dae, env, csets, ci_state')

	(**  `if' statements
	 **
	 ** If statements are instantiated by evaluating the
	 ** conditional expression, and selecting the branch that
	 ** should be used.
	 **)


	(* When the condition is constant evaluate it and select the correct branch *)
  rule	Static.elab_exp(env,e,false,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),true),_) &
	Ceval.ceval(env,e',false,NONE,NONE) => (Values.BOOL(cond),_) &
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     NON_INITIAL)
	  => (dae,env',csets', ci_state')

  rule	Static.elab_exp(env,e,false,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),true),_) &
	Ceval.ceval(env,e',false,NONE,NONE) => (Values.BOOL(cond),_) &
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_e_initialequation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     INITIAL)
	  => (dae,env',csets', ci_state')

  rule	Static.elab_exp(env,e,false,NONE) => (e',Types.PROP((Types.T_BOOL(_),_),false),_) &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, tb)
	  => (dae1,env',_, ci_state') &  (* There are no connections inside if-clauses. *)
	inst_list(env',mod,pre,csets,ci_state,inst_e_equation, fb)
	  => (dae2,env'',_, ci_state'')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     NON_INITIAL)
	=> ([DAE.IF_EQUATION(e',dae1,dae2)],env',csets, ci_state')


	(**  `when equation' statement, modelica 1.1 
	 **
	 ** When statements are instantiated by evaluating the
	 ** conditional expression.
	 **)

rule	Static.elab_exp (env,e,false,NONE) => (e',_,_) &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, el) => (dae1,env',_,_) &
	inst_equation_common(env',mod,pre,csets,ci_state,SCode.EQ_WHEN(ee,eel,eex),initial) 
	  => (dae2::_, env'',_,ci_state') &
         inst_equation_common_ci_trans (ci_state', initial) => ci_state''
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el, (ee,eel)::eex),   
			     initial as NON_INITIAL)
	=> ([DAE.WHEN_EQUATION(e',dae1,SOME(dae2))], env'',csets, ci_state'')

rule	Static.elab_exp (env,e,false,NONE) => (e',_,_) &
	inst_list(env,mod,pre,csets,ci_state,inst_e_equation, el) => (dae1,env',_,_) &
         inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el,[]),   
			     initial as NON_INITIAL)
	  => ([DAE.WHEN_EQUATION(e',dae1,NONE)], env', csets, ci_state')

(* seems unnecessary to handle when equations that are initial *) 


	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **
	 **)

	(** FIXME: Why lookup after add_for_loop_scope ? **)

  rule	(*Debug.fprintln ("insttr", "inst_equation_common_eqfor_1") &*)
	Static.elab_exp (env,e,false,NONE)
	  => (e',Types.PROP((Types.T_ARRAY(Types.DIM(_),
					   id_t),_),
			     true),_) &
	(*Debug.fprintln ("insti", "for expression elaborated") &*)
	add_for_loop_scope(env,i,id_t) => env' &
(*	Debug.fprintln ("insti", "loop-variable added to scope") &*)
	
	Lookup.lookup_var(env', Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      (Types.T_INTEGER(_),_), Types.UNBOUND) &
(*	Debug.fprintln ("insti", "loop variable looked up") &*)
	
	(* FIXME: Check bounds *)
	Ceval.ceval (env,e',false,NONE,NONE) => (v,_) &
(*	Debug.fprintln ("insti", "for expression evaluated") &*)
	unroll(env',mod,pre,csets,ci_state,i,v,el,initial) => (dae, csets') &
(*	Debug.fprintln ("insti", "for expression unrolled") &*)
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' 
(*	& Debug.fprintln ("insttr", "inst_equation_common_eqfor_1 succeeded")*)
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial)
	  => (dae, env,csets', ci_state')

  rule	(*Debug.fprintln ("insttr", "inst_equation_common_eqfor_2") &*)
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      (Types.T_INTEGER(_),_), Types.UNBOUND) &
	(*Debug.fprintln ("insti", "loop variable looked up") &*)
	Static.elab_exp (env,e,false,NONE)
	  => (e',Types.PROP((Types.T_ARRAY(Types.DIM(_),
					   (Types.T_INTEGER(_),_)),_),
			     false),_) &
	Print.print_buf "#-- Error: Non-constant iteration bounds not supported\n" 
	(*& Debug.fprintln ("insttr", "inst_equation_common_eqfor_2 succeeded")*)
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial)
	  => fail

  rule	Debug.fprint("failtrace", "- inst_equation_common failed\n")
	----------------------------------
	inst_equation_common(_,_,_,_,_,_,_) => fail
end


(** LS & ELN **)
relation inst_equation_common_ci_trans : (ClassInf.State, Initial)
	  => ClassInf.State = 

  rule	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	---------------------------------------------------------------
	inst_equation_common_ci_trans (ci_state, NON_INITIAL) => ci_state'

  axiom	inst_equation_common_ci_trans (ci_state, INITIAL) => ci_state

(*
  rule	ClassInf.trans(ci_state, ClassInf.FOUND_INITIALEQUATION) => ci_state'
	---------------------------------------------------------------
	inst_equation_common_ci_trans (ci_state, INITIAL) => ci_state'
*)

end

(** HJ: **)
relation add_for_loop_scope : (Env.Env, Ident, Types.Type) => Env.Env =

  rule	Env.open_scope (env,false,SOME(for_scope_name)) => env' &
	Env.extend_frame_v(env',
			   Types.VAR(i,
				     Types.ATTR(false,
						SCode.RW,
						SCode.VAR,
						Absyn.BIDIR),
				     false,
				     typ, 
				     Types.UNBOUND),NONE,false
			   ) => env''
	---------------
	add_for_loop_scope(env, i,typ) => env''

end

(** LS: **)
relation is_parameter : (Exp.ComponentRef, Env.Env) => () =

  rule	(*Env.print_env env &*)
	Lookup.lookup_var (env, cr) 
	  => (Types.ATTR(fl, acc, SCode.PARAM,dir), ty, bnd)
	----------------------------------------------------
	is_parameter (cr, env)

end 

(** LS: **)
relation prefix_params : (Env.Env, Exp.Exp) => Exp.Exp =

  rule	ModUtil.string_prefix_component_ref ("params->", is_parameter, env, e) => e'
	-----------------------------------------------------------------------
	prefix_params (env, e) => e'

end


(** LS & ELN 
 **
 ** Initial is added as a parameter.
 **  
 **)

(** relation: inst_eq_equation
 **
 ** Equations follow the same typing rules as equality expressions.
 ** This relation adds the equation to the DAE.
 **
 **)

relation inst_eq_equation : (Exp.Exp, Types.Properties,
			     Exp.Exp, Types.Properties, Initial) => DAE.Element list =
	(*PR. e1= lefthandside, e2=righthandside
	* This seem to be a strange relation. 
	* wich rule is matched? or is both rules matched?
	*)

        (* LS: Static.type_convert in Static.match_prop can probably fail,
	 * then the first rule will not match. Question if whether the second
	 * rule can match in that case.
	 *)
	
	(* This rule is matched first, if it fail the next rule is matched.
	 *)
  rule	(*Debug.print("\ninst_eq_equation (match e1) PROP, PROP") &*)
	Types.match_prop(e1, p1, p2) => e1' &
	inst_eq_equation_2(e1', e2, t2, initial) => dae 

	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP(t1,_),
			 e2,p2 as Types.PROP(t2,_), initial)
	  => dae

	(* If it fails then this rule is matched. *)
  rule	(*Debug.print("\ninst_eq_equation (match e2) PROP, PROP") &*)
	Types.match_prop(e2, p2, p1) => e2'&
(*	Debug.print("\n Second rule of relation_ inst_eq_equation ") &*)
	inst_eq_equation_2(e1, e2', t1, initial) => dae 
(*	& Debug.print("\n Second rule complete. ") *)
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP(t1,_),
			 e2,p2 as Types.PROP(t2,_), initial)
	  => dae



  rule	(* Debug.print("\ninst_eq_equation(e1) PROP_TUPLE, PROP_TUPLE") &*)
	(*Exp.print_exp (e1) & *)
	Types.match_prop(e1, p1, p2) => e1' &
	(*Exp.print_exp (e1') & *)
	inst_eq_equation_2(e1', e2, t2, initial) => dae 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,p2 as Types.PROP_TUPLE(t2,_), initial)
	  => dae


(*
  rule
	print("\n So far so good.") &
	
	print("\n  ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,Types.PROP_TUPLE(t2,_))
	  => fail
*)



	(* PR. *)	
  rule	(*Debug.print("\ninst_eq_equation(e2) PROP_TUPLE, PROP_TUPLE") &
	Debug.print "\n About to do a static match e2. " &*)
	Types.match_prop(e2, p2, p1) => e2'&
(*	Debug.print("\n Second rule of relation_ inst_eq_equation ") &*)
	inst_eq_equation_2(e1, e2', t1, initial) => dae 
(*	& Debug.print("\n Second rule complete. ") *)
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,p2 as Types.PROP_TUPLE(t2,_), initial)
	  => dae

	  (* An assignment to a varaible of T_ENUMERATION type is an explicit 
	     assignment to the value componnent of the enumeration, i.e. having a type T_ENUM*)
	
  rule	(*Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM or T_ENUMERATION.\n") &*)
	inst_eq_equation_2(e1,e2,t,initial) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Types.PROP((Types.T_ENUMERATION(_,_),_),_),
	    e2,Types.PROP(t as (Types.T_ENUM,_),_), initial) => dae

  rule	(*Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM or T_ENUMERATION.\n") &*)
	inst_eq_equation_2(e1,e2,t,initial) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Types.PROP((Types.T_ENUMERATION(_,_),_),_),
	    e2,Types.PROP(t as (Types.T_ENUMERATION(_,_),_),_), initial) => dae


  rule	(* Types.equivtypes(t1,t2) => false & *)
	Print.print_buf "# Illegal types in equation\n"&
	Print.print_buf "    lhs: " & Exp.print_exp e1 &
	Print.print_buf " :: " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    rhs: " & Exp.print_exp e2 &
	Print.print_buf " :: " & Types.print_type t2 & Print.print_buf "\n"
	----------
	inst_eq_equation(e1,Types.PROP(t1,_),
			 e2,Types.PROP(t2,_), initial) => fail


(* PR To debug*)

  rule	(*Debug.print("\ne1 is PROP and e2 is PROP_TUPLE.  ")*)
	---------------------------------	
	inst_eq_equation(e1,Types.PROP(t1,_),
			 e2, Types.PROP_TUPLE(_,_), initial) => fail

  rule	(*Debug.print("e2 is PROP")*)
	---------------------------------
	inst_eq_equation(e1,_,
			 e2,Types.PROP(t2,_), initial) => fail

  rule	(*Debug.print("e1 is PROP")*)
	---------------------------------
	inst_eq_equation(e1,Types.PROP(t1,_),
			 e2, _, initial) => fail




(* No match. *)
  rule	Debug.fprint("failtrace", "\n No match in inst_eq_equation. ")
	---------------------------------	
	inst_eq_equation(_,_,_,_,_) => fail

end

(** LS & ELN 
 **
 ** Initial is added as a parameter.
 **
 **)

(** relation: inst_eq_equation_2
 **
 ** This is the second stage of `inst_eq_equation', when the types are
 ** checked.
 **)

relation inst_eq_equation_2 : (Exp.Exp, Exp.Exp, Types.Type, Initial)
	=> DAE.Element list =

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_INTEGER(_),_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_REAL(_),_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_STRING(_),_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_BOOL(_),_),initial) => [dae]

  rule	make_dae_define (cr,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(Exp.CREF(cr,t),e2,(Types.T_ENUM,_),initial) => [dae]

  rule	make_dae_define (cr,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(Exp.CREF(cr,t),e2,(Types.T_ENUMERATION(_,_),_),initial) => [dae]


  rule	RTOpts.split_arrays => true &
	Exp.contain_functioncall(e1) => false &
	Exp.contain_functioncall(e2) => false &
(*	 For debugging.*)
(*	Print.print_buf "  Array equation: " &
	Exp.print_exp e1 & Print.print_buf " = " &
	Exp.print_exp e2 & Print.print_buf "\n" & *)
	inst_array_equation(e1,e2,ad,t,initial) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_ARRAY(ad,t),_),initial) => dae


	(* PR. The muliple outputs from functions is outputed as is. *)

  rule	make_dae_equation (e1,e2,initial) => dae 
	----------------------------------------
	inst_eq_equation_2 (e1,e2,(Types.T_TUPLE(_),_),initial) => [dae]


  rule	(*RTOpts.split_arrays => false &*)
	make_dae_equation (e1, e2, initial) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,(Types.T_ARRAY(ad,t),_),initial) => [dae]

  axiom	inst_eq_equation_2(e1, e2, (Types.T_COMPLEX(_,[]),_), initial) => []

  rule	Exp.extend_cref(c1,n,[]) => c1' &
	Exp.extend_cref(c2,n,[]) => c2' &
	inst_eq_equation_2(Exp.CREF(c1',t1), Exp.CREF(c2',t2), t, initial) => dae1 &
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   (Types.T_COMPLEX(cs,vs),p), initial) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   (Types.T_COMPLEX(cs,Types.VAR(n,_,_,t,_)::vs),p), initial) => dae

	(** When the type of the expressions is a complex type, and *)
	(** the left-hand side of the equation is not a component *)
	(** reference, a new variable is introduced to be able to *)
	(** dereference components of the expression. *)
	(** *)
	(** This is rather ugly, since it doesn't really solve the *)
	(** problem of describing the semantics.  Now the semantics of *)
	(** composite equations are defined in terms of other *)
	(** composite equations.  To make this a little cleaner, the *)
	(** equation that equates the new name to the expression is *)
	(** stored using DAE.DEFINE rather than DAE.EQUATION.  This *)
	(** makes it a little clearer. *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     SCode.VAR, Absyn.BIDIR), NONE,[],NONE)
	  => decl &
	inst_eq_equation_2(Exp.CREF(n,Exp.OTHER), e2, t, initial) => dae1 &
	list_append(decl, DAE.DEFINE(n, e1)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2 as Exp.CREF(_,_),
			   t as (Types.T_COMPLEX(_,_),_), initial) => dae

	(** When the right-hand side is not a component reference a *)
	(** similar trick is applied.  This also catched the case *)
	(** where none of the sides is a component reference *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     SCode.VAR, Absyn.BIDIR), NONE,[],NONE)
	  => decl &
	inst_eq_equation_2(e1, Exp.CREF(n,Exp.OTHER), t, initial) => dae1 &
	list_append(decl, DAE.DEFINE(n, e2)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2, t as (Types.T_COMPLEX(_,_),_), initial) => dae

  rule	Debug.fprint("failtrace", "- inst_eq_equation_2 failed\n exp1=") &
	Debug.fcall("failtrace",Exp.print_exp, e1) &
	Debug.fprint("failtrace", " exp2=" ) &
	Debug.fcall("failtrace",Exp.print_exp, e2) &
	Debug.fprint("failtrace", " type =") &
	Debug.fcall("failtrace",Types.print_type, t) &
	Debug.fprint("failtrace", "\n")
	-------------------------------------
	inst_eq_equation_2(e1,e2,t,initial) => fail

end

(** LS & ELN **)

relation make_dae_equation : (Exp.Exp, Exp.Exp, Initial) => DAE.Element =

  axiom	make_dae_equation (e1,e2,NON_INITIAL) => DAE.EQUATION(e1,e2)

  axiom	make_dae_equation (e1,e2,INITIAL) => DAE.INITIALEQUATION(e1,e2)

end

(** LS & ELN **)

relation make_dae_define : (Exp.ComponentRef, Exp.Exp, Initial) => DAE.Element = 

  axiom	make_dae_define (cr, e2, NON_INITIAL) => DAE.DEFINE(cr,e2)

  axiom	make_dae_define (cr, e2, INITIAL) => DAE.INITIALDEFINE(cr,e2)

end

(** relation: inst_array_equation
 **
 ** This checks the array size and uses `inst_array_el_eq' to create
 ** equations for each array element.
 **)

relation inst_array_equation : (Exp.Exp, Exp.Exp,
				Types.ArrayDim, Types.Type, Initial)
	  => DAE.Element list =

  rule	Print.print_buf "# Cannot instantiate equations with arrays of unknown size\n" &
	Print.print_buf "    " & Exp.print_exp e1 & Print.print_buf " = " & Exp.print_exp e2&
	Print.print_buf "\n"
	----------
	inst_array_equation(e1, e2, Types.DIM(NONE), t, initial) => fail

  rule	inst_array_el_eq(e1, e2, t, 1, sz, initial) => dae
	---------------------------------------------
	inst_array_equation(e1, e2, Types.DIM(SOME(sz)), t, initial) => dae

  rule	Debug.fprint("failtrace", "- inst_array_equation failed\n")
	--------------------------------------
	inst_array_equation (_,_,_,_,_) => fail

end

(** relation: inst_array_el_eq
 **
 ** This relation loops recursively through all indexes in the two
 ** arrays and generates an equation for each pair of elements.
 **)

relation inst_array_el_eq : (Exp.Exp, Exp.Exp, Types.Type, int, int, Initial)
	  => DAE.Element list =

  rule	int_le(i,sz) => true &
	Exp.simplify(Exp.ASUB(e1,i)) => e1' &
	Exp.simplify(Exp.ASUB(e2,i)) => e2' &
	inst_eq_equation_2(e1',e2',t,initial) => dae1 &
	int_add(i,1) => i' &
	inst_array_el_eq(e1,e2,t,i',sz,initial) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_array_el_eq(e1, e2, t, i, sz, initial) => dae

  rule	int_le(i,sz) => false
	---------------------
	inst_array_el_eq(e1, e2, t, i, sz, initial) => []

  rule	Debug.fprint("failtrace", "- inst_array_el_eq failed\n")
	-----------------------------------
	inst_array_el_eq(_,_,_,_,_,_) => fail

end

(** relation: inst_assertion
 **
 ** Instantiate an assertion.  There are not assertions in the output
 ** currently.
 **)

relation inst_assertion : (Env.Env, Exp.Exp, Types.Type,
			   bool, string, Prefix)
	  => DAE.Element list =

	(* Constant assertions *)
  axiom	inst_assertion (env, e, (Types.T_BOOL(_),_), true, d, pre) => [DAE.ASSERT(e)]

  axiom	inst_assertion (env, e, (Types.T_BOOL(_),_), _, d, pre) => [DAE.ASSERT(e)]

  rule	Print.print_buf "# Assertions have to be of type Boolean\n" &
	Print.print_buf "  assertion: (" &
	Prefix.prefix_exp(env,e,pre) => e' & Exp.print_exp e' & Print.print_buf "): " &
 	Print.print_buf d & Print.print_buf "\n"
	-----------------------------
	inst_assertion (env, e, _, _, d, pre) => fail
	
end

(** LS & ELN
 **
 ** Added the Initial parameter
 **)

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, SCode.EEquation list, Initial)
	  => (DAE.Element list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_,_) => ([], csets)

  rule	Env.open_scope (env,false,SOME(for_scope_name)) => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    SCode.CONST,
						    Absyn.BIDIR),
				      true,
				      (Types.T_INTEGER([]),NONE),
				      Types.VALBOUND(fst)),NONE,false) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_e_equation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs, initial)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs,initial as NON_INITIAL)
	  => (dae, csets'')

  rule	Env.open_scope (env, false,SOME(for_scope_name)) => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    SCode.CONST,
						    Absyn.BIDIR),
				      true,
				      (Types.T_INTEGER([]),NONE),
				      Types.VALBOUND(fst)),NONE,false) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_e_initialequation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs, initial)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs,initial as INITIAL)
	  => (dae, csets'')

  rule	Debug.fprint("failtrace",  "- unroll ") & 
	Debug.fcall("failtrace", Values.print_val, v) &
	Debug.fprint("failtrace", " failed\n")
	-------------------------
	unroll (_,_,_,_,_,_,v,_,_) => fail

end

(** relation: inst_algorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	(* If algorithm is inherited, find base class environment*)
	get_derived_env(env,bc) => env' &
	inst_statements(env',statements) => statements'
	----------------------------------------------
	inst_algorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements,bc))
	  => ([DAE.ALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	Debug.fprint("failtrace", "- inst_algorithm failed\n")
	---------------------------------
	inst_algorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_initialalgorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_initialalgorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	get_derived_env(env,bc) => env' &
	inst_statements(env,statements) => statements'
	----------------------------------------------
	inst_initialalgorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements,bc))
	  => ([DAE.INITIALALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	Debug.fprint("failtrace", "- inst_algorithm failed\n")
	---------------------------------
	inst_initialalgorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_statements
 **
 ** This relation converts a list of algorithm statements.
 **)

relation inst_statements : (Env, Absyn.Algorithm list)
	  => Algorithm.Statement list =

  axiom	inst_statements(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_statements(env,xs) => xs'
	------------------------------
	inst_statements(env,x::xs) => x'::xs'
end

relation inst_algorithmitems : (Env, Absyn.AlgorithmItem list)
	  => Algorithm.Statement list =

  axiom	inst_algorithmitems(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_algorithmitems(env,xs) => xs'
	------------------------------
	inst_algorithmitems(env,Absyn.ALGORITHMITEM(x,_)::xs) => x'::xs'

  rule	inst_algorithmitems(env,xs) => xs'
	------------------------------
	inst_algorithmitems(env,Absyn.ALGORITHMITEMANN(_)::xs) => xs'

end


(** relation: inst_statement
 **
 ** This relation Looks at an algorithm statement and uses relations
 ** in the `Algorithm' module to build a representation of it that can
 ** be used in the DAE output.
 **)

relation inst_statement : (Env, Absyn.Algorithm) => Algorithm.Statement =

  rule	Static.elab_cref (env,cr) => (Exp.CREF(ce,t), cprop, acc) &
    Static.canon_cref (env,ce) => ce' & 
	Static.elab_exp (env,e,false,NONE) => (e', eprop,_) &
	Algorithm.make_assignment(Exp.CREF(ce',t),cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e)) => stmt

  rule	Static.elab_cref (env,cr) => (ce, cprop, acc) &
	Static.elab_exp (env,e,false,NONE) => (e', eprop,_) &
	Algorithm.make_assignment(ce,cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e)) => stmt

  rule	Static.elab_exp (env,e,false,NONE) => (e' as Exp.CALL(_,_,_,_), eprop, _) &
	Static.elab_exp_list(env, expl, false, NONE) 
	  => (expl', cprops, _) &
	Algorithm.make_tuple_assignment(expl',cprops,e',eprop) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(expl),e)) => stmt

  rule	Print.print_buf "#Error, tuple assignment only allowed when rhs is function call.\n" 
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(expl),e)) => fail

  rule	Static.elab_exp(env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,tb) => tb' &
	inst_elseifs(env,eib) => eib' &
	inst_algorithmitems(env,fb) => fb' &
	Algorithm.make_if(e',prop,tb',eib',fb') => stmt
	--------------------------------------------
	inst_statement(env,Absyn.ALG_IF(e,tb,eib,fb)) => stmt

  rule	Static.elab_exp (env,e,false,NONE)  =>
	(e', prop as Types.PROP((Types.T_ARRAY(_,t),_),_),_) &
	
	add_for_loop_scope(env,i,t) => env' &
	
	inst_algorithmitems(env',sl) => sl' &
	Algorithm.make_for(i,e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_FOR(i,e,sl)) => stmt

  rule	Static.elab_exp (env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl) => sl' &
	Algorithm.make_while(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHILE(e,sl)) => stmt


  rule	Static.elab_exp (env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl) => sl' &
	Algorithm.make_when_a(e',prop,sl') => stmt
	(* TODO elsewhen *)
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN_A(e,sl,el)) => stmt

(* 1.0
 rule	Static.elab_exp (env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl) => sl' &
	Algorithm.make_when(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN(e,sl)) => stmt
*)

  rule	Static.elab_exp (env,cond,false,NONE) 
	  => (cond',cprop,_) &
	Static.elab_exp (env,msg,false,NONE) 
	  => (msg',msgprop,_) &
	Algorithm.make_assert(cond',msg',cprop,msgprop) => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),
					       Absyn.FUNCTIONARGS([cond,msg],[])))
	  => stmt

  rule  Debug.fprint("failtrace", "- inst_statement failed\n alg:") &
	Debug.fcall("failtrace", Dump.print_algorithm, alg) &
	Debug.fprint("failtrace", "\n") 
	---------------------------------
	inst_statement(env,alg) => fail
end

(** relation: inst_elseifs
 **
 ** This relation helps `inst_statement' to handle `elseif' parts.
 **)

relation inst_elseifs : (Env.Env, (Absyn.Exp * Absyn.AlgorithmItem list) list)
	=> (Exp.Exp * Types.Properties * Algorithm.Statement list) list =

  axiom	inst_elseifs (env,[]) => []

  rule	Static.elab_exp(env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,l) => stmts &
	inst_elseifs(env,tail) => tail'
	-------------------------------
	inst_elseifs(env,(e,l)::tail) => ((e',prop,stmts)::tail')

  rule	Debug.fprint("failtrace", "- inst_elseifs failed\n")
	-------------------------------
	inst_elseifs(_,_) => fail

end

(** relation: inst_connect
 ** 
 ** Generates connectionsets for connections.
 ** Parameters and constants in connectors should generate appropriate assert statements.
 ** Hence, a 'DAE.Element list' is returned as well.
 **)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef)
	  => (Connect.Sets,DAE.Element list) =

  rule	Static.elab_cref(env, c1) => (Exp.CREF(c1',t1),prop1,acc) &
	Static.elab_cref(env, c2) => (Exp.CREF(c2',t2),prop2,acc) &
	Static.canon_cref(env, c1') => c1'' &
	Static.canon_cref(env, c2') => c2'' &
	Lookup.lookup_var_local(env,c1'')
	  => (attr1 as Types.ATTR(flow1,_,_,_),ty1,_) &
	Lookup.lookup_var(env,c2'') => (attr2,ty2,_) &
	(** Check that the types of the connectors are good. *)
	valid_connector(ty1) &
	valid_connector(ty2) &
	check_connect_types(c1'',ty1,attr1,c2'',ty2,attr2) &
	component_face(c1'') => f1 &
	component_face(c2'') => f2 &
	connect_components(sets, env, pre, c1'', f1, ty1, c2'', f2, ty2, flow1)
	  => (sets',dae)
	---------------------------------
	inst_connect(sets, env,pre,c1,c2) => (sets',dae)

  rule	Print.print_buf "# could not connect\n"
	---------------------------------
	inst_connect(sets,_,_,_,_) => fail

end

(** relation: valid_connector
 **
 ** This relation tests whether a type is a eligible to be used in
 ** connections.
 **
 **)

relation valid_connector : Types.Type => () =

  axiom	valid_connector((Types.T_REAL(_),_))

  rule	ClassInf.valid(state,SCode.R_CONNECTOR)
	---------------------------------------
	valid_connector((Types.T_COMPLEX(state,_),_))

  rule	Print.print_buf "# Can't connect objects of type " &
	Types.print_type t & Print.print_buf "\n"
	-------------------------------
	valid_connector t => fail
end

(** relation: check_connect_types
 **
 ** Check that the type and type attributes of two connectors match,
 ** so that they really may be connected.
 **
 **)

relation check_connect_types : (Exp.ComponentRef, Types.Type,
				Types.Attributes,
			       	Exp.ComponentRef, Types.Type,
				Types.Attributes) => () =

  rule	assert_different_faces(c1,c2) &
	Print.print_buf "# Can't connect two input variables\n" &
	Print.print_buf "    while connecting " & Exp.print_component_ref c1 &
	Print.print_buf " to " & Exp.print_component_ref c2 &
	Print.print_buf "\n unless one of them is inside connector and the other outside connector."
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.INPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.INPUT)) => fail

  rule	assert_different_faces(c1,c2) &
	Print.print_buf "# Can't connect two output variables\n" &
	Print.print_buf "    while connecting " & Exp.print_component_ref c1 &
	Print.print_buf " to " & Exp.print_component_ref c2 & 
	Print.print_buf "\n unless one of them is inside connector and the other outside connector."
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.OUTPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.OUTPUT)) => fail

  rule	flow1 = flow2 &
	Types.equivtypes(t1, t2) => true
	-------------------------------
	check_connect_types(_,t1,Types.ATTR(flow1,_,_,_),
			    _,t2,Types.ATTR(flow2,_,_,_))

  rule	Print.print_buf "# Can't connect flow component " &
 	Exp.print_component_ref c1 &
	Print.print_buf " to non-flow component " &
 	Exp.print_component_ref c2 & Print.print_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(true,_,_,_),
			    c2,_,Types.ATTR(false,_,_,_)) => fail

  rule	Print.print_buf "# Can't connect non-flow component " &
 	Exp.print_component_ref c1 &
	Print.print_buf " to flow component " &
 	Exp.print_component_ref c2 & Print.print_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(false,_,_,_),
			    c2,_,Types.ATTR(true,_,_,_)) => fail

  rule	Debug.fprint("failtrace", "- check_connect_types(") & 
	Debug.fcall("failtrace", Exp.print_component_ref, c1) &
	Debug.fprint("failtrace", " <-> ") & 
        Debug.fcall("failtrace", Exp.print_component_ref, c2) & 
	Debug.fprint("failtrace", ") failed\n")
	------------------------------------------------------
	check_connect_types(c1,_,_,c2,_,_) => fail

end

(* fails if two connectors have same faces, e.g both inside or both outside connectors *)
relation assert_different_faces: (Exp.ComponentRef,Exp.ComponentRef)  => () =

  rule	component_face(c1) => Connect.INNER &	
	component_face(c1) => Connect.OUTER 
	----------------------------------
	assert_different_faces(c1,c2) => ()

  rule	component_face(c1) => Connect.OUTER &	
	component_face(c1) => Connect.INNER 
	----------------------------------
	assert_different_faces(c1,c2) => ()
end

(** relation: connect_components
 **
 ** This relation connects two components and generates connection
 ** sets along the way.  For simple components (of type `Real') it
 ** adds the components to the set, and for complex types it traverses
 ** the subcomponents and recursively connects them to each other.
 ** A DAE.Element list is returned for assert statements.
 **)

relation connect_components: (Connect.Sets,
			      Env.Env,
			      Prefix,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      bool) 
	  => (Connect.Sets, DAE.Element list) =
	  	
	(**  Flow type, must be a subtype of Real *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_flow(sets, c1', f1, c2', f2) => sets'
	-----------------------------------------
	connect_components(sets, env, pre, c1, f1, (Types.T_REAL(_),_),
			   c2, f2, (Types.T_REAL(_),_), true) => (sets',[])

  rule	Types.array_element_type(t1) => ((Types.T_REAL(_),_)) &
	Types.array_element_type(t2) => ((Types.T_REAL(_),_)) &
	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	----------------------------------------
	connect_components(sets,env, pre,c1,f1, (Types.T_ARRAY(_,t1),_),
			   c2,f2, (Types.T_ARRAY(_,t2),_),true) => (sets',[])
	
	(**  Non-flow type *)

	(** Parameters and constants generate assert statements *)
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Lookup.lookup_var_local(env,c1') => (Types.ATTR(_,_,vr,_),t1, _) &
	SCode.is_parameter_or_const(vr) => true &
	Types.basic_type t1 => true &
	Lookup.lookup_var_local(env,c2') => (Types.ATTR(_,_,_,_) ,t2, _) &
	Types.basic_type t2 => true 
	------------------------------------
	connect_components(sets, env, pre, c1, f1, (_,_),
			   c2, f2, (_,_), false) 
	  => (sets,
	      [DAE.ASSERT(Exp.CALL(Absyn.IDENT("assert"),
				     [Exp.RELATION(Exp.CREF(c1',Exp.REAL),
						 Exp.EQUAL(Exp.BOOL),
						 Exp.CREF(c2',Exp.REAL))
				      ,Exp.SCONST("automatically generated from connect")],false,true))])

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, env, pre, c1, _, (Types.T_REAL(_),_),
			   c2, _, (Types.T_REAL(_),_), false) => (sets',[])

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, env, pre, c1, _, (Types.T_INTEGER(_),_),
			   c2, _, (Types.T_INTEGER(_),_), false) => (sets',[])

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	dim1 = dim2 &
	Connect.add_array_equ(sets,c1',c2',dim1) => sets'
	----------------------------------------
	connect_components(sets,env,pre,c1,f1, (Types.T_ARRAY(Types.DIM(SOME(dim1)),t1),_),
			   c2,f2, (Types.T_ARRAY(Types.DIM(SOME(dim2)),t2),_),false) 
	  => (sets',[])

	(**  Complex types *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	connect_vars(sets,env,c1',f1,l1,c2',f2,l2) => (sets',dae)
	----------------------------------------
	connect_components(sets,env,pre,c1,f1, (Types.T_COMPLEX(_,l1),_),
			   c2,f2, (Types.T_COMPLEX(_,l2),_),_) => (sets',dae)
	
	(**  Error *)
	
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Print.print_buf "# Wrong type in connection\n"&
 	Print.print_buf "  while making connectiion " &
	Exp.print_component_ref c1 & Print.print_buf " <-> " &
	Exp.print_component_ref c2 & Print.print_buf "\n" &
	Print.print_buf "  The type `" & Types.print_type t1 &
	Print.print_buf "' is not allowed in connections\n"
	----------------------------------------
	connect_components(_,env,pre,c1,_,t1,c2,_,t2,_) => fail
	
end

(** relation: connect_vars
 **
 ** This relation connects two subcomponents by adding the component
 ** name to the current path and recursively connecting the components
 ** using the relation `connet_components'.
 **)

relation connect_vars : (Connect.Sets, 
			 Env.Env,
			 Exp.ComponentRef, Connect.Face, Types.Var list,
			 Exp.ComponentRef, Connect.Face, Types.Var list)
	  => (Connect.Sets, DAE.Element list) =

  axiom	connect_vars(sets,env,_,_,[],_,_,[]) => (sets,[])

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	check_connect_types(c1', ty1, attr1, c2', ty2, attr2) &
	connect_components(sets,env,Prefix.NOPRE,
			   c1',f1, ty1,
			   c2',f2, ty2, flow1) => (sets',dae) &
	connect_vars(sets',env,c1,f1,xs1,c2,f2,xs2) => (sets'',dae2) &
	list_append(dae,dae2) => dae'					 
	--------------------------------------
	connect_vars(sets,env,
		     c1,f1, Types.VAR(n,attr1 as Types.ATTR(flow1,_,vt1,_),
				      _,ty1,_)::xs1,
		     c2,f2, Types.VAR(_,attr2 as Types.ATTR(flow2,_,vt2,_),
				      _,ty2,_)::xs2)
	  => (sets'',dae')

end

(** relation: mktype **
 ** From a class typename, its inference state, and a list of subcomponents, this
 ** relation returns `Types.Type'.  If the class inference state
 ** indicates that the type should be a built-in type, one of the
 ** built-in type constructors is used.  Otherwise, a `T_COMPLEX' is
 ** built.
 **)

relation mktype : (Absyn.Path, ClassInf.State,Types.Var list) => Types.Type =
	
  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_INTEGER(_),v) => ((Types.T_INTEGER(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_REAL(_),v)    => ((Types.T_REAL(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_STRING(_),v)  => ((Types.T_STRING(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_BOOL(_),v)    => ((Types.T_BOOL(v),somep))

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,ClassInf.TYPE_ENUM(_),_)    => ((Types.T_ENUM,somep))

	(* Insert function type construction here
	   after checking input/output arguments? 
	   see types.rml T_FUNCTION *)

  rule	Types.make_function_type (p,vl) => functype
	--------------------------
	mktype(p,st as ClassInf.FUNCTION(name), vl) => functype

  rule	Types.make_enumeration_type (p,v1) => enumtype
	--------------------------------------------
	mktype(p,ClassInf.ENUMERATION(name),v1) => enumtype
(*
  rule	Print.print_buf " <function " & Print.print_buf name & Print.print_buf "> <" &
	Dump.print_list (vl, Types.print_var, ", ") &
	Print.print_buf " >"
	--------------------------
	mktype(st as ClassInf.FUNCTION(name), vl) => Types.T_COMPLEX(st,vl)
*)

  rule	get_opt_path(p) => somep
	-----------------------
	mktype(p,st,l) => ((Types.T_COMPLEX(st,l),somep))

end

relation get_opt_path: Absyn.Path => Absyn.Path option =
  axiom	get_opt_path Absyn.IDENT("") => NONE
  axiom	get_opt_path p => SOME(p)
end
(** relation: inst_list
 **
 ** This is a utility used to do instantiation of list of things,
 ** collecting the result in another list.
 **)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list)
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[]) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es)
	  => (l'',env'',csets'',ci_state'')

end

(** relation: component_face
 ** 
 ** This relation determines whether a component reference refers to an
 ** inner or outer connector.
 **)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_QUAL(_,_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

end



(** relation: inst_start_binding
** This relation investigates a modification and extracts the 
** start modification. E.g. Real x(start=1+3) => 1+3
** It also handles the case Integer T0[2](final start={5,6})={9,10} becomes
** Integer T0[1](start=5); Integer T0[2](start=6);
**
** Arg 1 is the start modification  
** Arg 2 is the expected type that the modification should have
** Arg 3 is the index list for the element: for T0[1,2] is {1,2} 
**
**)
relation inst_start_binding: (Types.Mod,Types.Type,int list) => DAE.StartValue =
        
  rule  
        
	    Mod.lookup_comp_modification(mod,"start") => mod2 &
	    
	    Mod.mod_equation(mod2) => SOME(Types.TYPED(e,Types.PROP(ty2,c))) &
	    Types.match_type(e,ty2,expected_type) => (e',ty') 

	 (*   & Debug.fprint("failtrace", "NO INDEX-------------- \n inst_start_binding ") & 
	    Debug.fcall("failtrace",Types.print_type, ty2) & 
	    Debug.fprint("failtrace", "| mod: ") & 
	    Debug.fcall("failtrace",Mod.print_mod, mod) & 
	    Debug.fprint("failtrace", "\n | mod2: ") & 
	    Debug.fcall("failtrace",Mod.print_mod, mod2) & 
	    Debug.fprint("failtrace", "\n , expected type ") & 
	    Debug.fcall("failtrace", Types.print_type, expected_type) &
	    Debug.fprint("failtrace", "\n--------------\n") *)
        
	    ---------------------------------------------------
	    inst_start_binding (mod,expected_type,[]) => SOME(e')
        
  rule  
  	    
	    Mod.lookup_comp_modification(mod,"start") => mod2 &
	    
        inst_start_binding2(mod2,etype,index_list) => result 
	    ---------------------------------------------------
        (*maybe this should be index::[]*)
	    inst_start_binding (mod,etype,index_list) => result
 
        
  rule  (*Debug.fprint("failtrace", "inst_start_binding 3333333333333") & 
	     Debug.fcall("failtrace", Types.print_type, etype) &
	     Debug.fprint("failtrace", "\n") *)
        ---------------------------------
   	    inst_start_binding(mod,etype,_) => NONE

end

(** relation: inst_start_binding2
** This relation investigates a modification and extracts the start modification if
** the modification is in array of components. 
** Help-relation to inst_start_binding
*)
relation inst_start_binding2: (Types.Mod,Types.Type,int list) => DAE.StartValue =

  rule  (* this rule handles the case where there is only one element in the index-list*)
        Mod.lookup_idx_modification(mod,index) => mod2 &
	    
        Mod.mod_equation(mod2) => SOME(Types.TYPED(e,Types.PROP(ty2,c))) &

        Types.match_type(e,ty2,etype) => (e',ty') 
        
	   (* & Debug.fprint("failtrace", "-------------- \n inst_start_binding ") & 
	    Debug.fcall("failtrace",Types.print_type, ty2) & 
	    Debug.fprint("failtrace", "| mod: ") & 
	    Debug.fcall("failtrace",Mod.print_mod, mod) & 
	    Debug.fprint("failtrace", "\n | mod2: ") & 
	    Debug.fcall("failtrace",Mod.print_mod, mod2) & 
	    Debug.fprint("failtrace", "\n | mod3: ") & 
	    Debug.fcall("failtrace", Types.print_type, etype) &
	    Debug.fprint("failtrace", "\n--------------\n") *)
        
	    ---------------------------------------------------
        (*maybe this should be index::[]*)
	    inst_start_binding2 (mod,etype,index::[]) => SOME(e')
 
  rule  (* this rule handles the case where there is several elements in the index-list*)
        Mod.lookup_idx_modification(mod,index) => mod2 &
	    
        inst_start_binding2(mod2,etype,res) => result

	 (*   & Debug.fprint("failtrace", "-------------- \n inst_start_binding ") & 
	    Debug.fprint("failtrace", "| mod: ") & 
	    Debug.fcall("failtrace",Mod.print_mod, mod) & 
	    Debug.fprint("failtrace", "\n | mod2: ") & 
	    Debug.fcall("failtrace",Mod.print_mod, mod2) & 
	    Debug.fprint("failtrace", "\n , expected type ") & 
	    Debug.fcall("failtrace", Types.print_type, etype) &
	    Debug.fprint("failtrace", "\n--------------\n") *)
        
	    ---------------------------------------------------
        (*maybe this should be index::[]*)
	    inst_start_binding2 (mod,etype,index::res) => result

  rule  (*Print.print_buf("inst_start_binding2 failed\n")*)
        ---------------------------------------------------
	    inst_start_binding2 (_,_,_) => fail
   
end

(** LS & ELN
 ** 
 ** Added NON_INITIAL for inst_eq_equation
 **
 **)

(** relation: inst_mod_equation
 **
 ** This relation adds the equation in the declaration of a variable,
 ** if such an equation exists.
 **)

relation inst_mod_equation : (Exp.ComponentRef, Types.Type, Mod)
	  => DAE.Element list =

	  
  rule	Types.elab_type ty1 => t &
(*
	Debug.print ("Debug: inst_mod_equation calling inst_eq_equation\n") &
	fix_mod_subscript (cr, e, prop2) => (e', prop2') &
	inst_eq_equation(Exp.CREF(cr,t),
			 Types.PROP(ty1,false), e',prop2',NON_INITIAL)
 => dae
*)
	inst_eq_equation(Exp.CREF(cr,t),
			 Types.PROP(ty1,false(*FIXME*)), e,prop2,NON_INITIAL) => dae
	-----------------------------------------------
	inst_mod_equation(cr,ty1, mod as Types.MOD(_,_,SOME(Types.TYPED(e,prop2))))
	  => dae

  axiom inst_mod_equation(_,_,Types.MOD(_,_,NONE)) => []
  axiom inst_mod_equation(_,_,Types.NOMOD) => []
  axiom	inst_mod_equation(_,_,Types.REDECL(_,_)) => []

  rule	Debug.fprint("failtrace", "- inst_mod_equation failed\n type: ") &
	Debug.fcall("failtrace", Types.print_type, t) &
  	Debug.fprint("failtrace", "\n  cref: ") &
	Debug.fcall("failtrace", Exp.print_component_ref, c) &
	Debug.fprint("failtrace", "\n mod:") &
	Debug.fcall("failtrace", Mod.print_mod, m) &
	Debug.fprint("failtrace", "\n") 
	------------------------------------
  	inst_mod_equation (c,t,m) => fail

end


(* might be needed from inst_mod_equation

relation fix_mod_subscript : (Exp.ComponentRef, Exp.Exp, Types.Properties) 
	  => (Exp.Exp, Types.Properties) = 

  rule	get_last_subscripts cr1 => subs &
	put_last_subscripts (cr2, subs) => cr2' &
	list_length subs => sublength &
	unlift_array_times (typrop, sublength) => typrop' &
	get_exp_type typrop' => ty2' &
	let newexp = Exp.CREF(cr2', ty2') &
	let newprop = Types.PROP(typrop', flg) 
	--------------------------------------
	fix_mod_subscript (cr1, Exp.CREF(cr2,ty2), Types.PROP(typrop,flg)) => (newexp, newprop)
end

relation unlift_array_times : (Types.Type, int) => Types.Type =
	
  axiom	unlift_array_times (ty, 0) => ty

  rule	Types.unlift_array ty => ty' &
	int_sub (cnt,1) => cnt' &
	unlift_array_times (ty', cnt') => ty''
	-------------------
	unlift_array_times (ty, cnt) => ty''
			 
end

relation get_exp_type : Types.Type => Exp.Type =

  axiom	get_exp_type Types.T_INTEGER(_) => Exp.INT
  axiom	get_exp_type Types.T_REAL(_) => Exp.REAL
  axiom	get_exp_type Types.T_STRING(_) => Exp.STRING
  axiom	get_exp_type Types.T_BOOL(_) => Exp.BOOL
  axiom	get_exp_type Types.T_ENUM => Exp.ENUM
  axiom	get_exp_type _ => Exp.OTHER

end


relation get_last_subscripts : Exp.ComponentRef => Exp.Subscript list =

  axiom	get_last_subscripts Exp.CREF_IDENT (n, subs) => subs

  rule	get_last_subscripts rest => subs
	--------------------------------
	get_last_subscripts Exp.CREF_QUAL (n, subs, rest) => subs
end

relation put_last_subscripts : (Exp.ComponentRef, Exp.Subscript list) 
	  => Exp.ComponentRef =

  axiom	put_last_subscripts (Exp.CREF_IDENT(n, subs), subs') 
	  => Exp.CREF_IDENT(n,subs') 

  rule	put_last_subscripts (rest,subs) => rest'
	--------------------------------
	put_last_subscripts (Exp.CREF_QUAL(n, s, rest), subs) => Exp.CREF_QUAL(n,s,rest')
end
*)



(** relation: check_prot
 **
 ** This relation is used to check that a protected element is not
 ** modified.
 **)

relation check_prot : (bool, Types.Mod, Exp.ComponentRef) => () =

  axiom	check_prot(false,_,cref)
	
  axiom check_prot(_,Types.NOMOD,_)

  rule	Print.print_buf "# Trying to modify protected element " &
	Exp.print_component_ref cref & Print.print_buf "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(** relation: make_binding
 **
 ** This relation looks at the equation part of a modification, and if
 ** there is a declaration equation builds a `Types.Binding' for it.
 **
 **)

relation make_binding : (Env.Env, SCode.Attributes, Types.EqMod option)
	  => Types.Binding =

  axiom	make_binding (_,_,NONE) => Types.UNBOUND

(* Numerical values becoms VALBOUND *)
  axiom	make_binding (env, _, SOME(Types.TYPED(Exp.ICONST(i),_))) 
	    => Types.VALBOUND(Values.INTEGER(i))
	    
  axiom make_binding (env, _, SOME(Types.TYPED(Exp.RCONST(r),_)))
	    => Types.VALBOUND(Values.REAL(r))
	    
  axiom	make_binding (env, _, SOME(Types.TYPED(Exp.SCONST(s),_)))
	=> Types.VALBOUND(Values.STRING(s))
	    
  axiom	make_binding (env, _, SOME(Types.TYPED(Exp.BCONST(b),_)))
	=> Types.VALBOUND(Values.BOOL(b))

	(* Constant binding *)
axiom  	make_binding (env, SCode.ATTR(_,_,_,SCode.CONST,_), SOME(Types.TYPED(e,prop)))
	  => Types.EQBOUND(e,true)

	(* default *)

  rule	Exp.simplify(e) => e' 
	-------------------
	make_binding (_,_, SOME(Types.TYPED(e,Types.PROP(t,c)))) => Types.EQBOUND(e',c)

  rule	Debug.fprint("failtrace", "- make_binding failed\n")
	-------------------------------
	make_binding(_,_,_) => fail

end


relation canon_cref_list : (Env, Exp.Exp list) => Exp.Exp list =

  axiom	canon_cref_list (_, []) => []

  rule	canon_cref_list (env, rest) => elist &
	Static.canon_cref (env, cr) => cr'
	---------------------------------
	canon_cref_list (env, Exp.CREF(cr,t)::rest) => Exp.CREF(cr',t)::elist

end

(** LS:
 ** This rule goes through the elements and for each variable, searches the rest
 ** of the list for "equations" which refer to that variable on the LHS, and puts
 ** their RHS in the variable as the initialization expression. This is needed
 ** for modelica output where parameters must be "assigned" (?) during
 ** declaration.
 **)

relation init_vars_modelica_output : DAE.Element list => DAE.Element list =

  rule	init_vars_modelica_output_1 ([], l) => l'
	---------------------------------------
	init_vars_modelica_output l => l'
end


relation init_vars_modelica_output_1 : (DAE.Element list, DAE.Element list) 
	  => DAE.Element list =

  axiom init_vars_modelica_output_1 (done, []) => done

  rule	init_vars_modelica_output_2 (cr, exp, done) => (exp', done') &
	init_vars_modelica_output_2 (cr, exp', todorest) => (exp'', todorest') &
	list_append (done', [DAE.VAR(cr, vk, vd, ty, exp'',inst_dims,start,flow,class)]) => done'' &
	init_vars_modelica_output_1 (done'', todorest') => done'''
	--------------------------------------------------------
	init_vars_modelica_output_1 (done, (v as DAE.VAR(cr, vk, vd, ty, exp,inst_dims,start,flow,class)) :: todorest)
	  => done'''


  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.COMP(n, DAE.DAE(dae'))]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.COMP(n, DAE.DAE(dae)) :: rest)
	  =>  done''

  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.FUNCTION(fpath, DAE.DAE(dae'), ty)]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.FUNCTION(fpath, DAE.DAE(dae), ty) :: rest)
	  =>  done''


  rule	list_append (done, [e]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	---------------------------------------
	init_vars_modelica_output_1 (done,  e :: rest) => done''

end


(** LS:
 ** Search the list for equations with LHS as componentref = cr, remove from the
 ** list and return the RHS of the last of those equations
 **)

relation init_vars_modelica_output_2 : (Exp.ComponentRef, Exp.Exp option, DAE.Element list) 
	  => (Exp.Exp option, DAE.Element list) =

  axiom init_vars_modelica_output_2 (cr, exp, []) => (exp, [])


  rule	Exp.cref_equal (cr, e1cr) => true &
	init_vars_modelica_output_2 (cr, SOME(exp'), rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, DAE.EQUATION(Exp.CREF(e1cr,_ (*Exp.OTHER*)), exp') :: rest)
	  => (exp'', rest')


  rule	Exp.cref_equal (cr, e1cr) => false &
	init_vars_modelica_output_2 (cr, exp, rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, (e1 as DAE.EQUATION(Exp.CREF(e1cr,_(* Exp.OTHER*)), exp')) :: rest)
	  => (exp'', e1 :: rest')

  rule	init_vars_modelica_output_2 (excr, exp, rest) => (exp', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (excr, exp, e1 :: rest) => (exp', e1 :: rest')

end
(** relation: inst_record_constructor_elt
 ** This relation takes an Env and an Element and builds a input argument to a record constructor.
   ** E.g if the element is Real x; the resulting Var is "input Real x;"
**)
relation inst_record_constructor_elt : (Env.Env,SCode.Element) =>
	Types.Var =
	  
  rule	(*Debug.fprint ("recconst", "inst_record_constructor_elt called\n") &*)
	Lookup.lookup_class(env,t,true) => (cl,cenv) &
	(*Debug.fprint ("recconst", "looked up class\n") &*)
	Mod.elab_mod(env,Prefix.NOPRE,mod) => mod' &
	let owncref = Absyn.CREF_IDENT(id,[]) &
	elab_arraydim(env,owncref,dim,NONE,true,NONE) => dimexp &
	(*Debug.fprint ("recconst", "calling inst_var\n") &*)
	inst_var(cenv, ClassInf.FUNCTION(""),mod', Prefix.NOPRE, [], id, cl, attr,
		 dimexp, [], [], false) => (_, _, tp') &
	(*Debug.fprint ("recconst", "Type of argument:") &
	Debug.fcall ("recconst",Types.print_type,tp') &
	Debug.fprint ("recconst","\nMod=") &
	Debug.fcall ("recconst",Mod.print_mod,mod') &*)
	Mod.mod_equation mod' => eq &
	make_binding(env,attr,eq) => bind
	---------------------------------------
	inst_record_constructor_elt (env,
				     SCode.COMPONENT(id,_,repl,prot,
						     attr as
						     SCode.ATTR(dim,f,acc,var,dir),t,mod,bc)) 
	    => Types.VAR(id,Types.ATTR(f,acc,var,Absyn.INPUT),prot,tp',bind)

  rule	Print.print_buf "#Error, inst_record_constructor_elt failed\n  element =" &
	SCode.print_element elt &
	Print.print_buf "\n"
	------------------
	inst_record_constructor_elt(env,elt) => fail
end

relation is_top_call: CallingScope => bool =
 
  axiom	is_top_call TOP_CALL => true
  axiom	is_top_call INNER_CALL => false

end


relation print_compmods:((SCode.Element * Types.Mod) list) => () =

  axiom	print_compmods([]) => ()
  rule	Print.print_buf "Component: " &
	SCode.print_element el &
	Print.print_buf "Modifier: " &
	Mod.print_mod mod &
	Print.print_buf "\n" &
	print_compmods(xs) 
	------------------
	print_compmods((el,mod)::xs) => ()
end
