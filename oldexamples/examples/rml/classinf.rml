(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 classinf.rml
 ** module:      ClassInf
 ** description: Class restrictions
 **
 ** RCS:	 $Id: classinf.rml,v 1.29 2004/09/28 15:04:58 haklu Exp $
 **
 ** This module deals with class inference, i.e. determining if a
 ** class definition adhers to one of the class restrictions, and, if
 ** specifically declared in a restrictied form, if it breaks that
 ** restriction.
 **
 ** The inference is implemented as a finite state machine.  The
 ** relation `start' initializes a new machine, and the relation
 ** `trans' signals transitions in the machine.  Finally, the state
 ** can be checked agains a restriction with the `valid' relation.
 ** 
 **)

module ClassInf :

  with "explode.rml"

  (** - Machine states *)
  datatype State = UNKNOWN       of string
		 | MODEL	 of string
		 | RECORD	 of string
		 | BLOCK	 of string
		 | CONNECTOR	 of string
		 | TYPE		 of string
		 | PACKAGE	 of string
		 | FUNCTION	 of string
		 | ENUMERATION   of string
		 | HAS_EQUATIONS of string
		 | IS_NEW        of string
		 | TYPE_INTEGER  of string
		 | TYPE_REAL     of string
		 | TYPE_STRING   of string
		 | TYPE_BOOL     of string
		 | TYPE_ENUM of string

  (** - Events *)
  datatype Event = FOUND_EQUATION     (* There are definitions inside the current definition *)
		 | NEWDEF	      (* This is not a derived class *)
  (** The `Event' type contains the different events during *)
  (** instantiation that signals a possible machine transition. *)

  (** - Exported relations *)

  relation start : (SCode.Restriction, string (*ident*)) => State

  (** relation: trans
   **
   ** This is the state machine transition relation.  It describes the
   ** transitions between states at different events.
   **)
  relation trans : (State, Event) => State

  (** relation: valid
   **
   ** This is the validity relation which determines if a state is valid
   ** according to one of the restrictions.  This means, that if a class
   ** definition is to be used as, say, a connector, the state of the
   ** state machine is checked against the `SCode.R_CONNECTOR'
   ** restriction using this relation to find out if it is an error to
   ** use this class definition as a connector.
   **)
   relation valid : (State, SCode.Restriction) => ()
  (* `assert_valid' is identical to 'valid'.  The only difference is *)
  (* that it prints an error message when it fails. *)
  relation assert_valid : (State, SCode.Restriction) => ()
  
  (* Succeeds if state is FUNCTION *)
  relation is_function: State => ()

  relation matching_state : (State, State list) => bool

  (* Debug relation *)
  relation print_state : State => ()
  relation get_state_name : State => string

end


with "print.rml"
with "absyn.rml"

(** - Printing *)
(**)
(** Some relations for printing error and debug information about the *)
(** state machine.
 **
 ** The code is excluded from the report.
 **)

(*!ignorecode*)

(** relation: print_state *)

relation print_state : State => () =

  rule	Print.print_buf "UNKNOWN " & Print.print_buf s
	----------------------------
	print_state UNKNOWN(s)

  rule	Print.print_buf "MODEL " & Print.print_buf s
	----------------------------
	print_state MODEL(s)

  rule	Print.print_buf "RECORD " & Print.print_buf s
	----------------------------
	print_state RECORD(s)

  rule	Print.print_buf "BLOCK " & Print.print_buf s
	----------------------------
	print_state BLOCK(s)

  rule	Print.print_buf "CONNECTOR " & Print.print_buf s
	----------------------------
	print_state CONNECTOR(s)

  rule	Print.print_buf "TYPE " & Print.print_buf s
	----------------------------
	print_state TYPE(s)

  rule	Print.print_buf "PACKAGE " & Print.print_buf s
	----------------------------
	print_state PACKAGE(s)

  rule	Print.print_buf "FUNCTION " & Print.print_buf s
	----------------------------
	print_state FUNCTION(s)

  rule	Print.print_buf "TYPE_INTEGER " & Print.print_buf s
	----------------------------
	print_state TYPE_INTEGER(s)

  rule	Print.print_buf "TYPE_REAL " & Print.print_buf s
	----------------------------
	print_state TYPE_REAL(s)

  rule	Print.print_buf "TYPE_STRING " & Print.print_buf s
	----------------------------
	print_state TYPE_STRING(s)

  rule	Print.print_buf "TYPE_BOOL " & Print.print_buf s
	----------------------------
	print_state TYPE_BOOL(s)

  rule	Print.print_buf "IS_NEW " & Print.print_buf s
	----------------------------
	print_state IS_NEW(s)

  rule	Print.print_buf "HAS_EQUATIONS " & Print.print_buf s
	----------------------------
	print_state HAS_EQUATIONS(s)

end

relation get_state_name : State => string =

  axiom	get_state_name UNKNOWN(s)	=> s
  axiom	get_state_name MODEL(s)		=> s
  axiom	get_state_name RECORD(s)	=> s
  axiom	get_state_name BLOCK(s)		=> s
  axiom	get_state_name CONNECTOR(s)	=> s
  axiom	get_state_name TYPE(s)		=> s
  axiom	get_state_name PACKAGE(s)	=> s
  axiom	get_state_name FUNCTION(s)	=> s
  axiom	get_state_name TYPE_INTEGER(s)	=> s
  axiom	get_state_name TYPE_REAL(s)	=> s
  axiom	get_state_name TYPE_STRING(s)	=> s
  axiom	get_state_name TYPE_BOOL(s)	=> s
  axiom	get_state_name IS_NEW(s)	=> s
  axiom	get_state_name HAS_EQUATIONS(s)	=> s

end


(** relation: print_event *)

relation print_event : Event => () =

  rule	Print.print_buf "FOUND_EQUATION"
	----------------------
	print_event FOUND_EQUATION

  rule	Print.print_buf "NEWDEF"
	--------------
	print_event NEWDEF

end

(*!includecode*)

(** - Transitions *)

(** relation: start
 **
 ** This is the  state machine initialization relation.
 **)

relation start : (SCode.Restriction, string) => State =

  axiom	start (SCode.R_CLASS, s) 	       => UNKNOWN(s)
  axiom	start (SCode.R_MODEL, s) 	       => MODEL(s)
  axiom	start (SCode.R_RECORD, s)            => RECORD(s)
  axiom	start (SCode.R_BLOCK, s)             => BLOCK(s)
  axiom	start (SCode.R_CONNECTOR, s)         => CONNECTOR(s)
  axiom	start (SCode.R_TYPE, s)              => TYPE(s)
  axiom	start (SCode.R_PACKAGE, s)           => PACKAGE(s)
  axiom	start (SCode.R_FUNCTION, s)          => FUNCTION(s)
  axiom	start (SCode.R_EXT_FUNCTION, s)      => FUNCTION(s)
  axiom start (SCode.R_ENUMERATION,s)	     => ENUMERATION(s)
  axiom	start (SCode.R_PREDEFINED_INT, s)    => TYPE_INTEGER(s)
  axiom	start (SCode.R_PREDEFINED_REAL, s)   => TYPE_REAL(s)
  axiom	start (SCode.R_PREDEFINED_STRING, s) => TYPE_STRING(s)
  axiom	start (SCode.R_PREDEFINED_BOOL, s)   => TYPE_BOOL(s)
  axiom	start (SCode.R_PREDEFINED_ENUM, s)   => TYPE_ENUM(s)

end

(** relation: trans
 **
 ** This is the state machine transition relation.  It describes the
 ** transitions between states at different events.
 **)

relation trans : (State, Event) => State =

	(** Event `NEWDEF' *)

  axiom	trans(UNKNOWN(s),        NEWDEF) => IS_NEW(s)
  axiom	trans(MODEL(s),          NEWDEF) => MODEL(s)
  axiom	trans(RECORD(s),         NEWDEF) => RECORD(s)
  axiom	trans(BLOCK(s),          NEWDEF) => BLOCK(s)
  axiom	trans(CONNECTOR(s),      NEWDEF) => CONNECTOR(s)

  rule	Print.print_buf "# In class " & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "# 'type' can only be derived from predefined types\n"
	-----------------------------------------------
	trans(TYPE(s),           NEWDEF) => fail

  axiom	trans(PACKAGE(s),        NEWDEF) => PACKAGE(s)
  axiom	trans(FUNCTION(s),       NEWDEF) => FUNCTION(s)
  axiom trans(ENUMERATION(s),	 NEWDEF) => ENUMERATION(s)
  axiom	trans(IS_NEW(s),         NEWDEF) => IS_NEW(s)
  axiom	trans(TYPE_INTEGER(s),   NEWDEF) => TYPE_INTEGER(s)
  axiom	trans(TYPE_REAL(s),      NEWDEF) => TYPE_REAL(s)
  axiom	trans(TYPE_STRING(s),    NEWDEF) => TYPE_STRING(s)
  axiom	trans(TYPE_BOOL(s),      NEWDEF) => TYPE_BOOL(s)
  axiom trans(TYPE_ENUM(s),NEWDEF) => TYPE_ENUM(s)
	(** Event `FOUND_EQUATION' *)

  axiom	trans(UNKNOWN(s),        FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(IS_NEW(s),         FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(MODEL(s),          FOUND_EQUATION) => MODEL(s)

  rule	Print.print_buf "# In class " & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "# Equations not allowed in records\n"
	-----------------------------------------------
	trans(RECORD(s),         FOUND_EQUATION) => fail

  axiom	trans(BLOCK(s),          FOUND_EQUATION) => BLOCK(s)

  rule	Print.print_buf "#-- In class " & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "#-- Equations not allowed in connectors\n"
	-----------------------------------------------
	trans(CONNECTOR(s),      FOUND_EQUATION) => fail

  axiom	trans(TYPE(s),           FOUND_EQUATION) => fail (* CORRECT? *)
  axiom	trans(PACKAGE(s),        FOUND_EQUATION) => fail
  axiom	trans(FUNCTION(s),       FOUND_EQUATION) => fail
  axiom	trans(HAS_EQUATIONS(s),  FOUND_EQUATION) => HAS_EQUATIONS(s)

  rule	Print.print_buf "- trans failed: " & print_state st &
 	Print.print_buf ", " & print_event ev & Print.print_buf "\n"
	--------------------------------------------------------
	trans(st, ev) => fail

end

(** relation: valid
 **
 ** This is the validity relation which determines if a state is valid
 ** according to one of the restrictions.  This means, that if a class
 ** definition is to be used as, say, a connector, the state of the
 ** state machine is checked against the `SCode.R_CONNECTOR'
 ** restriction using this relation to find out if it is an error to
 ** use this class definition as a connector.
 **)

relation valid : (State, SCode.Restriction) => () =

  axiom	valid(UNKNOWN(s), _)

  axiom	valid(IS_NEW(s),        SCode.R_CLASS)
  axiom	valid(HAS_EQUATIONS(s), SCode.R_CLASS)

  axiom	valid(MODEL(s),         SCode.R_MODEL)
  axiom	valid(IS_NEW(s),        SCode.R_MODEL)
  axiom	valid(HAS_EQUATIONS(s), SCode.R_MODEL)

  axiom	valid(RECORD(s),        SCode.R_RECORD)
  axiom	valid(IS_NEW(s),        SCode.R_RECORD)

  axiom	valid(BLOCK(s),         SCode.R_BLOCK)
  axiom	valid(HAS_EQUATIONS(s), SCode.R_BLOCK)

  axiom	valid(CONNECTOR(_),     SCode.R_CONNECTOR)
  axiom	valid(IS_NEW(_),        SCode.R_CONNECTOR)
  axiom valid(TYPE_INTEGER(_),	SCode.R_CONNECTOR)
  axiom valid(TYPE_REAL(_),	SCode.R_CONNECTOR)
  axiom valid(TYPE_STRING(_),	SCode.R_CONNECTOR)
  axiom valid(TYPE_BOOL(_),	SCode.R_CONNECTOR)

  axiom	valid(TYPE(s),          SCode.R_TYPE)
  axiom	valid(TYPE_INTEGER(s),  SCode.R_TYPE)
  axiom	valid(TYPE_REAL(s),     SCode.R_TYPE)
  axiom	valid(TYPE_STRING(s),   SCode.R_TYPE)
  axiom	valid(TYPE_BOOL(s),     SCode.R_TYPE)

  axiom	valid(IS_NEW(s),        SCode.R_PACKAGE)
  axiom	valid(PACKAGE(s),       SCode.R_PACKAGE)

  axiom	valid(IS_NEW(s),        SCode.R_FUNCTION)
  axiom	valid(FUNCTION(s),      SCode.R_FUNCTION)

end

(** relation: assert_valid
 **
 ** This relation has the same semantical meaning as the relation
 ** `valid'.  However, it prints an error message when it fails.
 **)

relation assert_valid : (State, SCode.Restriction) => () =

  rule	valid(st,re)
	------------
	assert_valid(st,re)

  rule	Print.print_buf "# Restriction violation: " & print_state st &
	Print.print_buf " is not a " & SCode.print_restr re & Print.print_buf "\n" 
	-------------------------------------------
	assert_valid(st,re) => fail

end


relation matching_state : (State, State list) => bool =

  axiom	matching_state (st, []) => false

  axiom	matching_state (UNKNOWN(_),	  UNKNOWN(_)::rest) => true
  axiom matching_state (MODEL(_),	  MODEL(_)::rest) => true
  axiom matching_state (RECORD(_),	  RECORD(_)::rest) => true
  axiom matching_state (BLOCK(_),	  BLOCK(_)::rest) => true
  axiom matching_state (CONNECTOR(_),	  CONNECTOR(_)::rest) => true
  axiom matching_state (TYPE(_),	  TYPE(_)::rest) => true
  axiom matching_state (PACKAGE(_),	  PACKAGE(_)::rest) => true
  axiom matching_state (FUNCTION(_),	  FUNCTION(_)::rest) => true
  axiom matching_state (ENUMERATION(_),	  ENUMERATION(_)::rest) => true
  axiom matching_state (HAS_EQUATIONS(_), HAS_EQUATIONS(_)::rest) => true
  axiom matching_state (IS_NEW(_),	  IS_NEW(_)::rest) => true
  axiom matching_state (TYPE_INTEGER(_),  TYPE_INTEGER(_)::rest) => true
  axiom matching_state (TYPE_REAL(_),	  TYPE_REAL(_)::rest) => true
  axiom matching_state (TYPE_STRING(_),	  TYPE_STRING(_)::rest) => true
  axiom matching_state (TYPE_BOOL(_),	  TYPE_BOOL(_)::rest) => true
  axiom matching_state (TYPE_ENUM(_),	  TYPE_ENUM(_)::rest) => true

  rule	matching_state (st, rest) => res
	--------------------------------
	matching_state (st, first::rest) => res
end


relation is_function: State => () =
  axiom is_function FUNCTION(_) => ()
end
