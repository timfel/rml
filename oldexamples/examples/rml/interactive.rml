(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(* $Id: interactive.rml,v 1.137 2005/01/20 08:24:07 x02lucpo Exp $ *)

(**
 ** This module contain functionality for model management, expression evaluation, etc. 
 ** in the interactive environment.
 ** The module defines a symboltable used in the interactive environment containing:
 ** - Modelica models (described using Absyn AST)
 ** - Variable bindings
 ** - Compiled functions (so they do not need to be recompiled)
 ** - Instantiated classes (that can be reused, not impl. yet)
 ** - Modelica models in SCode form (to speed up instantiation. not impl. yet)
 **)

module Interactive:
  with "absyn.rml"
  with "explode.rml" 
  with "dae.rml" 							  
  with "types.rml"
  with "values.rml"
  with "env.rml"

  datatype InteractiveStmt = IALG of Absyn.AlgorithmItem
			   | IEXP of Absyn.Exp
  datatype InteractiveStmts = ISTMTS of InteractiveStmt list * 
					bool (* true if output result == no semicolon*)
							  
  datatype InstantiatedClass =  INSTCLASS of Absyn.Path * (* The F.Q.name of the inst:ed class*)
					     DAE.Element list (* The list of DAE elements *)
						* Env.Env  (* The env of the inst:ed class*)

  datatype InteractiveVariable = IVAR of Absyn.Ident * (* The variable identifier *)
					 Values.Value *  (* The expression containing the value *)
					 Types.Type  (* The type of the expression *)


  datatype InteractiveSymbolTable = SYMBOLTABLE of Absyn.Program * (*The ast*)
						   SCode.Program * (* The exploded ast *)
						   InstantiatedClass list * (* List of instantiated classes*)
						   InteractiveVariable list * (*List of variables with values*)  
  						   (Absyn.Path * Types.Type) list (* List of compiled functions, F.Q name + type*)

  relation evaluate: (InteractiveStmts, InteractiveSymbolTable, bool) 
	  => (string,InteractiveSymbolTable) 

  relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program
  relation update_scope: (Absyn.Program, InteractiveVariable list) => InteractiveVariable list
  relation add_component: (string,Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program,string)
  relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int
  relation remove_compiled_functions: (Absyn.Program, (Absyn.Path * Types.Type) list)
	    => (Absyn.Path * Types.Type) list
  relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env 
  relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) => Absyn.Class 

  relation get_type_of_variable: (Absyn.Ident, InteractiveVariable list) => Types.Type 
  relation add_instantiated_class: (InstantiatedClass list, InstantiatedClass) => InstantiatedClass list 
  relation get_instantiated_class: (InstantiatedClass list, Absyn.Path) => InstantiatedClass 
  relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	  => InteractiveSymbolTable
  relation add_scope: (Absyn.Program, InteractiveVariable list) => Absyn.Program 
  relation is_primitive: (Absyn.ComponentRef, Absyn.Program) => bool  


  relation get_elementitems_in_class: (Absyn.Class) => Absyn.ElementItem list 
  relation get_components_in_class: (Absyn.Class) => Absyn.Element list 
  relation get_classnames_in_elts: (Absyn.ElementItem list) => string list
  relation get_component_name_and_type_and_comment: (Absyn.Element,Env.Env) => string list
  relation get_components: (Absyn.ComponentRef,Absyn.Program) => string 
  relation get_componentitems_name: Absyn.ComponentItem list => string list 
end


with "dump.rml"
with "debug.rml"
with "rtopts.rml"
with "util.rml"
with "parse.rml"
with "prefix.rml"
with "mod.rml"
with "lookup.rml"
with "classinf.rml"
with "exp.rml"
with "inst.rml"
with "staticexp.rml"							  
with "modutil.rml"
with "codegen.rml"
with "print.rml"
with "system.rml"
with "classloader.rml"
with "ceval.rml"

val Placement_records = "record Transformation Real x=0.0; Real y=0.0; Real scale=1.0; Real aspectRatio=1.0; Boolean flipHorizontal=false; Boolean flipVertical=false; Real rotation=0.0; end Transformation; record Placement Boolean visible=true; Transformation transformation; Transformation iconTransformation; end Placement;" 

val Line_records = "type LinePattern=enumeration(None,Solid,Dash,Dot,DashDot,DashDotDot); type Arrow=enumeration(None,Open,Filled,Half); record Line  Boolean visible=true;  Real points[:,2]; Integer color[3]={0,0,0}; LinePattern pattern = LinePattern.Solid; Real thickness=0.25; Arrow arrow[2]={Arrow.None,Arrow.None};  Real arrowSize = 3.0;  Boolean smooth=false; end Line;"

val Icon_records = "record GraphicItem Boolean visible=true; end GraphicItem; record CoordinateSystem Real extent[2,2]; end CoordinateSystem; record Icon CoordinateSystem coordinateSystem(extent ={{-10.0, -10.0}, {10.0, 10.0}}); /*GraphicItem graphics[:];*/ end Icon;"
val Diagram_records = "record GraphicItem Boolean visible=true; end GraphicItem; record CoordinateSystem Real extent[2,2]; end CoordinateSystem; record Diagram CoordinateSystem coordinateSystem(extent ={{-100.0, -100.0}, {100.0, 100.0}}); /*GraphicItem graphics[:];*/ end Diagram;"

(* This variable contains all records needed for the graphical primitives, such as Line, Ellipse, etc. *)
val Graphics_records = "type LinePattern=enumeration(None,Solid,Dash,Dot,DashDot,DashDotDot); type Arrow=enumeration(None,Open,Filled,Half); type FillPattern=enumeration(None,Solid,Horizontal,Vertical,Cross,Forward,Backward,CrossDiag,HorizontalCylinder,VerticalCylinder,Sphere); type BorderPattern=enumeration(None,Raised,Sunken,Engraved); type TextStyle=enumeration(Bold,Italic,Underline); record Line  Boolean visible=true;  Real points[:,2]; Integer color[3]={0,0,0}; LinePattern pattern = LinePattern.Solid; Real thickness=0.25; Arrow arrow[2]={Arrow.None,Arrow.None};  Real arrowSize = 3.0;  Boolean smooth=false; end Line; record Polygon Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; Real points[:,2]; Boolean smooth=false; end Polygon; record Rectangle Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; BorderPattern borderPattern=BorderPattern.None; Real extent[2,2]; Real radius=0.0; end Rectangle; record Ellipse Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; Real extent[2,2]; end Ellipse; record Text Boolean visible=true;Integer lineColor[3]={0,0,0};Integer fillColor[3]={0,0,0}; LinePattern pattern=LinePattern.Solid; FillPattern fillPattern=FillPattern.None; Real lineThickness=0.25; Real extent[2,2]; String textString; Real fontSize = 0.0; String fontName=\"\"; TextStyle textStyle[:]; end Text; record Bitmap Boolean visible=true; Real extent[2,2]; String fileName=\"\"; String imageSource=\"\"; end Bitmap;"

(** relation: evaluate
 ** This relation evaluates expressions feeded interactively to the compiler.
**)

relation evaluate: (InteractiveStmts, InteractiveSymbolTable, bool) 
	  => (string,InteractiveSymbolTable) =

  rule	evaluate2(ISTMTS([x],true),st) => (res,newst)
	----------------------------
	evaluate (ISTMTS([x],true),st,false) => ("",newst)

  rule	(* Verbose, semicolon off *)
	evaluate2(ISTMTS([x],false),st) => (res,newst)
	----------------------------
	evaluate (ISTMTS([x],true),st,true) => (res,newst)

  rule	evaluate2(ISTMTS([x],false),st) => (res,newst)
	----------------------------
	evaluate (ISTMTS([x],false),st,verbose) => (res,newst)

  rule	evaluate2(ISTMTS([x],sc),st) => (res,newst) &
	evaluate(ISTMTS(xs,sc),newst,false) => (res,newst') 
	------------------------------------------
	evaluate (ISTMTS(x::xs,sc),st,false) => (res,newst')

  rule	evaluate2(ISTMTS([x],sc),st) => (res,newst) &
	evaluate(ISTMTS(xs,sc),newst,true) => (res2,newst') &
	Util.string_append_list([res,res2]) => res'
	------------------------------------------
	evaluate (ISTMTS(x::xs,sc),st,true) => (res',newst')
end

relation evaluate2:  (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable) =

  rule	get_variable_names(vars) => vars &
	string_append(vars,"\n") => str
	--------------------------
	evaluate2(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("listVariables",_),Absyn.FUNCTIONARGS([],[])))],_),st as SYMBOLTABLE(_,_,_,vars,_))
	  => (str,st)

  rule	evaluate_graphical_api(stmts,st) => (str,newst)
	----------------------------------------------------
	evaluate2(stmts as ISTMTS([IEXP(Absyn.CALL(_,_))],_),st) => (str,newst)
	
  rule	evaluate_expr(exp,st) => (s1,newst) &
	string_append(s1,"\n") => str
	------------------------------------------------------
	evaluate2(stmts as ISTMTS([exp],_),st) => (str,newst)
	
  axiom	evaluate2(_,st) => ("Not implemented yet\n",st)
end


(** relation: evaluate_expr
 ** This relation takes an 'InteractiveStmt´ and a symboltable and 
 ** evaluates the expression using Staticexp.
 **)
		 
relation evaluate_expr: (InteractiveStmt, InteractiveSymbolTable) =>
	(string,InteractiveSymbolTable) =
	
  rule	build_env_from_symboltable(st) => env &	
	Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
	Ceval.ceval (env,sexp,true,SOME(st'),NONE) => (value,SOME(st'')) &
	Values.val_string value =>  str
	-------------------------------
	evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_,_)) => (str,st'')

  rule	build_env_from_symboltable(st) => env &	
	not Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
	Print.print_buf "# Error determing type of expression." 
	-------------------------------
	evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_,_)) => fail
	
  rule	build_env_from_symboltable(st) => env &	
	Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
	not Ceval.ceval (env,sexp,true,SOME(st'),NONE) => (_,_) &
	Print.print_buf "# Constant evaluating of expression failed.\n" 
	-------------------------------
	evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_,_)) => fail

  rule	build_env_from_symboltable(st) => env &	
	Static.elab_exp(env,cond,true,SOME(st)) 
	  => (econd,prop,SOME(st')) &
	Ceval.ceval (env,econd,true,SOME(st'),NONE) 
	  => (Values.BOOL(true),SOME(st'')) 
	-----------------------------------------------
	evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),Absyn.FUNCTIONARGS([cond,msg],_)),_)),st as SYMBOLTABLE(p,_,_,_,_))
	    => ("", st'')
	
  rule	build_env_from_symboltable(st) => env &	
	Static.elab_exp(env,msg,true,SOME(st)) 
	  => (msg',prop,SOME(st')) &
	Ceval.ceval (env,msg',true,SOME(st'),NONE) 
	  => (Values.STRING(str),SOME(st'')) 
	-----------------------------------------------
	evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),Absyn.FUNCTIONARGS([cond,msg],_)),_)),st as SYMBOLTABLE(p,_,_,_,_))
	    => (str, st'')

  rule	build_env_from_symboltable(st) => env &
	Static.elab_exp(env,exp,true,SOME(st)) => (sexp,Types.PROP(t,_),SOME(st'))  &
	Ceval.ceval(env,sexp,true,SOME(st'),NONE) => (value,SOME(st'')) &
	Values.val_string value =>  str &
	add_var_to_symboltable(ident,value,t,st'') => newst	
	-----------------------------------------------
	evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(Absyn.CREF_IDENT(ident,[]),exp),_)),st as SYMBOLTABLE(p,_,_,_,_)) 
	    => (str, newst)

       (* Since expressions cannot be tuples an empty string is returned *)
  rule	build_env_from_symboltable(st) => env &
	Static.elab_exp(env,rexp,true,SOME(st)) => (srexp,rprop,SOME(st'))	&
	Types.get_prop_type rprop => ((Types.T_TUPLE(types),_)) &
	Util.list_map(crefexps, get_ident_from_crefexp) => idents &
	Ceval.ceval(env,srexp,true,SOME(st'),NONE) => (Values.TUPLE(values), SOME(st'')) &
	add_vars_to_symboltable(idents,values,types,st'') => newst
	-----------------------------------------------
	evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(crefexps),rexp),_)),st as SYMBOLTABLE(p,_,_,_,_)) 
	    => ("", newst)
	
  rule	Print.get_string() => s1 & Print.clear_buf() & string_append("Error evaluating expr.\n",s1) => str &
	Debug.fprint ("failtrace", "#-- evaluate_expr failed:") &
	Debug.fcall ("failtrace", Dump.dump_istmt, ISTMTS([stmt], true)) &
	Debug.fprintln ("failtrace", "\n")
	-----------------------------
	evaluate_expr(stmt,st) => (str,st)
end

relation get_ident_from_crefexp : Absyn.Exp => Absyn.Ident =

  axiom	get_ident_from_crefexp Absyn.CREF(Absyn.CREF_IDENT(id, _)) => id
	
  rule	Print.print_buf "#-- Not a component reference in tuple assignment:\n#-- " &
	Dump.print_exp_str exp => str &
	Print.print_buf str &
	Print.print_buf "\n"
	--------------------
	get_ident_from_crefexp exp => fail
end


relation get_variable_names: (InteractiveVariable list) => string =

  rule	get_variable_list_str(vars) => strlst &
	Util.string_delimit_list(strlst,", ") => str &
	Util.string_append_list(["{",str,"}"]) => res
	---------------------------------------------
	get_variable_names(vars) => res
end

relation get_variable_list_str: (InteractiveVariable list) => string list =
	
  axiom	get_variable_list_str([]) => []
	
  rule	get_variable_list_str(vs)=> res 
	----------------------------
	get_variable_list_str(IVAR(p,_,_)::vs) => p::res
end

relation get_type_of_variable: (Absyn.Ident, InteractiveVariable list) => Types.Type =
  axiom get_type_of_variable(id,[]) => fail
	
  rule	varid = id
	----------------------------------------------
	get_type_of_variable (varid,IVAR(id,_,tp)::rest) => tp 
	
  rule	not varid = id &
	get_type_of_variable(varid,rest) => tp
	----------------------------------------------
	get_type_of_variable (varid,IVAR(id,_,_)::rest) => tp 
end

relation add_vars_to_symboltable: (Absyn.Ident list, Values.Value list,
				   Types.Type list, InteractiveSymbolTable) 
	  => InteractiveSymbolTable =
	  
  axiom	add_vars_to_symboltable ([],_,_,st) => st
	
  rule	add_var_to_symboltable (id, v, t, st) => st' &
	add_vars_to_symboltable(idrest, vrest, trest, st') => st''
	-------------------------------------------------------------
	add_vars_to_symboltable (id::idrest, v::vrest, t::trest, st) => st''
end


relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	  => InteractiveSymbolTable =
	  
  rule	add_var_to_varlist(ident,v,t,vars) => vars'
	----------------------------
	add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,id,vars,cf))
	  => SYMBOLTABLE(p,sp,id,vars',cf)
end

relation add_var_to_varlist: (Absyn.Ident, Values.Value, Types.Type,
			      InteractiveVariable list) 
	  => InteractiveVariable list =
  rule	ident = id2
	-----------
	add_var_to_varlist(ident,v,t,IVAR(id2,_,_)::rest) 
	    => IVAR(ident,v,t)::rest

  rule	not ident = id2 &
	add_var_to_varlist(ident,v,t,rest) => rest'
	 ------------------------------------
	add_var_to_varlist(ident,v,t,IVAR(id2,val2,t2)::rest)
	    => IVAR(id2,val2,t2)::rest'

  axiom	add_var_to_varlist(ident,v,t,[]) => [IVAR(ident,v,t)]
end

relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env =
	
  rule	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	add_vars_to_env(vars,env) => env'
	------------------------------------------
	build_env_from_symboltable(SYMBOLTABLE(p,sp,ic,vars,cf)) => env'
end

relation add_vars_to_env: (InteractiveVariable list, Env.Env) => Env.Env =

  rule	Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	Env.update_frame_v(env,
	    Types.VAR(
		id,
		Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),
		false,
		tp,
		Types.VALBOUND(v)
	    ),false) => env' &
	add_vars_to_env(rest,env') => env''
	---------------------------------------
	add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''
	
  rule	not Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	Env.extend_frame_v(env,
	    Types.VAR(
		id,
		Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),
		false,
		tp,
		Types.VALBOUND(v)
	    ),NONE,false) => env' &
	add_vars_to_env(rest,env') => env''
	---------------------------------------
	add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''

  axiom	 add_vars_to_env([],env) => env

end

(** relation: evaluate_graphical_api
 ** This relation evaluates all primitives in the graphical api.
 **)

relation evaluate_graphical_api: (InteractiveStmts, InteractiveSymbolTable) => 
	(string, InteractiveSymbolTable) = 			

  rule update_program(
      Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE))],Absyn.TOP),
      p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv,cf) &
	string_append(name,"\n") => resstr
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("createModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_))],[])))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true\n",newst)
	    
  rule	Absyn.cref_to_path(path) => path' &
	Absyn.path_last_ident(path') => name &
	Absyn.strip_last(path') => wpath &
	update_program(
	    Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE))],Absyn.WITHIN(wpath)),p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv,cf)
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("createModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(path as Absyn.CREF_QUAL(_,_,_))],[])))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true\n",newst)

  rule	componentref_to_path(cr) => path &
	update_program(
	    Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE))],Absyn.WITHIN(path)),
	    p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv,cf) &
	string_append(name,"\n") => resstr
	---------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("newModel",_),
		Absyn.FUNCTIONARGS( [Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(cr)] , [])))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true\n",newst)


	rule	delete_class(cr,p) => (resstr, newp)
	---------------------------------------------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("deleteClass",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)], [])))],_
		),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))
	

  rule	add_component(name,tp,model,nargs,p) => (newp,resstr)
	& Print.get_string() => str & string_append(resstr,str) => resstr'
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("addComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],nargs)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true\n",SYMBOLTABLE(newp,s,ic,iv,cf))

  rule	(*delete_component(name,model,p) => (newp,resstr) &
	add_component(name,tp,model,nargs,newp) => (newp2,resstr)*)
	update_component(name,tp,model,nargs,p) =>(newp, res)
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("updateComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],nargs)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (res, SYMBOLTABLE(newp,s,ic,iv,cf))

  rule	delete_component(name,model,p) => (newp,resstr)
	& Print.get_string() => str & string_append(resstr,str) => resstr'
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("deleteComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(model)],nargs)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true\n",SYMBOLTABLE(newp,s,ic,iv,cf))

  rule	add_class_annotation(cr,nargs,p) => newp &
	let newst = SYMBOLTABLE(newp,s,ic,iv,cf) 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("addClassAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],nargs)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true\n",newst)

  rule	get_component_count(cr,p) => count &
	int_string count => str &
	string_append(str,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getComponentCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_component(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponent",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_components(cr,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getComponents",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_component_annotations(cr,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getComponentAnnotations",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_component_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponentAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_component_modification(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthComponentModification",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_inheritance_count(cr,p) => count &
	int_string count => str &
	string_append(str,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getInheritanceCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_inherited_class(cr,n,p) => str &
	string_append(str,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthInheritedClass",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_connection_count(cr,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getConnectionCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_connection(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnection",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	add_connection(cr,c1,c2,nargs,p) => (s1,newp) &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("addConnection",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],nargs)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

  rule	delete_connection(cr,c1,c2,p) => (s1,newp) &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("deleteConnection",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

  rule	delete_connection(cr,c1,c2,p) => (s1,newp) &
	add_connection(cr,c1,c2,nargs,newp) => (s2,newp') &
	string_append(s2,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("updateConnection",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],nargs)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp',s,ic,iv,cf))

  rule	get_nth_connection_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnectionAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_connector_count(cr,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getConnectorCount",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_connector(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnector",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_nth_connector_icon_annotation(cr,p,n) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getNthConnectorIconAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)


  rule	Absyn.cref_to_path(cr) => path &
	get_icon_annotation(path,p) => s1 &
	string_append(s1,"\n") => resstr
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getIconAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_diagram_annotation(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getDiagramAnnotation",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_packages_in_path(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getPackages",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_top_packages(p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getPackages",_),
		Absyn.FUNCTIONARGS([],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	Absyn.cref_to_path(cr) => path &
	get_classnames_in_path(path,p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getClassNames",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	get_top_classnames(p) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("getClassNames",_),
		Absyn.FUNCTIONARGS([],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_primitive(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isPrimitive",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_type(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isType",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_connector(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isConnector",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_model(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_record(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isRecord",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_block(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isBlock",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_function(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isFunction",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_package(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isPackage",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_class(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isClass",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_parameter(cr,class,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isParameter",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_protected(cr,class,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isProtected",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	is_constant(cr,class,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("isConstant",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	exist_class(cr,p) => b1 &
	Util.bool_string(b1) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("existClass",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	exist_class(cr,p) => b1 &
	is_model(cr,p) => b2 &
	bool_and(b1,b2) => res &
	Util.bool_string(res) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("existModel",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

  rule	exist_class(cr,p) => b1 &
	is_package(cr,p) => b2 &
	bool_and(b1,b2) => res &
	Util.bool_string(res) => s1 &
	string_append(s1,"\n") => resstr 
	-----------------------
	evaluate_graphical_api(
	    ISTMTS([IEXP(Absyn.CALL(
		Absyn.CREF_IDENT("existPackage",_),
		Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	    ),
	    st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

end

relation componentref_to_path: Absyn.ComponentRef => Absyn.Path = 

  axiom componentref_to_path(Absyn.CREF_IDENT(ident,_)) => Absyn.IDENT(ident)
	
  rule	componentref_to_path(x) => px
	-----------------------------
	componentref_to_path(Absyn.CREF_QUAL(id,_,x)) => Absyn.QUALIFIED(id,px)
end	

(** relation: is_primitive 
 ** This relation takes a component reference and a program. 
 ** It returns the true if the refrenced type is a primitive type, otherwise it returns 
 ** false.
**)
relation is_primitive: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => class &
	is_primitive_class(class,p) => res
	----------------------------
	is_primitive(cr,p) => res

(* Instead of elaborating and lookup these in env, we optimize a bit and just return true for these *)
  axiom	is_primitive(Absyn.CREF_IDENT("Real",_),_) => true
  axiom	is_primitive(Absyn.CREF_IDENT("Integer",_),_) => true
  axiom	is_primitive(Absyn.CREF_IDENT("String",_),_) => true
  axiom	is_primitive(Absyn.CREF_IDENT("Boolean",_),_) => true
  axiom	is_primitive(_,_) => false
end

(** relation: delete_class
 ** This relation takes a component reference and a program. 
 ** It deletes the class specified by the component reference from the given program.
 **)
relation delete_class: (Absyn.ComponentRef, Absyn.Program) => (string, Absyn.Program) =

  rule	(* Class inside another class, inside another class *)
	Absyn.cref_to_path(class) => cpath &
	Absyn.strip_last(cpath) => parentcpath &
	Absyn.strip_last(parentcpath) => parentparentcpath &
	get_pathed_class_in_program(cpath, p) => cdef &
	get_pathed_class_in_program(parentcpath, p) => parentcdef &
  remove_inner_class(cdef, parentcdef) => parentcdef' &
	update_program(Absyn.PROGRAM([parentcdef'], Absyn.WITHIN(parentparentcpath)), p) => newp
	----------------------------------------------------------------------------
	delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", newp)

  rule	(* Class inside other class *)
	Absyn.cref_to_path(class) => cpath &
	Absyn.strip_last(cpath) => parentcpath &
	get_pathed_class_in_program(cpath, p) => cdef &
	get_pathed_class_in_program(parentcpath, p) => parentcdef &
  remove_inner_class(cdef, parentcdef) => parentcdef' &
	update_program(Absyn.PROGRAM([parentcdef'], Absyn.TOP), p) => newp
	----------------------------------------------------------------------------
	delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", newp)

  rule	(* Top level class *)
	Absyn.cref_to_path(class) => cpath &
	get_pathed_class_in_program(cpath, p) => cdef &
	delete_class_from_list(cdef, clist) => clist'
	---------------------------------------------------------------------------------------
	delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", Absyn.PROGRAM(clist', w))

  axiom	delete_class(_, p) => ("false",p)	
end

relation delete_class_from_list: (Absyn.Class, Absyn.Class list)
	 => Absyn.Class list =
	
	(* Empty list *)
  axiom	 delete_class_from_list(_,[]) => []

  rule name = name2
	-------------------------------------------------------------------------------------------
  delete_class_from_list(Absyn.CLASS(name,_,_,_,_,_), Absyn.CLASS(name2,_,_,_,_,_)::xs) => xs

  rule not name = name2 &
  delete_class_from_list(cdef, xs) => res
	--------------------------------------
  delete_class_from_list(cdef as Absyn.CLASS(name,_,_,_,_,_), (x as Absyn.CLASS(name2,_,_,_,_,_))::xs) => x::res

  rule delete_class_from_list(cdef, xs) => res
	--------------------------------------
  delete_class_from_list(cdef as Absyn.CLASS(name,_,_,_,_,_), x::xs) => x::res
end

(** relation: is_type 
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "type", otherwise it returns 
 ** false.
**)
relation is_type: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_TYPE,_) 
	----------------------------
	is_type(cr,p) => true

  axiom	is_type(cr,p) => false
end

(** relation: is_connector
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "connector", otherwise it returns  
 ** false.
**)
relation is_connector: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_) 
	----------------------------
	is_connector(cr,p) => true

  axiom	is_connector(cr,p) => false
end

(** relation: is_model
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "model", otherwise it returns 
 ** false.
**)
relation is_model: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_MODEL,_) 
	----------------------------
	is_model(cr,p) => true

  axiom	is_model(cr,p) => false
end

(** relation: is_record
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "record", otherwise it returns 
 ** false.
**)
relation is_record: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_RECORD,_) 
	----------------------------
	is_record(cr,p) => true

  axiom	is_record(cr,p) => false
end

(** relation: is_block
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "block", otherwise it returns 
 ** false.
**)
relation is_block: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_BLOCK,_) 
	----------------------------
	is_block(cr,p) => true

  axiom	is_block(cr,p) => false
end

(** relation: is_function
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "function", otherwise it returns
 ** false.
**)
relation is_function: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_FUNCTION,_) 
	----------------------------
	is_function(cr,p) => true

  axiom	is_function(cr,p) => false
end

(** relation: is_package
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "package", otherwise it returns 
 ** false.
**)
relation is_package: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_PACKAGE,_) 
	----------------------------
	is_package(cr,p) => true

  axiom	is_package(cr,p) => false
end

(** relation: is_class
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "class", otherwise it returns 
 ** false.
**)
relation is_class: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_CLASS,_) 
	----------------------------
	is_class(cr,p) => true

  axiom	is_class(cr,p) => false
end


(** relation: is_parameter
 ** This relation takes a class and a component reference and a program
 ** and returns true if the component referenced is a parameter.
**)
relation is_parameter: (Absyn.ComponentRef, Absyn.ComponentRef, Absyn.Program) => bool =

  rule	Absyn.cref_to_path(classname) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_)) &
	get_public_list(parts) => publst &
	get_components_contains_name(cr,publst) => Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.PARAM,_,_),_,_) 
	------------------------
	is_parameter (cr,classname,p) => true

  axiom	is_parameter (_,_,_) => false
end

(** relation: is_protected
 ** This relation takes a class and a component reference and a program
 ** and returns true if the component referenced is in a protected section.
**)
relation is_protected: (Absyn.ComponentRef, Absyn.ComponentRef, Absyn.Program) => bool =

  rule	Absyn.cref_to_path(classname) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_)) &
	get_public_list(parts) => publst &
	get_components_contains_name(cr,publst) => _
	------------------------
	is_protected (cr,classname,p) => false

  rule	Absyn.cref_to_path(classname) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_)) &
	get_protected_list(parts) => protlst &
	get_components_contains_name(cr,protlst) => _
	---------------------------------------------
	is_protected (cr,classname,p) => true

  axiom	is_protected (_,_,_) => false
end

(** relation: is_constant
 ** This relation takes a class and a component reference and a program
 ** and returns true if the component referenced is a constant.
**)
relation is_constant: (Absyn.ComponentRef, Absyn.ComponentRef, Absyn.Program) => bool =

  rule	Absyn.cref_to_path(classname) => path &
	get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_)) &
	get_public_list(parts) => publst &
	get_components_contains_name(cr,publst) => Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.CONST,_,_),_,_) 
	------------------------
	is_constant (cr,classname,p) => true

  axiom	is_constant (_,_,_) => false
end

relation get_components_contains_name: (Absyn.ComponentRef, Absyn.ElementItem list) 
	  => Absyn.ElementSpec =

  rule	get_compitem_named(cr,ellst) => _
	-------------------
	get_components_contains_name (cr,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,res as Absyn.COMPONENTS(_,_,ellst),_,_,_))::xs) => res

  rule	get_components_contains_name(cr,xs) => res
	-----------------------------------------
	get_components_contains_name (cr,x::xs) => res
end

relation get_compitem_named: (Absyn.ComponentRef, Absyn.ComponentItem list)
	  => Absyn.ComponentItem =

  rule	id1 = id2 
	---------
	get_compitem_named(Absyn.CREF_IDENT(id1,_), (x as Absyn.COMPONENTITEM(Absyn.COMPONENT(id2,_,_),_))::xs) => x
	
  rule	get_compitem_named(cr,xs) => res
	--------------------------------
	get_compitem_named(cr, x::xs) => res
end
(** relation: exist_class
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class exists in the symbol table, otherwise it returns
 ** false.
**)
relation exist_class: (Absyn.ComponentRef, Absyn.Program) => bool =
	
  rule	Absyn.cref_to_path(cr) => path &
	get_pathed_class_in_program(path,p) => _
	----------------------------
	exist_class(cr,p) => true

  axiom	exist_class(cr,p) => false
end


relation is_primitive_class: (Absyn.Class,Absyn.Program) => bool =
	
  axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_INT,_),_) => true
  axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_REAL,_),_) => true
  axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_STRING,_),_) => true
  axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_BOOL,_),_) => true
  axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_TYPE,_),_) => true
	
  rule	Absyn.cref_to_path(Absyn.CREF_IDENT(cname,[])) => inmodel &
	lookup_classdef(path,inmodel,p)=> (cdef,_) &
	is_primitive_class(cdef,p) => res
	-------------------------------
	is_primitive_class(Absyn.CLASS(cname,_,_,_,Absyn.R_CLASS,Absyn.DERIVED(path,_,_,_,_)),p) => res

end

(** relation: remove_compiled_functions
**
**)
relation remove_compiled_functions: (Absyn.Program, (Absyn.Path * Types.Type) list)
	    => (Absyn.Path * Types.Type) list =
  rule	remove_cf(id,cfs) => cfs'
	-----------------
	remove_compiled_functions(Absyn.PROGRAM([Absyn.CLASS(id,_,_,_,Absyn.R_FUNCTION,_)],_),cfs) => cfs'
  axiom	remove_compiled_functions(_,cfs) => cfs
end

relation remove_cf: (Absyn.Ident, (Absyn.Path * Types.Type) list)
	    => (Absyn.Path * Types.Type) list =

  axiom	remove_cf(_,[]) => []

  rule	id1 = id2 &
	remove_cf(id1,rest) => res
	--------------------------
	remove_cf(id1,(Absyn.IDENT(id2),t)::rest) => res 
  rule	not id1 = id2 &
	remove_cf(id1,rest) => res
	--------------------------
	remove_cf(id1,(Absyn.IDENT(id2),t)::rest) => ((Absyn.IDENT(id2),t)::res)
end

(** relation: update_program
 **
 ** This relation takes an old program (second argument), i.e. the old symboltable, 
 ** and a new program (first argument), i.e. a new set of classes and updates the old 
 ** program with the definitions in the new one
 **)     
relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program =
     
  axiom	update_program (Absyn.PROGRAM([],_),prg) => prg
     
  rule	(* For split definitions at top, when introducing new model, eg. "package A" *)
	let newclass = Absyn.CLASS(name,p,false,e,restr,Absyn.PARTS([Absyn.PUBLIC([])],NONE)) &
	update_program(Absyn.PROGRAM([newclass],Absyn.TOP),oldp) => newp
	-------------------------------------------------------
	update_program(Absyn.BEGIN_DEFINITION(Absyn.IDENT(name),restr,p,e),oldp) => newp

  rule	(* For split definitions not at top,  eg. "package A.B" *)
	Absyn.strip_last(path) => w &
	Absyn.path_last_ident(path) => name &
	let newclass = Absyn.CLASS(name,p,false,e,restr,Absyn.PARTS([Absyn.PUBLIC([])],NONE)) &
	update_program(Absyn.PROGRAM([newclass],Absyn.WITHIN(w)),oldp) => newp
	-------------------------------------------------------
	update_program(Absyn.BEGIN_DEFINITION(path as Absyn.QUALIFIED(_,_),
					      restr,p,e),oldp) 
	  => newp

  rule	class_in_program(name,p2) => false &
	update_program(Absyn.PROGRAM(c2,w),Absyn.PROGRAM((c1::c3),w2)) => pnew
	---------------------------------------------------------
	update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_,_))::c2,w as Absyn.TOP),p2 as Absyn.PROGRAM(c3,w2)) => pnew

  rule	class_in_program(name,p2) => true &
	update_program(Absyn.PROGRAM(c2,w),p2) => pnew &
        replace_class_in_program(c1,pnew) => pnew' 
	------------------------------------------
	update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_,_))::c2,w as Absyn.TOP),p2) => pnew'
	
  rule	insert_class_in_program(c1,w,p2) => pnew &
	update_program(Absyn.PROGRAM(c2,w),pnew) => pnew' 
	---------------------------------------------
	update_program(Absyn.PROGRAM(c1::c2,w as Absyn.WITHIN(path)),p2) => pnew'

  rule	(* nested packages (of form A.B) *)
	get_pathed_class_in_program(path,p) => cdef &
	Absyn.strip_last(path) => modelwithin &
	add_to_public(cdef,
		      Absyn.ELEMENTITEM(
					Absyn.ELEMENT(
						      false, 
						      false, 
						      Absyn.UNSPECIFIED,
						      "",
						      elt,"",0,NONE)))
	  => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)
	  => newp
	--------------------------------
	update_program(Absyn.COMP_DEFINITION(elt,SOME(path as Absyn.QUALIFIED(_,_))),p) 
	  => newp

  rule	(* top package *)
	 get_pathed_class_in_program(path,p) => cdef &
	add_to_public(cdef,
		      Absyn.ELEMENTITEM(
					Absyn.ELEMENT(
						      false, 
						      false, 
						      Absyn.UNSPECIFIED,
						      "",
						      elt,"",0,NONE)))
	  => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)
	  => newp
	--------------------------------
	update_program(Absyn.COMP_DEFINITION(elt,SOME(path as Absyn.IDENT(_))),p) 
	  => newp

  rule	(* nested packages ( e.g. A.B ) *)
	get_pathed_class_in_program(path,p) => cdef &
	Absyn.strip_last(path) => modelwithin &
	add_to_public(cdef,
	 	      Absyn.ELEMENTITEM(
			 		Absyn.ELEMENT(
						      false, 
						      false, 
						      Absyn.UNSPECIFIED,
						      "",
						      elt,"",0,NONE)))
 	  => newcdef &	
	  update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)
	  => newp
 	--------------------------------
 	update_program(Absyn.IMPORT_DEFINITION(elt,SOME(path as Absyn.QUALIFIED(_,_))),p) 
 	  => newp
  rule	(* top level package e.g. A *)
	get_pathed_class_in_program(path,p) => cdef &
	add_to_public(cdef,
	 	      Absyn.ELEMENTITEM(
			 		Absyn.ELEMENT(
						      false, 
						      false, 
						      Absyn.UNSPECIFIED,
						      "",
						      elt,"",0,NONE)))
 	  => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)
	  => newp
 	--------------------------------
 	update_program(Absyn.IMPORT_DEFINITION(elt,SOME(path as Absyn.IDENT(_))),p) 
 	  => newp	

  rule	Print.print_buf "Further program merging not implemented yet\n"
	------------------------
	update_program (a,b) => b
end


(* This relation adds the scope of the scope variable to the program,
 ** so it can be inserted at the correct place.
 ** It also adds the scope to BEGIN_DEFINITION, COMP_DEFINITION and 
 ** IMPORT_DEFINITION so an empty class definition
 ** can be inserted at the correct place.
 *)
relation add_scope: (Absyn.Program, InteractiveVariable list) 
	  => Absyn.Program =
	
  rule	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path))
	--------------------------------------
	add_scope(Absyn.PROGRAM(cls,Absyn.TOP),vars) 
	  => Absyn.PROGRAM(cls,Absyn.WITHIN(path))
	
  rule	not get_variable_value("scope",vars) => _
	--------------------------------------
	add_scope(Absyn.PROGRAM(cls,w),vars) 
	  => Absyn.PROGRAM(cls,w)

  rule	(* This should probably be forbidden. *)
	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path)) &
	  Absyn.join_paths(path,path2) => newpath 
	--------------------------------------
	add_scope(Absyn.PROGRAM(cls,Absyn.WITHIN(path2)),vars)
	  => Absyn.PROGRAM(cls,Absyn.WITHIN(newpath))

  rule	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path)) &
	Absyn.join_paths(path,path2) => newpath  
	--------------------
	add_scope(Absyn.BEGIN_DEFINITION(path2,restr,p,e),vars)
	=> Absyn.BEGIN_DEFINITION(newpath,restr,p,e)
	  
  rule	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path)) 
	  --------------------
	add_scope(Absyn.COMP_DEFINITION(elt,NONE),vars)
	  => Absyn.COMP_DEFINITION(elt,SOME(path))

  rule	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path)) 
	  --------------------
	add_scope(Absyn.IMPORT_DEFINITION(elt,NONE),vars)
	  => Absyn.IMPORT_DEFINITION(elt,SOME(path))

  axiom	add_scope(p,_) => p
end

(* This relation takes a PROGRAM and updates the variable scope to according
 to the value of program:
1. BEGIN_DEFINITION ident appends ident to scope
2. END_DEFINITION ident removes ident from scope
*)
relation update_scope: (Absyn.Program, InteractiveVariable list) 
	  => InteractiveVariable list =
	  
  rule	(* If not top scope *)
	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path)) &
	Absyn.join_paths(path,Absyn.IDENT(id)) => newscope &
	let newscope' = Values.CODE(Absyn.C_TYPENAME(newscope)) &
	add_var_to_varlist(
			   "scope",
			   newscope',
			   ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE)),
			   vars)
	  => vars'
	-------------------------------------------------------------
	update_scope(Absyn.BEGIN_DEFINITION(Absyn.IDENT(id),_,_,_),vars) => vars'
	
  rule	(* If top scope *)
	let newscope' = Values.CODE(Absyn.C_TYPENAME(Absyn.IDENT(id))) &
	add_var_to_varlist(
			   "scope",
			   newscope',
			   ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE)),
			   vars)
	  => vars'
	-----------
	update_scope(Absyn.BEGIN_DEFINITION(Absyn.IDENT(id),_,_,_),vars) => vars'
	
  rule	(* If not top scope *)
	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(path)) &
	Absyn.path_last_ident(path) => id2 &
	id1 = id2 &
	Absyn.strip_last(path) => newscope &
	let newscope' = Values.CODE(Absyn.C_TYPENAME(newscope)) &
	Absyn.strip_last(path) => path' &
	add_var_to_varlist(
			   "scope",
			   newscope',
			   ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE)),
			   vars)
	  => vars'
	----------------------
	update_scope(Absyn.END_DEFINITION(id1),vars) => vars'

  rule	get_variable_value("scope",vars) 
	  => Values.CODE(Absyn.C_TYPENAME(Absyn.IDENT(id2))) &
	id1 = id2 &  
	remove_var_from_varlist("scope",vars) => vars' 
	------------------------
	update_scope(Absyn.END_DEFINITION(id1),vars) => vars'

axiom update_scope(_,vars) => vars


end

relation remove_var_from_varlist: (Absyn.Ident,InteractiveVariable list) 
	=> InteractiveVariable list =

  axiom	remove_var_from_varlist(_,[]) => []
	  
  rule	id1 = id2 
	---------
	remove_var_from_varlist(id1, IVAR(id2,_,_)::rest) => rest

  rule	not id1 = id2 &
	remove_var_from_varlist(id1,rest) => rest'
	-----------------------------------------
	remove_var_from_varlist(id1,(v as IVAR(id2,_,_))::rest)
	  => v::rest'
end

relation get_variable_value: (Absyn.Ident, InteractiveVariable list) => 
	(Values.Value) =

  rule	id1 = id2
	-------
	get_variable_value(id1,IVAR(id2,v,_)::_) => v

  rule	not id1 = id2 &
	get_variable_value(id1,rest) => v
	---------------------------------
	get_variable_value(id1,IVAR(id2,v,_)::rest) => v
end


(** relation: lookup_classdef
 ** This relation takes a Path of a class to lookup and a Path as a starting point for the lookup rules and a Program.
 ** It returns the Class definition and the complete Path to the class.
**)
relation lookup_classdef: (Absyn.Path, Absyn.Path, Absyn.Program) => (Absyn.Class, Absyn.Path) =
	
  rule	(* Look first inside 'inmodel' *)
	get_pathed_class_in_program(inmodel,p) => inmodeldef &
	get_pathed_class_in_program(path,Absyn.PROGRAM([inmodeldef],Absyn.TOP)) => cdef &
	Absyn.join_paths(inmodel,path) => newpath
	--------------------------------
	lookup_classdef(path, inmodel,p) => (cdef,newpath)

	(* Then look inside next level *)
  rule	Absyn.strip_last(inmodel) => innewpath &
	lookup_classdef(path,innewpath,p) => (cdef,respath)
	------------------------------
	lookup_classdef(path,inmodel,p) => (cdef,respath)
	
  rule	(* Finally look in top level *)
	get_pathed_class_in_program(path,p) => cdef
	------------------------------------------
	lookup_classdef(path,_,p) => (cdef,path)

  axiom	lookup_classdef(Absyn.IDENT("Real"),_,_) => 
	(Absyn.CLASS("Real",false,false,false,Absyn.R_PREDEFINED_REAL,Absyn.PARTS([],NONE)), 
	 Absyn.IDENT("Real"))

  axiom	lookup_classdef(Absyn.IDENT("Integer"),_,_) => 
	(Absyn.CLASS("Integer",false,false,false,Absyn.R_PREDEFINED_INT,Absyn.PARTS([],NONE)), 
	 Absyn.IDENT("Integer"))

  axiom	lookup_classdef(Absyn.IDENT("String"),_,_) => 
	(Absyn.CLASS("String",false,false,false,Absyn.R_PREDEFINED_STRING,Absyn.PARTS([],NONE)), 
	 Absyn.IDENT("String"))

  axiom	lookup_classdef(Absyn.IDENT("Boolean"),_,_) => 
	(Absyn.CLASS("Boolean",false,false,false,Absyn.R_PREDEFINED_BOOL,Absyn.PARTS([],NONE)), 
	 Absyn.IDENT("Boolean"))

  rule	Print.print_buf "#Error, lookup_classdef failed\n" &
	Absyn.path_string path => s1 &
	Absyn.path_string inpath => s2 &
	Print.print_buf s1 & Print.print_buf " in " & Print.print_buf s2 &
	Print.print_buf "\n" 
	---------------------
	lookup_classdef(path,inpath,_) => fail
end

(** relation: delete_component
 ** This relation deletes a component from a class given the name of the component instance,
 ** the model in which the component is instantiated in, and the Program.
 **
 ** Both public and protected lists are searched.
 **)
relation delete_component: (string, Absyn.ComponentRef, Absyn.Program) 
	 => (Absyn.Program ,string) =

  rule	Absyn.cref_to_path(model) => modelpath &
	not get_pathed_class_in_program(modelpath,p) => _
	---------------------------------
	delete_component (name,model,p) => (p,"false\n") 

  rule	Absyn.cref_to_path(model) => modelpath &
	Absyn.strip_last(modelpath) => modelwithin &
	get_pathed_class_in_program(modelpath,p) => cdef &
	delete_component_from_class(name, cdef) => newcdef &
	update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	------------------------------------------------
	delete_component(name, model as Absyn.CREF_QUAL(_,_,_),p as Absyn.PROGRAM(_,w)) => (newp,"true\n")
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	delete_component_from_class(name, cdef) => newcdef &
	update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	------------------------------------------------
	delete_component( name, model as Absyn.CREF_IDENT(_,_), p as Absyn.PROGRAM(_,w)) => (newp,"true\n")

  axiom	delete_component(_,_,p) => (p,"false\n") 
end

(** relation: delete_component_from_class
 ** This relation deletes a component from a class given the name of the component instance, and a 'Class'.
 ** 
 ** Both public and protected lists are searched.
 **)
relation delete_component_from_class: (string, Absyn.Class)
	 => Absyn.Class =
	
	(* Search in public list *)
  rule	get_public_list(parts) => publst &
	delete_component_from_elementitems(name,publst) => publst2 &
	list_length(publst2) => l2 &
	list_length(publst) => l1 &
	int_sub(l1,1) => l1' &
	l1' = l2 &
	replace_public_list(parts,publst2) => parts2 
	--------------------------------------------
	delete_component_from_class(name, Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt))) 
	=> Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))

	(* Search in protected list *)
  rule	get_protected_list(parts) => protlst &
	delete_component_from_elementitems(name,protlst) => protlst2 &
	list_length(protlst2) => l2 &
	list_length(protlst) => l1 &
	int_sub(l1,1) => l1' &
	l1' = l2 &
	replace_protected_list(parts,protlst2) => parts2 
	--------------------------------------------
	delete_component_from_class(name, Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt))) 
	=> Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))
end	

relation delete_component_from_elementitems: (string, Absyn.ElementItem list) 
	  => Absyn.ElementItem list =
  axiom	 delete_component_from_elementitems (_,[]) => []

  rule	name = name2 
	-------------
	delete_component_from_elementitems(name,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,[Absyn.COMPONENTITEM(Absyn.COMPONENT(name2,_,_),_)]),_,_,_))::xs) => xs

  rule	not name = name2 &
	delete_component_from_elementitems(name, xs) => res
	-------------------------
	delete_component_from_elementitems(name, (x as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,[Absyn.COMPONENTITEM(Absyn.COMPONENT(name2,_,_),_)]),_,_,_)))::xs) => x::res

  rule	delete_component_from_elementitems(name, xs) => res
	---------------------------------------------------
	delete_component_from_elementitems(name,x::xs) => x::res 
end

(** relation add_component
 ** This relation takes:  arg1 - string giving the instancename, arg2 - `ComponentRef' giving the component type
 ** arg3 - ComponentRef giving the model to instantiate the component within, arg4 - `NamedArg' list of annotations 
 ** and arg5 - a Program. The result is an updated program with the component and its annotations inserted, and a string
 ** "OK" for success. If the insertion fails, a suitable error string is given along with the input Program.
 **)
relation add_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program ,string) =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	not get_pathed_class_in_program(modelpath,p) => _
	---------------------------------
	add_component (name,tp,model,nargs,p) => (p,"false\n") 
	

	(* Adding component to model that resides inside package *)
  rule	Absyn.cref_to_path(model) => modelpath &
	Absyn.strip_last(modelpath) => modelwithin &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	annotation_list_to_absyn_comment(nargs,NONE) => annotation &
	modification_to_absyn(nargs,NONE) => modification &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	------------------------------------------------
	add_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")
	
	(* Adding component to model that resides on top level *)
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	annotation_list_to_absyn_comment(nargs,NONE) => annotation &
	modification_to_absyn(nargs,NONE) => modification &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)=> newp
	------------------------------------------------
	add_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")

  axiom	add_component (_,_,_,_,p) => (p,"-1")
	
end

(** relation: update_component
 ** This relation updates a component in a class. The reason for having this relation 
 ** is that a deletion followed by an addition would mean that all optional arguments must be
 ** resent to the add_component relation in order to get the same component attributes,etc. 
 ** as previous. 
 **) 
relation update_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list,
			    Absyn.Program) => (Absyn.Program ,string) =

  rule	(* Updating a public component to model that resides inside package *)
	Absyn.cref_to_path(model) => modelpath &
	Absyn.strip_last(modelpath) => modelwithin &
	delete_component(name,model,p) => (p',_) &
	get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)) &
	get_pathed_class_in_program(modelpath,p') => cdef &
	get_public_list(parts) => publst &
	get_components_contains_name(Absyn.CREF_IDENT(name,[]),publst) 
	  => Absyn.COMPONENTS(attr,tp,items) &
	get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	  => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	annotation_list_to_absyn_comment(nargs,ann) => annotation &
	modification_to_absyn(nargs,mod) => modification &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(attr,tp,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE)))
	  => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p) => newp
	--------------------------
	update_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	  => (newp, "true\n")

  rule	(* Updating a protected component to model that resides inside package*)
	Absyn.cref_to_path(model) => modelpath &
	Absyn.strip_last(modelpath) => modelwithin &
	delete_component(name,model,p) => (p',_) &
	get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)) &
	get_pathed_class_in_program(modelpath,p') => cdef &
	get_protected_list(parts) => protlst &
	get_components_contains_name(Absyn.CREF_IDENT(name,[]),protlst) 
	  => Absyn.COMPONENTS(attr,tp,items) &
	get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	  => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	annotation_list_to_absyn_comment(nargs,ann) => annotation &
	modification_to_absyn(nargs,mod) => modification &
	add_to_protected(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(attr,tp,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE)))
	  => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p) => newp
	--------------------------
	update_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	  => (newp, "true\n")

  rule	(* Updating a public component to model that resides on top level *)
	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	delete_component(name,model,p) => (p',_) &
	get_pathed_class_in_program(modelpath,p') => cdef &
	get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)) &
	get_public_list(parts) => publst &
	get_components_contains_name(Absyn.CREF_IDENT(name,[]),publst) 
	  =>Absyn.COMPONENTS(attr,tp,items) &
	get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	  => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	annotation_list_to_absyn_comment(nargs,ann) => annotation &
	modification_to_absyn(nargs,mod) => modification &
	add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(attr,tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) 
	  => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	------------------------------------------------
	update_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	  => (newp,"true\n")

  rule	(* Updating a protected component to model that resides on top level *)
	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.cref_to_path(tp) => tppath &
	delete_component(name,model,p) => (p',_) &
	get_pathed_class_in_program(modelpath,p') => cdef &
	get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)) &
	get_protected_list(parts) => protlst &
	get_components_contains_name(Absyn.CREF_IDENT(name,[]),protlst) 
	  =>Absyn.COMPONENTS(attr,tp,items) &
	get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	  => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	annotation_list_to_absyn_comment(nargs,ann) => annotation &
	modification_to_absyn(nargs,mod) => modification &
	add_to_protected(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	    Absyn.COMPONENTS(attr,tppath,
		[Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) 
	  => newcdef &	
	update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	------------------------------------------------
	update_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	  => (newp,"true\n")

end

(** relation:add_class_annotation 
 ** This relation takes a `ComponentRef' and an `Exp' expression and a `Program' and adds the 
 ** expression as a annotation to the specified model in the program, 
 ** returning the updated program.
**)
relation add_class_annotation:(Absyn.ComponentRef,Absyn.NamedArg list,Absyn.Program) => Absyn.Program =
  rule	(* Class inside other class *)
	Absyn.cref_to_path(model) => modelpath &
	Absyn.strip_last(modelpath) => modelwithin &
	get_pathed_class_in_program(modelpath,p) => cdef &
	add_class_annotation_to_class(cdef,nargs) => cdef' &
	update_program(Absyn.PROGRAM([cdef'], Absyn.WITHIN(modelwithin)),p) => newp
	-----------------------------
	add_class_annotation(model as Absyn.CREF_QUAL(_,_,_),nargs,p) => newp

  rule	(* Class on top level *)
	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	add_class_annotation_to_class(cdef,nargs) => cdef' &
	update_program(Absyn.PROGRAM([cdef'], Absyn.TOP),p) => newp
	-----------------------------
	add_class_annotation(model as Absyn.CREF_IDENT(_,_),nargs,p) => newp
end

(** relation: add_class_annotation_to_class
 *
 * This relation adds an annotation on element level to a `Class´.
 **)
relation add_class_annotation_to_class: ( Absyn.Class, Absyn.NamedArg list) 
	  => Absyn.Class =
	
  rule	(* No annotation element found in class *)
	get_public_list(parts) => publst &
	not get_element_annotation_in_elements(publst) => _ &
	annotation_list_to_absyn(nargs) => annotation &
	add_to_public(cdef,Absyn.ANNOTATIONITEM(annotation)) => cdef' 
	------------------------------------------------------------
	add_class_annotation_to_class(cdef as Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)),nargs) => cdef'

  rule	get_public_list(parts) => publst &
	get_element_annotation_in_elements(publst) => Absyn.ANNOTATIONITEM(oldann) &
	annotation_list_to_absyn(nargs) => newann &
	merge_annotations(oldann,newann) => newann' &
	replace_element_annotation_in_elements(publst,newann') => publst2 &
	replace_public_list(parts,publst2) => parts2 
	--------------------------------
	add_class_annotation_to_class(cdef as Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)),nargs)
	=> Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))
end

(** relation: replace_element_annotation_in_elements
 *
 * This relation takes an element list and replaces the first annotation with the
 * one given as argument.
 **)

relation replace_element_annotation_in_elements: (Absyn.ElementItem list,Absyn.Annotation)
	  => Absyn.ElementItem list =
	  
  axiom	replace_element_annotation_in_elements(Absyn.ANNOTATIONITEM(_)::xs,a) 
	  => Absyn.ANNOTATIONITEM(a)::xs
	
  rule	replace_element_annotation_in_elements(xs,a2) => res
	-----------------------
	replace_element_annotation_in_elements(a::xs,a2) 
	  => a::res

  axiom	replace_element_annotation_in_elements([],_) => []
end

(** relation: get_element_annotation_in_elements
 *
 * This relation retrieves the forst Annotation among the elements taken as argument
 *
 **)
relation get_element_annotation_in_elements: (Absyn.ElementItem list) 
	  => Absyn.ElementItem =
	  
  axiom	get_element_annotation_in_elements((a as Absyn.ANNOTATIONITEM(_))::xs) => a
	
  rule	get_element_annotation_in_elements(xs) => a
	-------------------------------------------
	get_element_annotation_in_elements(_::xs) => a
end

(** relation: merge_annotations
 *
 * This relation takes an old annotation as first argument and a new annotation as 
 * second argument and merges the two.
 * Annotation "parts" that exist in both the old and the new annotation will be changed
 * according to the new definition. For instance,
 * merge_annotations(annotation(x=1,y=2),annotation(x=3)) => annotation(x=3,y=2)
 **)
relation merge_annotations:(Absyn.Annotation, Absyn.Annotation) => Absyn.Annotation =
	 
  rule	not remove_modification_in_elementargs(eltargs,cr) => _ &
	merge_annotations(Absyn.ANNOTATION(oldrest),Absyn.ANNOTATION(eltargs))
	  => Absyn.ANNOTATION(neweltargs) 
	  ----------------------------
	merge_annotations(Absyn.ANNOTATION((mod as Absyn.MODIFICATION(_,_,cr,_,_))::oldrest),
			  Absyn.ANNOTATION(eltargs))
	  => Absyn.ANNOTATION(mod::neweltargs)
	  
  rule	remove_modification_in_elementargs(eltargs,cr) => eltargs' &
	merge_annotations(Absyn.ANNOTATION(oldrest),Absyn.ANNOTATION(eltargs))
	  => Absyn.ANNOTATION(neweltargs) 
	-----------------------------------------------------------------------
	merge_annotations(Absyn.ANNOTATION((mod as Absyn.MODIFICATION(_,_,cr,_,_))::oldrest),
			  Absyn.ANNOTATION(eltargs))
	  => Absyn.ANNOTATION(neweltargs)

  axiom	merge_annotations(Absyn.ANNOTATION([]),a) => a
end

(** relation: remove_modification_in_elementargs
 * This relation removes the class modification named by the second argument.
* If no such class modification is found the relation fails.
* Currently, only identifiers are allowed as class modifiers, i.e. a(...) and not a.b(...)
**)
relation remove_modification_in_elementargs:(Absyn.ElementArg list, Absyn.ComponentRef )
	=> Absyn.ElementArg list = 

  rule	id = id2 
	---------------------------------------------
	remove_modification_in_elementargs([Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_)],cr as Absyn.CREF_IDENT(id2,_))
	  => []
  rule	not id = id2 
	---------------------------------------------
	remove_modification_in_elementargs([(m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))],cr as Absyn.CREF_IDENT(id2,_))
	  => fail

  rule	id = id2 &
	remove_modification_in_elementargs(xs,cr) => res 
	---------------------------------------------
	remove_modification_in_elementargs(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_)::xs,cr as Absyn.CREF_IDENT(id2,_))
	  => res
  rule	not id = id2 &
	remove_modification_in_elementargs(xs, cr) => res 
	---------------------------------------------
	remove_modification_in_elementargs((m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))::xs,cr as Absyn.CREF_IDENT(id2,_))
	  => m::res

  rule	remove_modification_in_elementargs(xs, cr) => res 
	---------------------------------------------
	remove_modification_in_elementargs((m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))::xs,cr as Absyn.CREF_IDENT(id2,_))
	  => m::res 
end

(** relation: get_inheritance_count
 ** This relation takes a `ComponentRef' and a `Program' and returns the number of inherited classes in the 
 ** class referenced by the `ComponentRef'.
   **)
relation get_inheritance_count: (Absyn.ComponentRef,Absyn.Program) => int = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &

	count_base_classes(cdef) => count
	-------------------------------------------------
	get_inheritance_count( model,p) => count
	
  axiom	get_inheritance_count (_,_) => 0
end

(** relation: get_inheritance_count
 ** This relation takes a `ComponentRef' and a `Program' and returns the number of inherited classes in the 
 ** class referenced by the `ComponentRef'.
   **)
relation get_nth_inherited_class: (Absyn.ComponentRef,int,Absyn.Program) => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	Lookup.lookup_class(env,modelpath,false) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	  get_nth_inherited_class2(c,cdef,n,env') => str 
	-------------------------------------------------
	get_nth_inherited_class( model,n,p) => str

(*  rule	Print.get_string() => str
	-------------------------------------------------
	get_nth_inherited_class( model,n,p) => str*)
	
  axiom	get_nth_inherited_class (_,_,_) => "-1"
end
relation get_nth_inherited_class2: (SCode.Class, Absyn.Class,int, Env.Env) 
	  => string =

  rule	(* First try without instantiating, if class is in parents*)
	get_base_classes(cdef,env) => lst &  
	int_sub(n,1) => n' &
	list_nth(lst,n') => cref &
	Absyn.cref_to_path(cref) => path &
	Absyn.path_string(path) => str
	-----------------------
	get_nth_inherited_class2(c as SCode.CLASS(_,_,_,_,_),cdef,n,env)
	  => str

  rule	(* If that fails, instantiate, which takes more time*)
	Env.open_scope(env,encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	  => (env'',_) &
	get_base_classes(cdef,env'') => lst &  
	int_sub(n,1) => n' &
	list_nth(lst,n') => cref &
	Absyn.cref_to_path(cref) => path &
	Absyn.path_string(path) => str
	--------------------------
	get_nth_inherited_class2(c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	  => str
end


(** relation: get_component_count
 ** This relation takes a `ComponentRef' and a `Program' and returns the number of public components in the 
 ** class referenced by the `ComponentRef'.
   **)
relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int = 
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_components(cdef) => count
	-------------------------------------------------
	get_component_count( model,p) => count
end

(** relation: count_components
 ** This relation takes a `Class' and returns the number of components in that class
**)

relation count_components: Absyn.Class => int =

  rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt)) => c1 &
	count_components_in_elts(elt) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt)) 
	    => res

  rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt)) => c1 &
	count_components_in_elts(elt) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt)) 
	    => res
  rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt)) => res
	-----------------------------------------------------
	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt)) => res
	
  axiom count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],_)) => 0
  axiom count_components Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(_,_,_,_,_)) => -1
end

relation count_components_in_elts: Absyn.ElementItem list => int =

  rule	count_components_in_elts(lst) => c1 &
	list_length(complst) => ncomps &
	int_add(c1,ncomps) => res
	--------------------------
	count_components_in_elts(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,complst),_,_,NONE))::lst) => res
	
  rule	count_components_in_elts(lst) => res
	----------------------------
	count_components_in_elts(_::lst) => res

  axiom	count_components_in_elts([]) => 0
end


(** relation: get_nth_component
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of names
 ** containing the name, type and comment of that component.
 **)
relation get_nth_component: (Absyn.ComponentRef,Absyn.Program, int) => string = 
  rule	Absyn.cref_to_path(model) => modelpath &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	Lookup.lookup_class(env,modelpath,false) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_component2(c,cdef,n,env') => str 
	-------------------------------------------------
	get_nth_component( model,p,n) => str

	axiom get_nth_component(_,_,_) => "-1"
end

relation get_nth_component2: (SCode.Class,Absyn.Class, int, Env.Env) 
	  => string =
(*rule	
	get_nth_component_in_class(cdef,n) => comp &
	get_component_name_and_type_and_comment (comp,env) => [s1] &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str 
	--------------------------
	get_nth_component2 (c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	  => str
*)

rule	(* If fails, instantiate class and search... *)
	Env.open_scope(env,encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	  => (env'',_) &
	get_nth_component_in_class(cdef,n) => comp &
	get_component_name_and_type_and_comment (comp,env'') => [s1] &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	--------------------------
	get_nth_component2 (c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	  => str
  rule	print "get_nth_component2 failed\n" 
	-----------------------
	get_nth_component2(_,_,_,_) => fail

end

(** relation: get_components
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns 
 ** a list of all components, as returned by get_nth_component.
 **)
relation get_components: (Absyn.ComponentRef,Absyn.Program) => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	Lookup.lookup_class(env,modelpath,false) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	Env.open_scope(env',encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	  => (env'',_) &
	get_components_in_class(cdef) => comps &
	get_components_name_and_type_and_comment (comps,env'') => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	-------------------------------------------------
	get_components(model,p) => str

	axiom get_components(_,_) => "-1"
end


(** relation: get_component_annotations
 ** This relation takes a `ComponentRef', a `Program' and
 ** returns a list of all component annotations, as returned by 
 ** get_nth_component_annotation.
 **)
relation get_component_annotations: (Absyn.ComponentRef,
				      Absyn.Program) 
	  => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_components_in_class(cdef) => comps &
	get_component_annotations_from_elts(comps) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	-------------------------------------------------
	get_component_annotations( model,p) => str

	axiom get_component_annotations(_,_) => "-1"
end

(** relation: get_nth_component_annotation
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of values
 ** corresponding to the flat record for component annotations.
 **)
relation get_nth_component_annotation: (Absyn.ComponentRef,Absyn.Program, int) => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_component_in_class(cdef,n) => comp &
	get_component_annotation(comp) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	---------------------------------------------- 
	get_nth_component_annotation( model,p,n) => str

	axiom get_nth_component_annotation(_,_,_) => "-1"
end

(** relation: get_nth_component_modification
 ** This relation takes a `ComponentRef', a `Program' and an int and  returns a comma separated string of values
 ** corresponding to the flat record for component annotations.
 **)
relation get_nth_component_modification: (Absyn.ComponentRef,Absyn.Program, int) 
	  => string = 

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_component_in_class(cdef,n) => comp &
	get_component_modification(comp) => str &
	Util.string_append_list(["{",str,"}"]) => str'
	---------------------------------------------- 
	get_nth_component_modification( model,p,n) => str'

	axiom get_nth_component_modification(_,_,_) => "-1"
end

(** relation: get_connection_count
 ** This relation takes a `ComponentRef' and a `Program' and returns a string containing
 ** the number of connections in the model identified by the `ComponentRef'.
**)
relation get_connection_count: (Absyn.ComponentRef, Absyn.Program) => string =

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_connections cdef => numconn &
	int_string numconn => res
	-------------------------
	get_connection_count (model,p) => res
	
	axiom get_connection_count(_,_) => "-1"
end

(** relation: get_nth_connection
 ** This relation takes a `ComponentRef' and a `Program' and an int and 
** returns a comma separated string for the nth connection, e.g. "R1.n,C.p".
**)
relation get_nth_connection: (Absyn.ComponentRef, Absyn.Program, int) => string =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => Absyn.EQUATIONITEM(eq,_) &
	get_connection_str eq => str
	----------------------------
	get_nth_connection (model,p,n) => str

	axiom get_nth_connection(_,_,_) => "-1"
end

relation add_connection: (Absyn.ComponentRef, Absyn.ComponentRef, Absyn.ComponentRef,
			  Absyn.NamedArg list, Absyn.Program) => 
	(string, Absyn.Program) =

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	  => newcdef &
	update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	---------------------------------------------------
	add_connection(model as Absyn.CREF_IDENT(_,_),c1,c2,[],p as Absyn.PROGRAM(_,w)) => ("Ok",newp)
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.strip_last(modelpath) => package &
	add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	  => newcdef &
	update_program(Absyn.PROGRAM([newcdef],Absyn.WITHIN(package)),p)=> newp
	---------------------------------------------------
	add_connection(model as Absyn.CREF_QUAL(_,_,_),c1,c2,[],p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	annotation_list_to_absyn(nargs) => annotation &
	add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),SOME(Absyn.COMMENT(SOME(annotation),NONE)))) 
	  => newcdef &
	update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	---------------------------------------------------
	add_connection(model as Absyn.CREF_IDENT(_,_),c1,c2,nargs,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	Absyn.strip_last(modelpath) => package &
	annotation_list_to_absyn(nargs) => annotation &
	add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),SOME(Absyn.COMMENT(SOME(annotation),NONE)))) 
	  => newcdef &
	update_program(Absyn.PROGRAM([newcdef],Absyn.WITHIN(package)),p)=> newp
	---------------------------------------------------
	add_connection(model as Absyn.CREF_QUAL(_,_,_),c1,c2,nargs,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)	
end

relation delete_connection: (Absyn.ComponentRef, Absyn.ComponentRef, Absyn.ComponentRef, Absyn.Program)
	  => (string,Absyn.Program) =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	Absyn.strip_last(modelpath) => modelwithin &
	get_pathed_class_in_program(modelpath,p) => cdef &
	delete_equation_in_class(cdef,c1,c2) => newcdef &
	update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	---------------------------------------------------
	delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	delete_equation_in_class(cdef,c1,c2) => newcdef &
	update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	---------------------------------------------------
	delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

  axiom	delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("-1",p)	
end

relation delete_equation_in_class: (Absyn.Class, Absyn.ComponentRef, Absyn.ComponentRef)
	  => Absyn.Class =  
	  
  rule	get_equation_list(parts) => eqlst &
	delete_equation_in_eqlist(eqlst,c1,c2) => eqlst' &
	replace_equation_list(parts,eqlst') => parts2 
	----------------------------
	delete_equation_in_class(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)),c1,c2)
	  => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))
end

relation delete_equation_in_eqlist: (Absyn.EquationItem list, Absyn.ComponentRef,Absyn.ComponentRef) => Absyn.EquationItem list =

  axiom	delete_equation_in_eqlist([],_,_) => []

  rule	Absyn.cref_to_path(c1) => p1 & Absyn.path_string(p1) => s1 &
	Absyn.cref_to_path(c2) => p2 & Absyn.path_string(p2) => s2 &
	Absyn.cref_to_path(cn1) => pn1 & Absyn.path_string(pn1) => sn1 &
	Absyn.cref_to_path(cn2) => pn2 & Absyn.path_string(pn2) => sn2 &
	s1 = sn1 & s2 = sn2 &
	delete_equation_in_eqlist(xs,c1,c2) => res
	---------------------
	delete_equation_in_eqlist(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(cn1,cn2),_)::xs,c1,c2) => res

  rule	delete_equation_in_eqlist(xs,c1,c2) => res
	------------------------------------
	delete_equation_in_eqlist(x::xs,c1,c2) => x::res
end

(** relation: get_nth_connection_annotation
 ** This relation takes a `ComponentRef' and a `Program' and an int and 
** returns a comma separated string  of values for the annotation of the the nth connection.
**)
relation get_nth_connection_annotation: (Absyn.ComponentRef, Absyn.Program, int) => string =

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => citem &
	get_connection_annotation_str (citem) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	--------------
	get_nth_connection_annotation(model,p,n) => str

  axiom	get_nth_connection_annotation(_,_,_) => "{}"
end

(** relation: get_connector_count
 ** This relation takes a ComponentRef and a Program and returns the number
 ** of connector components in the class given by the classname in the 
 ** ComponentRef. A partial instantiation of the inheritance structure is performed in order 
 ** to find all connectors of the class
 **)
relation get_connector_count: ((* Env.Env, *) Absyn.ComponentRef, Absyn.Program) => string =
	(** A complete elaboration is far too expensive. Instead we only look through the components of
	 ** the class for types declared using the "connector" restricted class keyword. We also look in
	 ** base classes  (recursively)  
	 **)

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_public_connectors(modelpath,p,cdef) => count &
	int_string(count) => countstr
	-------------------
	get_connector_count (model,p) => countstr

	axiom get_connector_count(_,_) => "-1"
end

(** relation: get_nth_connector
 ** This relation takes a ComponentRef and a Program and an int and returns a string with the name of the nth
 ** connector component in the class given by ComponentRef in the Program.
 **)
relation get_nth_connector: (Absyn.ComponentRef, Absyn.Program, int) => string =
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_connector_str(modelpath,cdef,p,n) => (str,tp) &
	Absyn.path_string tp => tpstr &
	string_append(str,",") => s1 &
	string_append(s1,tpstr) => resstr
	-----------------
	get_nth_connector(model,p,n)=> resstr

  axiom get_nth_connector(_,_,_) => "-1"
end

(** relation: get_nth_connector
 ** This relation takes a ComponentRef and a Program and an int and returns a string with the name of the nth
 ** connectors icon annotation in the class given by ComponentRef in the Program.
 **)
relation get_nth_connector_icon_annotation: (Absyn.ComponentRef, Absyn.Program, int) => string =
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_public_connector_str(modelpath,cdef,p,n) => (resstr,tp) &
	get_icon_annotation(tp,p) => resstr
	--------------------------
	get_nth_connector_icon_annotation(model,p,n)=> resstr

  axiom get_nth_connector_icon_annotation(_,_,_) => "-1"	
end

(** relation: get_diagram_annotation
 ** This relation takes a Path and a Program and returns a comma separated 
   string of values for the diagram annotation for the class named by the first argument.
**)
relation get_diagram_annotation: (Absyn.Path, Absyn.Program) => string =

  rule	get_pathed_class_in_program (modelpath,p) => cdef &
	get_diagram_annotation_in_class(cdef) => str
	---------------------------
	get_diagram_annotation(modelpath,p) => str

  axiom get_diagram_annotation(_,_) => "get_diagram_annotation failed!"
end

(** relation: get_icon_annotation
 ** This relation takes a Path and a Program and returns a comma separated
 ** string of values for the icon annotation for the class named by the first argument. 	
 *)
relation get_icon_annotation: (Absyn.Path, Absyn.Program) => string =

   rule	get_pathed_class_in_program(modelpath,p) => cdef &
	get_icon_annotation_in_class(cdef) => str
	-----------------------------------------
	get_icon_annotation(modelpath,p) => str
  axiom get_icon_annotation(_,_) => ""
end

(** relation: get_packages_in_path
 ** This relation takes a Path and a Program and returns a list of the names of the packages found in the Path.
**)

relation get_packages_in_path: (Absyn.Path,Absyn.Program) => string =

  rule	get_pathed_class_in_program(modelpath,p) => cdef &
	get_packages_in_class(modelpath,p,cdef) => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	----------------------
	get_packages_in_path (modelpath,p) => res
  axiom	 get_packages_in_path(_,_) => "-1"
end
(** relation: get_top_packages
 ** This relation takes a Path and a Program and returns a list of the names of the packages found in the Path.
 **)
relation get_top_packages: (Absyn.Program) => string =

  rule	get_top_packages_in_program(p) => strlist &
	Util.string_delimit_list(strlist,",") => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	-------------------------
	get_top_packages(p) => res

  axiom	get_top_packages(_) => "-1"
end

relation get_top_packages_in_program: Absyn.Program => string list =
	
  axiom	get_top_packages_in_program Absyn.PROGRAM([],_) => []
	
  rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	-----------------------------------------
	get_top_packages_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,Absyn.R_PACKAGE,_)::rest,w)) => id::res

  rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	------------------------------------------
	get_top_packages_in_program (Absyn.PROGRAM(_::rest,w)) => res
end

(** relation: get_packages_in_class
 ** This relation takes a `Class' definition and a Path identifying th elcass. 
 ** It returns a string containing comma separated package names found 
 ** in the class definition.
 **)
relation get_packages_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) => string =

  rule	get_packages_in_parts(parts) => strlist &
	Util.string_delimit_list(strlist,",") => res
	-------------------------------------
	get_packages_in_class(_,_,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,cmt))) => res

  rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	get_packages_in_class(newpath,p,cdef) => res 
	--------------------------------------------
	get_packages_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_))) => res
end


relation get_packages_in_parts:(Absyn.ClassPart list ) => string list =

  axiom	get_packages_in_parts [] => []

  rule	get_packages_in_elts(elts) => l1 &
	get_packages_in_parts(rest) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_packages_in_parts(Absyn.PUBLIC(elts)::rest) => res	
	
  rule	get_packages_in_parts(rest) => res
	-----------------------------------
	get_packages_in_parts(_::rest) => res
end

relation get_packages_in_elts: (Absyn.ElementItem list) => string list =
  axiom	 get_packages_in_elts [] => []
	
  rule	get_packages_in_elts(rest) => res
	--------------------------------
	get_packages_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,_,Absyn.R_PACKAGE,_)),_,_,NONE))::rest) => id::res

  rule	get_packages_in_elts(rest) => res
	--------------------------------
	get_packages_in_elts (_::rest) => res
end

relation get_classnames_in_path: (Absyn.Path,Absyn.Program) => string =

  rule	get_pathed_class_in_program(modelpath,p) => cdef &
	get_classnames_in_class(modelpath,p,cdef) => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	----------------------
	get_classnames_in_path (modelpath,p) => res
  axiom	 get_classnames_in_path(_,_) => "-1"
end

(** relation: get_top_classnames
 ** This relation takes a Path and a Program and returns a list of the names of the packages found in the Path.
 **)
relation get_top_classnames: (Absyn.Program) => string =

  rule	get_top_classnames_in_program(p) => strlist &
(*	Print.print_buf "program =" &
	Dump.dump p & Print.print_buf "\n" &*)
	Util.string_delimit_list(strlist,",") => str &
	string_append("{",str) => s1 &
	string_append(s1,"}") => res
	-------------------------
	get_top_classnames(p) => res

  axiom	get_top_classnames(_) => "-1"
end

relation get_top_classnames_in_program: Absyn.Program => string list =
	
  axiom	get_top_classnames_in_program Absyn.PROGRAM([],_) => []
	
  rule	get_top_classnames_in_program (Absyn.PROGRAM(rest,w)) => res 
	-----------------------------------------
	get_top_classnames_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,_,_)::rest,w)) => id::res

  rule	get_top_classnames_in_program (Absyn.PROGRAM(rest,w)) => res
	------------------------------------------
	get_top_classnames_in_program (Absyn.PROGRAM(_::rest,w)) => res
end

(** relation: get_classnames_in_class
 ** This relation takes a `Class' definition and a Path identifying th elcass. 
 ** It returns a string containing comma separated package names found 
 ** in the class definition.
 **)
relation get_classnames_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) => string =

  rule	get_classnames_in_parts(parts) => strlist &
	Util.string_delimit_list(strlist,",") => res
	-------------------------------------
	get_classnames_in_class(_,_,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_))) => res

  rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	get_classnames_in_class(newpath,p,cdef) => res 
	--------------------------------------------
	get_classnames_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_))) => res
end


relation get_classnames_in_parts:(Absyn.ClassPart list ) => string list =

  axiom	get_classnames_in_parts [] => []

  rule	get_classnames_in_elts(elts) => l1 &
	get_classnames_in_parts(rest) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_classnames_in_parts(Absyn.PUBLIC(elts)::rest) => res	
	
  rule	get_classnames_in_parts(rest) => res
	-----------------------------------
	get_classnames_in_parts(_::rest) => res
end

relation get_classnames_in_elts: (Absyn.ElementItem list) => string list =
  axiom	 get_classnames_in_elts [] => []
	
  rule	get_classnames_in_elts(rest) => res
	--------------------------------
	get_classnames_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,_,_,_)),_,_,NONE))::rest) => id::res
  rule	get_classnames_in_elts(rest) => res
	--------------------------------
	get_classnames_in_elts (_::rest) => res
end

(* This relation gets all base classes of a class, NOT Recursive.*)
relation get_base_classes : (Absyn.Class, Env.Env) 
	  => Absyn.ComponentRef list =

  rule	get_base_classes_from_parts(parts, env) => res 
	-----------------------------------------
	get_base_classes (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)),env) 
	  => res

  axiom	get_base_classes (_,_) => []
end

relation get_base_classes_from_parts: (Absyn.ClassPart list, Env.Env) 
	  => Absyn.ComponentRef list =

  rule	get_base_classes_from_elts(elts, env) => c1 &
	get_base_classes_from_parts(rest, env) => c2 &
	list_append(c1,c2) => res 
	----------------------------
	get_base_classes_from_parts(Absyn.PUBLIC(elts)::rest, env) => res

  rule	get_base_classes_from_parts(rest, env) => res
	----------------------------------------
	get_base_classes_from_parts(_::rest, env) => res

  axiom	get_base_classes_from_parts([], env) => []
end

relation get_base_classes_from_elts : (Absyn.ElementItem list, Env.Env) 
	  => Absyn.ComponentRef list =

  axiom	get_base_classes_from_elts([], env) => []

  rule	(* Inherited class is defined inside package *)
	get_base_classes_from_elts(rest,env) => cl &
	Lookup.lookup_class(env,path,true) => (c,env') &
	Env.get_env_path(env') => SOME(envpath) &
	Absyn.path_last_ident(path) => tpname &
	Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	Absyn.path_to_cref(p') => cref
	------------------------
	get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_,_))::rest, env )
	    => cref::cl

  rule	(* Inherited class defined on top level scope*)
	get_base_classes_from_elts(rest,env) => cl &
	Lookup.lookup_class(env,path,true) => (c,env') &
	Env.get_env_path(env') => NONE &
	Absyn.path_to_cref(path) => cref
	--------------------------------
	get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_,_))::rest, env )
	    => cref::cl

  rule	get_base_classes_from_elts(rest, env) => cl
	--------------------------------------
	get_base_classes_from_elts (_::rest, env) => cl
end

(* Relation: count_base_classes
 ** This relation counts the number of base classes of a class
 **)

relation count_base_classes : (Absyn.Class) 
	  => int =

  rule	count_base_classes_from_parts(parts) => res 
	-----------------------------------------
	count_base_classes (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_))) 
	  => res

  axiom	count_base_classes (_) => 0
end

relation count_base_classes_from_parts: (Absyn.ClassPart list) 
	  => int =

  rule	count_base_classes_from_elts(elts) => c1 &
	count_base_classes_from_parts(rest) => c2 &
	int_add(c1,c2) => res
	----------------------------
	count_base_classes_from_parts(Absyn.PUBLIC(elts)::rest) => res

  rule	count_base_classes_from_parts(rest) => res
	----------------------------------------
	count_base_classes_from_parts(_::rest) => res

  axiom	count_base_classes_from_parts([]) => 0
end

relation count_base_classes_from_elts : (Absyn.ElementItem list) 
	  => int =

  axiom	count_base_classes_from_elts([]) => 0

  rule	(* Inherited class *)
	count_base_classes_from_elts(rest) => cl &
	int_add(cl,1) => res
	------------------------
	count_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_,_))::rest )
	    => res

  rule	count_base_classes_from_elts(rest) => cl
	--------------------------------------
	count_base_classes_from_elts (_::rest) => cl
end

relation get_icon_annotation_from_baseclasses :(Absyn.ComponentRef list, Absyn.Program) 
	=> string list =
  axiom	get_icon_annotation_from_baseclasses([],p) => []

  rule	Absyn.cref_to_path cr => path &
	get_icon_annotation(path,p) => s1 &
	get_icon_annotation_from_baseclasses(rest,p) => s2
	------------------------------------------------
	get_icon_annotation_from_baseclasses(cr::rest,p) => s1::s2
end


relation get_icon_annotation_in_class : (Absyn.Class) => string =

  rule	get_icon_annotation_from_parts(parts) => annlst &
	get_icon_annotation_str(annlst) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str 
	------------------------
	get_icon_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_))) 
	  => str	
end

relation get_icon_annotation_from_parts: Absyn.ClassPart list 
	  => Absyn.ElementArg list =
	
  axiom	get_icon_annotation_from_parts [] => []
	
  rule	get_icon_annotation_from_elts(elts) => res
	-----------------------------------------
	get_icon_annotation_from_parts(Absyn.PUBLIC(elts)::rest) => res

  rule	get_icon_annotation_from_elts(elts) => res
	-----------------------------------------
	get_icon_annotation_from_parts(Absyn.PROTECTED(elts)::rest) => res

  rule	get_icon_annotation_from_eqns(eqns) => res
	-----------------------------------------
	get_icon_annotation_from_parts(Absyn.EQUATIONS(eqns)::rest) => res

  rule	get_icon_annotation_from_eqns(eqns) => res
	-----------------------------------------
	get_icon_annotation_from_parts(Absyn.INITIALEQUATIONS(eqns)::rest) => 
	res

  rule	get_icon_annotation_from_algs(algs) => res
	-----------------------------------------
	get_icon_annotation_from_parts(Absyn.ALGORITHMS(algs)::rest) => res

  rule	get_icon_annotation_from_algs(algs) => res
	-----------------------------------------
	get_icon_annotation_from_parts(Absyn.INITIALALGORITHMS(algs)::rest) => res
  rule	get_icon_annotation_from_parts(rest) => res
	-----------------------------------------
	get_icon_annotation_from_parts(_::rest) => res
end

relation get_icon_annotation_from_elts: (Absyn.ElementItem list) 
	  => Absyn.ElementArg list =

  rule	contain_icon_annotation(lst)
	-----------------------------
	get_icon_annotation_from_elts(Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(lst))::rest)
	  => lst
  rule	get_icon_annotation_from_elts(rest) => res
	-----------------------------
	get_icon_annotation_from_elts(_::rest)
	  => res
end

relation contain_icon_annotation: Absyn.ElementArg list => () =

  axiom	contain_icon_annotation(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),_,_)::_) => ()

  rule	contain_icon_annotation(lst)
	-----------------------------
	contain_icon_annotation(_::lst) 
end

relation get_icon_annotation_from_eqns: (Absyn.EquationItem list) 
	  => Absyn.ElementArg list =

  axiom	get_icon_annotation_from_eqns [] => []

  rule	contain_icon_annotation(lst)
	--------------------------------------
	get_icon_annotation_from_eqns(Absyn.EQUATIONITEMANN(Absyn.ANNOTATION(lst))::rest)
	  => lst

  rule	get_icon_annotation_from_eqns(rest) => res
	--------------------------------------
	get_icon_annotation_from_eqns(_::rest) => res
end

relation get_icon_annotation_from_algs: Absyn.AlgorithmItem list 
	  => Absyn.ElementArg list =

  axiom	get_icon_annotation_from_algs [] => []

  rule	contain_icon_annotation(lst)
	-----------------------------
	get_icon_annotation_from_algs(Absyn.ALGORITHMITEMANN(Absyn.ANNOTATION(lst))::rest) 
	=> lst
  rule	get_icon_annotation_from_algs(rest) => res
	-----------------------------
	get_icon_annotation_from_algs(_::rest) => res
end

relation get_icon_annotation_in_elementitemlist: (Absyn.ElementItem list) => string =
  axiom	get_icon_annotation_in_elementitemlist [] => ""
	
  rule	get_icon_annotation_str(annlst) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str	
	----------------------------
	get_icon_annotation_in_elementitemlist (Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(annlst))::_) => str
	
  rule	get_icon_annotation_in_elementitemlist(xs) => str
	------------------------------------------------
	get_icon_annotation_in_elementitemlist(_::xs) => str
end

relation get_icon_annotation_str: (Absyn.ElementArg list) => string =

  rule	string_append(Icon_records,Graphics_records) => records &
	get_annotation_string (records,Absyn.ANNOTATION([ann])) => str 
	-----------------------------------------------
	get_icon_annotation_str ( (ann as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),mod,_))::_) => str

  rule	get_icon_annotation_str (xs) => str
	-------------------------------
	get_icon_annotation_str( _::xs) => str
end

relation get_diagram_annotation_from_baseclasses :(Absyn.ComponentRef list, Absyn.Program) 
	=> string list =
  axiom	get_diagram_annotation_from_baseclasses([],p) => []

  rule	Absyn.cref_to_path cr => path &
	get_diagram_annotation(path,p) => s1 &
	get_diagram_annotation_from_baseclasses(rest,p) => s2
	------------------------------------------------
	get_diagram_annotation_from_baseclasses(cr::rest,p) => s1::s2
end

relation get_diagram_annotation_in_class : (Absyn.Class) => string =

  rule	get_public_list(parts) => publst &
	get_protected_list(parts) => protlst &
	list_append(publst,protlst) => lst &
	get_diagram_annotation_in_elementitemlist(lst) => str
	----------------------------
	get_diagram_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_))) => str	
end

relation get_diagram_annotation_in_elementitemlist: (Absyn.ElementItem list) => string =
  axiom	get_diagram_annotation_in_elementitemlist [] => ""
	
  rule	get_diagram_annotation_str(annlst) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str	
	----------------------------
	get_diagram_annotation_in_elementitemlist (Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(annlst))::_) => str
	
  rule	get_diagram_annotation_in_elementitemlist(xs) => str
	------------------------------------------------
	get_diagram_annotation_in_elementitemlist(_::xs) => str
end

relation get_diagram_annotation_str: (Absyn.ElementArg list) => string =

  rule	string_append(Diagram_records,Graphics_records) => records &
	get_annotation_string (records,Absyn.ANNOTATION([ann])) => str 
	-----------------------------------------------
	get_diagram_annotation_str ( (ann as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Diagram",_),mod,_))::_) => str

  rule	get_diagram_annotation_str (xs) => str
	-------------------------------
	get_diagram_annotation_str( _::xs) => str
end

relation get_nth_public_connector_str: (Absyn.Path, Absyn.Class, Absyn.Program,  int) => (string,Absyn.Path) =
	
  rule	get_nth_connector_str (p, modelpath, elt, n) => (str,tp)
	------------------------------------------
	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,_)), p, n)  
	  => (str,tp)
	
	(** The rule above failed, count the number of connectors in the first public list, subtract the number 
	 ** and try the rest of the list **)
  rule	count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([Absyn.PUBLIC(elt)],cmt))) => c1 &
	int_sub(n,c1) => c2 &
	get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt)),p,c2) => (str,tp)
	--------------------------------------------------
	get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt)), p, n) => (str,tp)
	
  rule	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt)), p, n) => (str,tp)
	-----------------------------------------------------
	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt)), p, n) => (str,tp)
	
end

(** relation: get_nth_connector_str
 ** This relation takes an ElementItem list and an int and  returns the name of the nth connector component
 ** in that list. 
 **)

relation get_nth_connector_str: (Absyn.Program, Absyn.Path, Absyn.ElementItem list
				 ,int)
	  => (string, Absyn.Path) =

  rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	get_nth_public_connector_str(newmodelpath,cdef,p,n) => (str,tp)
	-----------------
	get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,_,NONE))::lst,n) => (str,tp)

  rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	count_public_connectors(newmodelpath,p,cdef) => c1 &
	int_sub(n,c1) => c2 &
	get_nth_connector_str(p,modelpath,lst,c2) => (str,tp)
	-----------------
	get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,_,NONE))::lst,n) => (str,tp) 

  rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_), newmodelpath) &
	get_nth_compname(complst,n) => str 
	----------------------------------
	get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,_,NONE))::lst, n) 
	  => (str,tp)

  rule	(** Not so fast, since we lookup and instantiate two times just because this was not 
	 ** the connector we were looking for. **)
	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_), newmodelpath) &
	list_length(complst) => c1 &
	int_sub(n,c1) => newn &
	get_nth_connector_str(p,modelpath,lst,newn) => (str,tp)
	---------------------------------------
	get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,_,NONE))::lst, n)
	  => (str,tp)
	
  rule	get_nth_connector_str(p,modelpath,lst,n) => (str,tp)
	---------------------------------------
	get_nth_connector_str(p,modelpath,_::lst,n) => (str,tp)

  axiom	get_nth_connector_str(p,modelpath,[],n) => fail
end

relation get_nth_compname: (Absyn.ComponentItem list, int) => string =

  axiom	get_nth_compname (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_)::lst,1) => id
	
  rule	int_sub(n,1) => n1 &
	get_nth_compname (xs, n1) => res
	--------------------------------
	get_nth_compname (_::xs,n ) => res
  axiom	get_nth_compname ([],_) => fail
end

(* This relation takes a Class and counts the number of connector components in the class. 
 * This also includes counting in inherited classes.
 *)
relation count_public_connectors: (Absyn.Path, Absyn.Program, Absyn.Class) => int =
	
  rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt))) => c1 &
	count_connectors(modelpath,p,elt) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_public_connectors (modelpath, p,  Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt))) 
	    => res
	    
  rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt))) => res
	-----------------------------------------------------
	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt))) => res
	
  axiom count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt))) => 0

  rule	lookup_classdef(cname,modelpath,p) => (cdef,newmodelpath) &
	count_public_connectors (newmodelpath,p,cdef) => res
	--------------------------------------------------
	count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(cname,_,_,_,_))) => res
end

(** relation: count_connectors
 ** This relation takes a Path to the current model and a ElementItem list and returns the number 
 ** of connector components in that list.
 **)
relation count_connectors: (Absyn.Path, Absyn.Program, Absyn.ElementItem list) => int =

  rule	lookup_classdef(tp, modelpath,p) => (cdef,newmodelpath) &
	count_public_connectors(newmodelpath,p,cdef) => c1 &
	count_connectors(modelpath,p,lst) => c2 &
	int_add(c1,c2) => res
	---------------------
	count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,_,NONE))::lst) => res

  rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_), newmodelpath) &
	list_length(complst) => c1 &
	count_connectors(modelpath,p,lst) => c2 &
	int_add(c1,c2) => res
	--------------------
	count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,_,NONE))::lst) => res

	
	(* Rule above didn't match => element not connector components, try rest of list*)
  rule	count_connectors(modelpath, p, lst) => res 
	---------------------
	count_connectors(modelpath, p, _::lst) => res

  axiom	count_connectors(_, _, []) => 0
end

(** relation: get_connection_annotation_str
 ** This relation takes an `EquationItem' and returns a comma separated string of values 
 ** from the flat record of a connection annotation that is found in the `EquationItem'.
 **)
relation get_connection_annotation_str: Absyn.EquationItem => string =
	
  rule	create_funcargs_from_elementargs(elts) => fargs &
	Parser.parsestring Line_records => (p,parsestr) & (* Always succeeds, check parsestr for errors *)
 	parsestr = "Ok" &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	Static.elab_graphics_exp(env,Absyn.CALL(Absyn.CREF_IDENT("Line",[]),fargs)) => (newexp,_) &	
	Exp.print_exp_str(newexp) => gexpstr 
	-------------------------------------------------
	get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_), SOME(Absyn.COMMENT(SOME(Absyn.ANNOTATION([Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Line",_),SOME(Absyn.CLASSMOD(elts,NONE)),_)])),_))))
	  => gexpstr
	
  axiom	get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),NONE)) => fail

end

relation create_funcargs_from_elementargs: Absyn.ElementArg list => Absyn.FunctionArgs =

  axiom	create_funcargs_from_elementargs([]) => Absyn.FUNCTIONARGS([],[])

  rule	create_funcargs_from_elementargs(xs) => Absyn.FUNCTIONARGS(expl,narg)
	----------------
	create_funcargs_from_elementargs(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),SOME(Absyn.CLASSMOD(_,SOME(exp))),_)::xs)
	  => Absyn.FUNCTIONARGS(expl,Absyn.NAMEDARG(id,exp)::narg)

  rule	create_funcargs_from_elementargs(xs) => Absyn.FUNCTIONARGS(expl,narg)
	----------------
	create_funcargs_from_elementargs(_::xs)
	  => Absyn.FUNCTIONARGS(expl,narg)
end


(**relation: get_nth_connectionitem_in_class
 ** This relation takes a `Class' and  an int ane returns the nth `EquationItem' containing a
 ** connect statement in that class.
**)
relation get_nth_connectionitem_in_class: (Absyn.Class, int) => Absyn.EquationItem =

  rule	get_nth_connectionitem_in_classparts(parts,n) => eq
	-------------------------
	get_nth_connectionitem_in_class ( Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)),n) => eq
end

(**relation: get_nth_connectionitem_in_classparts
 ** This relation takes a `ClassPart' list and an int and returns 
** the nth connections as an `EquationItem'.
**)

relation get_nth_connectionitem_in_classparts: (Absyn.ClassPart list, int) => Absyn.EquationItem =
	
  rule	get_nth_connectionitem_in_equations(e,n) => eq
	-------------------------------------
	get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

	(* The rule above failed, subtract the number of connections in the first equation section *)
	(* and try with the rest of the classparts*)
  rule	count_connections_in_equations(e) => c1 &
	int_sub(n,c1)=> newn &
	get_nth_connectionitem_in_classparts(xs,newn) => eq
	-----------------------------------------------
	get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

  rule	get_nth_connectionitem_in_classparts(xs,n) => eq
	--------------------------------------------
	get_nth_connectionitem_in_classparts(_::xs,n) => eq

end

(** relation: get_nth_connection_in_equations
   ** This relation takes  an `Equation' list and an int and 
   ** returns the nth connection as an `Equation'. If the number is larger than the number of connections
 ** in the list, the relation fails.
**)
relation get_nth_connectionitem_in_equations: (Absyn.EquationItem list, int) => Absyn.EquationItem =

axiom	get_nth_connectionitem_in_equations ((eq as Absyn.EQUATIONITEM((Absyn.EQ_CONNECT(_,_)),_))::xs,1) => eq

  rule	int_sub (n,1) => newn &
	get_nth_connectionitem_in_equations (xs,newn) => eq
	-----------------------------------------------
	get_nth_connectionitem_in_equations (Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs,n) => eq

  rule	get_nth_connectionitem_in_equations (xs,n) => eq
	--------------------------------------------
	get_nth_connectionitem_in_equations (_::xs,n) => eq

  axiom get_nth_connectionitem_in_equations([],_) => fail
end

(** relation: get_connection_str
   ** This relation takes an `Equation' assumed to contain a connection and returns a 
   ** comma separated string of componentreferences, e.g "R1.n,C.p" for  connect(R1.n,C.p).
   **)
relation get_connection_str:  Absyn.Equation => string =
  rule	Absyn.cref_to_path cr1 => p1 &
	Absyn.cref_to_path cr2 => p2 &
	Absyn.path_string p1 => s1 &
	Absyn.path_string p2 => s2 &
	string_append(s1,",") => s3 &
	string_append(s3,s2) => str
	---------------------------
	get_connection_str Absyn.EQ_CONNECT(cr1,cr2) => str
end 

(** relation: count_connections
 ** This relation takes a `Class' and returns an int with the number of connections
** in the `Class'.
**)
relation count_connections: Absyn.Class => int =
	
  rule	count_connections_in_classparts(parts) => count
	-----------------------------------------------
	count_connections Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)) => count
end

(** relation: count_connections_in_classparts
 ** This relation takes a `ClassPart' list and returns an int with the number of connections in that list.
**)
relation count_connections_in_classparts: Absyn.ClassPart list => int =

  rule	count_connections_in_equations(eqlist) => r1 &
	count_connections_in_classparts(xs) => r2 &
	int_add (r1,r2) => res
	----------------------
	count_connections_in_classparts( Absyn.EQUATIONS(eqlist)::xs) => res

  rule	count_connections_in_classparts(xs) => res
	------------------------------------------
	count_connections_in_classparts( _::xs) => res
	
	axiom count_connections_in_classparts([]) => 0
end

(** relation: count_connections_in_equations
 ** This relation takes an `Equation' list and returns  an int 
 ** with the number of connect statements in that list.
**)
relation count_connections_in_equations: Absyn.EquationItem list => int =
	
  rule	count_connections_in_equations(xs) => r1 &
	int_add(r1,1)  => res 
	---------------------
	count_connections_in_equations(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs) => res
	
  rule	count_connections_in_equations(xs) => res
	-----------------------------------------
	count_connections_in_equations(_::xs) => res
	
  axiom	count_connections_in_equations([]) => 0
end

relation get_component_annotations_from_elts: (Absyn.Element list) 
	  => string =

  rule
	Parser.parsestring Placement_records => (p,parsestr) & (* Always succeeds, check parsestr for errors *)
	parsestr = "Ok" &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	get_componentitems_annotations(comps,env) => res &
	Util.string_delimit_list(res,",") => res'
	------------------------------------------------
	get_component_annotations_from_elts(comps) => res'
end

relation get_componentitems_annotations: (Absyn.Element list, Env.Env) 
	  => string list =

  axiom	get_componentitems_annotations([],_) => []

  rule	get_componentitems_annotations_from_items(items,env)
	  => res1 &
	  get_componentitems_annotations(rest,env) => res2 &
	list_append(res1,res2) => res
	------------------------
	get_componentitems_annotations(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,items),_,_,_)::rest,env) 
	  => res
  rule	get_componentitems_annotations(rest,env) => res2 &
	list_append(["{}"],res2) => res
	------------------------
	get_componentitems_annotations(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,_),_,_,_)::rest,env) 
	  => res

  rule	get_componentitems_annotations(rest,env) => res 
	------------------------
	get_componentitems_annotations(_::rest,env) => res
end



relation get_componentitems_annotations_from_items: (Absyn.ComponentItem list,
					  Env.Env) 
	  => string list =

  axiom	get_componentitems_annotations_from_items ([],env) => []

  rule	Lookup.lookup_class(env,Absyn.IDENT("Placement"),false) => (c,env') &
	SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false) => mod' &
	Mod.elab_mod(env',Prefix.NOPRE,mod') => mod'' &
	Inst.inst_class(env', mod'', Prefix.NOPRE, [], c,
			[], false,Inst.TOP_CALL) 
	  => (dae, _, cs, t, state) &
	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
     	DAE.get_variable_bindings_str dae' => gexpstr &
	Util.string_append_list(["{",gexpstr,"}"]) => gexpstr' &
	
	get_componentitems_annotations_from_items(rest,env) => res
	-----------------------------------------------
	get_componentitems_annotations_from_items(Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(SOME(
		Absyn.ANNOTATION(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Placement",_),SOME(Absyn.CLASSMOD(mod,NONE)),_)::_)
	),_)))::rest,env)
	  => gexpstr'::res

  rule	get_componentitems_annotations_from_items(rest,env) => res 
	-----------------------
	get_componentitems_annotations_from_items (Absyn.COMPONENTITEM(_,NONE)::(rest as _::_),env) => "{},"::res

  axiom	get_componentitems_annotations_from_items ([Absyn.COMPONENTITEM(_,NONE)],env) => ["{}"]

end

(** relation: get_component_annotation
 ** This relation takes an `Element' and returns a comma separated string of values
 ** corresponding to the flat record for a component annotation. If several components are declared 
 ** within the eleement, a list of values is given for each of them.
**)
relation get_component_annotation: Absyn.Element => string =
	
  rule	get_componentitems_annotation(lst) => str
	-----------------------------------------
	get_component_annotation(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_,NONE)) => str
	axiom get_component_annotation _ => ""
end 

relation get_componentitems_annotation: Absyn.ComponentItem list => string =
	
  rule	get_annotation_string(Placement_records, Absyn.ANNOTATION(mod)) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"},") => s3 &
	get_componentitems_annotation(rest) => str &
	string_append(s3,str) => res
	----------------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(SOME(
		Absyn.ANNOTATION(mod as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Placement",_),_,_)::_)
	),_)))::(rest as (_::_))) => res
	
  rule	get_annotation_string(Placement_records, Absyn.ANNOTATION(mod)) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => res 
	----------------------------
	get_componentitems_annotation ([Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(SOME(
	Absyn.ANNOTATION(mod as Absyn.MODIFICATION(_,_, Absyn.CREF_IDENT("Placement",_),_,_)::_)
	),_)))]) => res

  rule	get_componentitems_annotation(rest) => str &
	string_append("{nada},",str) => res
	-----------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(NONE,_)))::(rest as (_::_))) => res

  rule	get_componentitems_annotation(rest) => str &
	string_append("{},",str) => res
	-----------------------
	get_componentitems_annotation (Absyn.COMPONENTITEM(_,NONE)::(rest as (_::_))) => res

  rule	let res = "{}"
	-----------------------
	get_componentitems_annotation ([Absyn.COMPONENTITEM(_,NONE)]) => res
end

(** relation: get_component_modification
 ** This relation takes an `Element' and returns a comma separated list of 
 ** Code expression for the modification of the component.
**)
relation get_component_modification: Absyn.Element => string =
	
  rule	get_componentitems_modification(lst) => str
	-----------------------------------------
	get_component_modification(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_,NONE)) => str
	axiom get_component_modification _ => ""
end 

relation get_componentitems_modification: Absyn.ComponentItem list => string =
	
  rule	Dump.print_exp_str Absyn.CODE(Absyn.C_MODIFICATION(mod)) => s1 &
	get_componentitems_modification(rest) => s2 &
	Util.string_append_list([s1,",",s2]) => res
	-------------------------------------------
	get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(mod)),_)::(rest as (_::_))) => res
	
  rule	Dump.print_exp_str Absyn.CODE(Absyn.C_MODIFICATION(mod)) => res
	-------------------------------------------------------------
	get_componentitems_modification ([Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(mod)),_)]) => res

  rule	get_componentitems_modification(rest) => str &
	string_append("Code(),",str) => res
	-----------------------
	get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,NONE),_)::(rest as (_::_))) => res

  rule	get_componentitems_modification(rest) => str &
	string_append("Code(),",str) => res
	-----------------------
	get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,NONE),_)::(rest as (_::_))) => res

  rule	let res = "Code()"
	-----------------------
	get_componentitems_modification ([Absyn.COMPONENTITEM(_,NONE)]) => res
end


(** relation_ get_annotation_string
 ** This relation takes an annotation and returns a comma separates string of values
 ** representing the flat record of the specific annotation.
 ** The relation as two special rules for handling of Icon and Diagram annotations since these 
 ** two contain graphic primitives, which must be handled specially because Modelica does not have 
 ** the possibility to store polymorphic values (e.g. different record classes with the same base class)
 ** in for instance an array.
**)

relation get_annotation_string: (string,Absyn.Annotation) => string =

  rule	strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(_,SOME(graphicexp))),_)]) &
	SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &
	Parser.parsestring totstring => (p,parsestr) & (* Always succeeds, check parsestr for errors *)
	parsestr = "Ok" &
	SCode.elaborate(p) => p' &
	Inst.make_simple_env_from_program(p',Absyn.IDENT("Icon")) => env  & 
	get_class_in_program("Icon",p) => placementc &
	SCode.elab_class(placementc) => placementclass &
	Mod.elab_mod (env,Prefix.NOPRE,mod') => mod'' &	
	Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			[], false,Inst.TOP_CALL) 
	  => (dae, _, cs, t, state) &
	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
     	DAE.get_variable_bindings_str dae' => str  &
	Static.elab_graphics_exp(env,graphicexp) => (graphicexp2,prop) &

	Exp.print_exp_str(graphicexp2) => gexpstr &
	string_append(str,",") => s1 &
	string_append(s1,gexpstr) => totstr
	-----------------------------------
	get_annotation_string(totstring,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => totstr

  rule	strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(_,SOME(graphicexp))),_)]) &
	SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &
	Parser.parsestring totstring => (p,parsestr) & (* Always succeeds, check parsestr for errors *)
	parsestr = "Ok" &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("Diagram")) => env  & 
	get_class_in_program("Diagram",p) => placementc &
	SCode.elab_class(placementc) => placementclass &
	Mod.elab_mod (env,Prefix.NOPRE,mod') => mod'' &
	Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			[], false,Inst.TOP_CALL) 
	  => (dae, _,cs, t, state) &

	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
     	DAE.get_variable_bindings_str dae' => str  &
	
	Static.elab_graphics_exp(env,graphicexp) => (graphicexp2,prop) &
	Exp.print_exp_str(graphicexp2) => gexpstr &
	string_append(str,",") => s1 &
	string_append(s1,gexpstr) => totstr
	-----------------------------------
	get_annotation_string(totstring,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Diagram",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => totstr

  rule	SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false) => mod' & 
	Parser.parsestring totstring => (p,parsestr) & (* Always succeeds, check parsestr for errors *)
	parsestr = "Ok" &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT(anncname)) => env  & 
	get_class_in_program(anncname,p) => placementc &
	SCode.elab_class(placementc) => placementclass &
	Mod.elab_mod (env,Prefix.NOPRE,mod') => mod'' &
	Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			[], false,Inst.TOP_CALL) 
	  => (dae, _, cs, t, state) &
	(* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	Inst.init_vars_modelica_output dae => dae' &
     	DAE.get_variable_bindings_str dae' => str 
	-----------------------------------------
	get_annotation_string(totstring, Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(anncname,_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => str

  rule	Print.print_buf "get_annotation_string failed!\n"
	---------------------------------------
	get_annotation_string(_,_) => fail
end

(** relation: strip_graphics_modification
 ** This relation strips out the `graphics' modification from an ElementArg list and return 
 ** two lists, one with the other modifications and the second with the `graphics' modification
**)
relation strip_graphics_modification: (Absyn.ElementArg list) => (Absyn.ElementArg list, Absyn.ElementArg list) =
	
  axiom	strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("graphics",_),_,_))::rest) => (rest, [mod])
	
  rule	strip_graphics_modification(rest) => (l1,l2) 
	------------------------------------------
	strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,_,_,_))::rest) => (mod::l1,l2)

  axiom	strip_graphics_modification([]) => ([],[])
end
	

(** relation: get_components_in_class
 ** 
 ** Both public and protected lists are searched.
**)
relation get_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt))) => []
	  
  (* Search in public list *)
  rule	get_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt))) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt))) => res

  (* Search in protected list *)
  rule	get_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt))) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt))) => res

  axiom	get_components_in_class(_) => []
end

relation get_components_in_elementitems: (Absyn.ElementItem list) 
	  => Absyn.Element list =

  axiom	get_components_in_elementitems([]) => []

  rule	get_components_in_elementitems(rest) => res
	-------------------------------------------
	get_components_in_elementitems(Absyn.ELEMENTITEM(elt)::rest) 
	  => elt::res

  rule	get_components_in_elementitems(rest) => res
	-------------------------------------------
	get_components_in_elementitems(_::rest) => res
end

relation get_nth_component_in_class:  (Absyn.Class,int) => Absyn.Element =
	
  rule	count_components_in_elts(elt) => count &
	int_le(n,count) => true &
	get_nth_component_in_elementitems(elt,n) => res
	-----------------------------------------------
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt)),n) 
	    => res
	    
	    (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	    (* subtract and try next public list *)
  rule	count_components_in_elts(elt) => c1 &
	int_sub(n,c1) => newn &
	int_string(newn) => newnstr &
	int_gt(newn,0) =>  true &
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt)),newn) => res
	------------------------------------------------------------------------------------
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::rest,cmt)),n) => res

  rule	get_nth_component_in_elementitems(elt,n) => res
	-----------------------------------------------
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt)),n) 
	    => res
	    
	    (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	    (* subtract and try next public list *)
  rule	count_components_in_elts(elt) => c1 &
	int_sub(n,c1) => newn &
	int_gt(newn,0) => true &
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt)),newn) => res
	------------------------------------------------------------------------------------
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::rest,cmt)),n) => res

  rule	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt)),n) => res
	-----------------------------------------------------------------------
	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt)),n) => res
	
  axiom get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt)),_) => fail
  axiom get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(_,_,_,_,_)),_) => fail

end

(** relation: get_elementitems_in_class
 ** 
 ** Both public and protected lists are searched.
**)
relation get_elementitems_in_class: (Absyn.Class) => Absyn.ElementItem list =

  axiom	 get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt))) => []
	  
        (* Search in public list *)
  rule	get_elementitems_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt))) => lst1 &
        list_append(elts,lst1) => lst 
		------------------------------
	    get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt))) => lst
        
        (* Search in protected list *)
  rule	get_elementitems_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt))) => lst1 &
        list_append(elts,lst1) => lst 
	    ------------------------------
	    get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt))) => lst
        
  axiom get_elementitems_in_class(_) => []
end

(** relation: get_nth_component_in_elementintems 
 ** This relation takes an `ElementItem' list and and integer and returns the nth component 
 ** in the list
**)
relation get_nth_component_in_elementitems: (Absyn.ElementItem list, int) 
	  => Absyn.Element =

  axiom	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,elt::_),g,h,i))::_,1) 
	  => Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,[elt]),g,h,i)

  rule	list_length(lst) => numcomps &
	int_gt(n,numcomps) => true &
	int_sub(n,numcomps) => newn &
	get_nth_component_in_elementitems(rest,newn) => res
	---------------------------------------------------
	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_,_))::rest,n) => res

  rule	list_length(lst) => numcomps &
	int_le(n,numcomps) => true &
	int_sub(n,1) => n' &
	list_nth(lst,n') => elt
	-----------------------------
	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt as Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,lst),g,h,i))::rest,n) 
	  => Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,[elt]),g,h,i)


(*  rule	int_ge(n,1) => true &
	get_nth_component_in_elementitems(rest,n) => res
	---------------------------------------------------
	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,n) => res*)

  rule	get_nth_component_in_elementitems(rest,n) => res
	------------------------------------------------
	get_nth_component_in_elementitems(_::rest,n) => res

  axiom	get_nth_component_in_elementitems([],_) => fail
end

relation get_components_name_and_type_and_comment: (Absyn.Element list, Env.Env) => string =

rule	get_components_name_and_type_and_comment2(elts,env) => lst &
	Util.string_delimit_list(lst,"},{") => lst' &
	Util.string_append_list(["{",lst',"}"]) => res
	-----------------------------------------------
	get_components_name_and_type_and_comment(elts,env) => res
end

relation get_components_name_and_type_and_comment2: (Absyn.Element list, Env.Env) => string list =
  axiom	get_components_name_and_type_and_comment2([],_) => []

  rule	get_component_name_and_type_and_comment(elt,env) => lst1 &
	get_components_name_and_type_and_comment2(rest,env) => lst2 &
	list_append(lst1,lst2) => res
	----------------------------------------------------------
	get_components_name_and_type_and_comment2(elt::rest,env) => res
end

(** relation: get_component_name_and_type_and_comment
 ** This relation takes an `Element' and returns a list of strings 
 ** of comma separated values of the 
 **  type and name and comment of the component, e.g. 'Resistor,R1, "comment"' 
 ** or 'Resistor,R1,"comment1",R2,"comment2"'
 ** If Element is not a component, the empty string is returned
**)
relation get_component_name_and_type_and_comment: (Absyn.Element,Env.Env) 
	  => string list =

  rule	Lookup.lookup_class(env,p,true) => (c,env') &
	Env.get_env_path(env') => SOME(envpath) &
	Absyn.path_last_ident(p) => tpname &
	Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	Absyn.path_string(p') => typename &
	get_componentitems_name(lst) => names &
	prefix_typename(typename,names) => lst
	-------------------------------------------
	get_component_name_and_type_and_comment(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,p,lst),_,_,_),env) => lst

	rule	Absyn.path_string(p) => typename &
	get_componentitems_name(lst) => names &
	prefix_typename(typename,names) => lst
	-------------------------------------------
	get_component_name_and_type_and_comment(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,p,lst),_,_,_),env) => lst

	axiom	get_component_name_and_type_and_comment(_,env) => []

  rule	print "get_component_name_and_type_and_comment failed\n"
	-------------------------------------------
	get_component_name_and_type_and_comment(_,_) => fail
end

relation prefix_typename: (string, string list) => string list =
  axiom	prefix_typename (_,[]) => []

  rule	prefix_typename(tp,rest) => res &
	Util.string_append_list([tp,",",str]) => str'
	---------------------
	prefix_typename(tp,str::rest) => str'::res
end


(** relation_get_componentitems_name
 ** This relation takes a `ComponentItems' list and returns a 
 ** comma separated list of all
 ** component names and comments (if any).
**)
relation get_componentitems_name: Absyn.ComponentItem list => string list =
	
  rule	string_append(c1,",") => s1 &
	get_componentitems_name(c2::rest) => lst &
	Util.string_append_list([s1,"\"",s2,"\""]) => str
	----------------------------
	get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),SOME(Absyn.COMMENT(_,SOME(s2))))::(c2::rest)) => str::lst

  rule	string_append(c1,",") => s1 &
	get_componentitems_name(c2::rest) => lst &
	Util.string_append_list([s1,"\"\""]) => str
	----------------------------
	get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),NONE)::(c2::rest)) => str::lst

  rule	get_componentitems_name(rest) => res
	------------------------------------
	get_componentitems_name(_::rest) => res

  rule	Util.string_append_list([c1,",\"",s2,"\""]) => res
	----------------------
	get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),SOME(Absyn.COMMENT(_,SOME(s2))))]) => [res]

  rule  Util.string_append_list([c1,",\"\""]) => res
	---------------------------------------
	get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_)]) => [res]

  axiom	get_componentitems_name([_]) => []
end
(** relation: add_to_public
 ** This relation takes a 'Class' definition and adds an `ElementItem' to the first public list in the class.
 ** If no public list is available in the class one is created.
 **)
relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

  rule	get_public_list(parts) => publst &
	list_append(publst,[eitem]) => publst2 &
	replace_public_list(parts,publst2) => parts2 
	--------------------------------------------
	add_to_public ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)), eitem) 
	    => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))

  axiom	add_to_public ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_)),eitem) => fail

  axiom	add_to_public(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)),eitem)
	    => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(Absyn.PUBLIC([eitem])::parts,cmt))

end

(** relation: add_to_protected
 ** This relation takes a 'Class' definition and adds an `ElementItem' to the first protected list in the class.
 ** If no protected list is available in the class one is created.
 **)
relation add_to_protected: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

  rule	get_protected_list(parts) => protlst &
	list_append(protlst,[eitem]) => protlst2 &
	replace_protected_list(parts,protlst2) => parts2 
	--------------------------------------------
	add_to_protected ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)), eitem) 
	    => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))

  axiom	add_to_protected ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_)),eitem) => fail

  axiom	add_to_protected(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)),eitem)
	    => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(Absyn.PROTECTED([eitem])::parts,cmt))

end

(** relation: add_to_equation
 ** This relation takes a 'Class' definition and adds an `EquationItem' to the first equation list in the class.
 ** If no public list is available in the class one is created.
 **)
relation add_to_equation: (Absyn.Class, Absyn.EquationItem) => Absyn.Class = 

  rule	get_equation_list(parts) => eqlst &
	let eqlst2 = eitem::eqlst &
	replace_equation_list(parts,eqlst2) => parts2 
	--------------------------------------------
	add_to_equation ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)), eitem) 
	    => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt))

  axiom	add_to_equation ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_)),eitem) => fail

  rule	(* Add the equations last, to make nicer output if public section present *)
	list_append(parts,[Absyn.EQUATIONS([eitem])]) => newparts
	------------------
	add_to_equation(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt)),eitem)
	    => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(newparts,cmt))
end


(** relation: replace_class_in_program
 ** This relation takes a `Class' and a `Program' and replaces the class definition 
 ** at the top level in the program by the class definition of the `Class'.
 **)
relation replace_class_in_program: (Absyn.Class, Absyn.Program) => Absyn.Program =
  axiom replace_class_in_program(c, Absyn.PROGRAM([],w)) => Absyn.PROGRAM([c],w)
  rule	name1 = name2
	-------------
	replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_,_),Absyn.PROGRAM(Absyn.CLASS(name2,_,_,_,_,_)::clst,w))
	    => Absyn.PROGRAM(c::clst,w)
	    
  rule	not name1 = name2 &
	replace_class_in_program(c, Absyn.PROGRAM(clst,w)) => Absyn.PROGRAM(newclst,w)
	-------------------------------------------------------
	replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_,_),
	    Absyn.PROGRAM((c1 as Absyn.CLASS(name2,_,_,_,_,_))::clst,w)) 
	    => Absyn.PROGRAM(c1::newclst,w)

  rule	Print.print_buf "replace_class_in_program failed \n class:" &
	Debug.fcall ("dump", Dump.dump, Absyn.PROGRAM([c],Absyn.TOP)) &
	Print.print_buf "\nprogram: \n" &
	Debug.fcall ("dump", Dump.dump, p)
	----------------------------
	replace_class_in_program(c,p) => fail
end
	
(** relation: insert_class_in_program 
 ** This relation inserts the class into the Program at the scope given by the 
 ** within argument. If the class referenced by the within argument is not 
 ** defined, the relation prints an error message and fails.
 **)
	
relation insert_class_in_program: (Absyn.Class, Absyn.Within, Absyn.Program) => Absyn.Program =

  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &
	update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1,w as Absyn.WITHIN(Absyn.QUALIFIED(n1,_)),p) => pnew
	
  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &
	update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1, w as Absyn.WITHIN(Absyn.IDENT(n1)),p) => pnew
	
  rule	print "Error inserting in class. (" & Dump.unparse_within(0, w) => s1 & print s1 
	& print ") program = \n" (*& Dump.unparse_str p => pstr & print pstr & print "\n"  *)
	-------------------
	insert_class_in_program(c1 as Absyn.CLASS(name,_,_,_,_,_),w,p) => fail	
end

(** relation: insert_class_in_class
 ** This relation takes a class to update (the first argument)  and an inner 
 ** class (which is either replacing
 ** an earlier class or is a new inner definition) and a within statement
 ** pointing inside the class (including the class itself in the reference), and updates the class with the inner class.
 **)
relation insert_class_in_class: (Absyn.Class, Absyn.Within, Absyn.Class) => Absyn.Class =
	
  rule	replace_inner_class(c1,c2) => cnew  
	----------------------------------
	insert_class_in_class(c1,Absyn.WITHIN(Absyn.IDENT(name)),c2) => cnew

  rule  get_first_ident_from_path(path) => name2 &
        get_inner_class(c2,name2) => cinner &
	insert_class_in_class(c1,Absyn.WITHIN(path),cinner) => cnew &
        replace_inner_class(cnew,c2) => cnew' 
	---------------------------------------------
	insert_class_in_class(c1,Absyn.WITHIN(Absyn.QUALIFIED(name,path)),c2) => cnew'
	
  rule	Print.print_buf "insert_class_in_class failed\n" 
	-------------------------------------
	insert_class_in_class(_,_,_) => fail
end

(** relation: get_first_ident_from_path
 ** This relation takes a `Path` as argument and returns the first `Ident' of the path.
 **)
relation get_first_ident_from_path: Absyn.Path => Absyn.Ident =
     axiom get_first_ident_from_path (Absyn.IDENT(name)) => name
     axiom get_first_ident_from_path (Absyn.QUALIFIED(name,path)) => name
end

(** relation: remove_inner_class 
 ** This relation takes two class definitions. The first one is the local class that should be
 ** removed from the second one.
 **)
relation remove_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

  rule	get_public_list(parts) => publst &
	remove_class_in_elementitemlist(publst,c1) => publst2 &
	replace_public_list(parts,publst2) => parts2 
	-----------------------------------------------
	remove_inner_class (c1,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt))) 
	    => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt))

  rule	Print.print_buf "Failed in remove_inner_class\n"
	---------------------------------------
	remove_inner_class (_,_) => fail
end

(** relation: remove_class_in_elementitemlist
 ** This relation takes an Element list and a Class and returns a modified element list
 ** where the class definition of the class is removed.
  **)
relation remove_class_in_elementitemlist: (Absyn.ElementItem list, Absyn.Class) => Absyn.ElementItem list =
	
  rule	remove_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	remove_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

  rule	not name1 = name &
	remove_class_in_elementitemlist(xs,c) => res
	------------------------------------------
	remove_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_)),_,_,NONE)))::xs,c as Absyn.CLASS(name,_,_,_,_,_)) => e1::res
	
  rule name1 = name 
	-----------------------------
	remove_class_in_elementitemlist(
	    (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, Absyn.CLASS(name1,_,_,_,_,_)),f,g,h)))::xs,
	    c2 as Absyn.CLASS(name,_,_,_,_,_))
	    => xs
	
  rule	remove_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	remove_class_in_elementitemlist(c1::xs,c) => c1::res

  axiom	 remove_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c),"",0,NONE))]
end

(** relation: replace_inner_class 
 ** This relation takes two class definitions. The first one is inserted/replaced as a local class inside the second one.
 **)
relation replace_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

  rule	get_public_list(parts) => publst &
	replace_class_in_elementitemlist(publst,c1) => publst2 &
	replace_public_list(parts,publst2) => parts2 
	-----------------------------------------------
	replace_inner_class (c1,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt))) 
	    => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt))
  rule	Print.print_buf "Failed in replace_inner_class\n"
	---------------------------------------
	replace_inner_class (_,_) => fail
end

(** relation: replace_class_in_elementitemlist
 ** This relation takes an Element list and a Class and returns a modified element list
 ** where the class definition of the class is updated or added.
  **)
relation replace_class_in_elementitemlist: (Absyn.ElementItem list, Absyn.Class) => Absyn.ElementItem list =
	
  rule	replace_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	replace_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

  rule	not name1 = name &
	replace_class_in_elementitemlist(xs,c) => res
	------------------------------------------
	replace_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_)),_,_,NONE)))::xs,c as Absyn.CLASS(name,_,_,_,_,_)) => e1::res
	
  rule name1 = name 
	-----------------------------
	replace_class_in_elementitemlist(
	    (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, Absyn.CLASS(name1,_,_,_,_,_)),f,g,h)))::xs,
	    c2 as Absyn.CLASS(name,_,_,_,_,_))
	    => Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e,c2),f,g,h))::xs
	
  rule	replace_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	replace_class_in_elementitemlist(c1::xs,c) => c1::res

  axiom	 replace_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c),"",0,NONE))]
end

(** relation: get_inner_class
 ** This relation takes a class name and a class and return the inner class definition 
 ** having that name.
**)
relation get_inner_class: (Absyn.Class, Absyn.Ident) => Absyn.Class =
  rule	get_public_list(parts) => publst &
	get_class_from_elementitemlist(publst,name) => c1
	-----------------------------------------------
	get_inner_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_)), name) => c1

  rule	Print.get_string => str &
	Print.clear_buf &
	Print.print_buf "get_inner_class failed, c:" &
	Dump.dump Absyn.PROGRAM([c],Absyn.TOP) &
	Print.print_buf "name :" & Print.print_buf name & 
	Print.get_string => s1 & (*print s1 &*) Print.clear_buf & Print.print_buf str 
	--------------
	get_inner_class (c,name) => fail
end

(** relation: replace_public_list
 ** This relation replaces the `ElementItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_public_list: (Absyn.ClassPart list,Absyn.ElementItem list) => Absyn.ClassPart list =

  rule	delete_public_list(rest) => rest'
	---------------------------------
	replace_public_list ((lst as Absyn.PUBLIC(_))::rest,newpublst) 
	  => Absyn.PUBLIC(newpublst)::rest'
	
  rule	replace_public_list(xs,new) => ys
	---------------------------------
	replace_public_list(x::xs,new) => x::ys

  axiom replace_public_list([],_) => []
end

(** relation: replace_public_list
 ** This relation replaces the `ElementItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_protected_list: (Absyn.ClassPart list,Absyn.ElementItem list) => Absyn.ClassPart list =

  rule	delete_protected_list(rest) => rest'
	---------------------------------
	replace_protected_list ((lst as Absyn.PROTECTED(_))::rest,newprotlist) 
	  => Absyn.PROTECTED(newprotlist)::rest'
	
  rule	replace_protected_list(xs,new) => ys
	---------------------------------
	replace_protected_list(x::xs,new) => x::ys

  axiom replace_protected_list([],_) => []
end

relation delete_public_list:(Absyn.ClassPart list) 
	  => Absyn.ClassPart list =
  axiom	delete_public_list([]) => []

  rule	delete_public_list(xs) => res
	-----------------------------
	delete_public_list(Absyn.PUBLIC(_)::xs) => res

  rule	delete_public_list(xs) => res
	-----------------------------
	delete_public_list(x::xs) => x::res
end

relation delete_protected_list:(Absyn.ClassPart list) 
	  => Absyn.ClassPart list =
  axiom	delete_protected_list([]) => []

  rule	delete_protected_list(xs) => res
	-----------------------------
	delete_protected_list(Absyn.PROTECTED(_)::xs) => res

  rule	delete_protected_list(xs) => res
	-----------------------------
	delete_protected_list(x::xs) => x::res
end

(** relation: replace_equation_list
 ** This relation replaces the `EquationItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_equation_list: (Absyn.ClassPart list,Absyn.EquationItem list) => Absyn.ClassPart list =

  axiom replace_equation_list ((lst as Absyn.EQUATIONS(_))::rest,newpublst) 
	  => Absyn.EQUATIONS(newpublst)::rest
	
  rule	replace_equation_list(xs,new) => ys
	---------------------------------
	replace_equation_list(x::xs,new) => x::ys

  axiom replace_equation_list([],_) => []
end


(** relation: get_public_list
 ** This relation takes a ClassPart List and returns an appended list of all public lists.
 **
*)
relation get_public_list: Absyn.ClassPart list => Absyn.ElementItem list =
  axiom	get_public_list([]) => []
	
  rule	get_public_list(rest) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_public_list Absyn.PUBLIC(res1)::rest => res
	
  rule	get_public_list(xs) => ys
	---------------------------
	get_public_list(x::xs) => ys

end


(** relation: get_protected_list
 ** This relation takes a ClassPart List and returns an appended list of all protected lists.
 **
*)
relation get_protected_list: Absyn.ClassPart list => Absyn.ElementItem list =
  axiom	get_protected_list([]) => []
	
  rule	get_protected_list(rest) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_protected_list Absyn.PROTECTED(res1)::rest => res
	
  rule	get_protected_list(xs) => ys
	---------------------------
	get_protected_list(x::xs) => ys
end

(** relation: get_equation_list
 ** This relation takes a ClassPart List and returns the first EquationItem list of the class.
 **
*)
relation get_equation_list: Absyn.ClassPart list => Absyn.EquationItem list =

  axiom get_equation_list Absyn.EQUATIONS(lst)::rest => lst
	
  rule	get_equation_list(xs) => ys
	---------------------------
	get_equation_list(x::xs) => ys

  axiom get_equation_list(_) => fail
end


(** relation: get_class_from_elementitemlist
 ** This relation takes an ElementItem list and an Ident and returns the class definition
 ** among the element list having that identifier
  **)
relation get_class_from_elementitemlist: (Absyn.ElementItem list, Absyn.Ident) => Absyn.Class =
	
  rule	get_class_from_elementitemlist(xs,name) => res
	----------------------------------------------
	get_class_from_elementitemlist(Absyn.ANNOTATIONITEM(_)::xs,name) => res

  rule	name1 = name2
	------------------------------
	get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_)),_,_,NONE))::xs,name2) => c1

  rule	not name1 = name &
	get_class_from_elementitemlist(xs,name) => res
	------------------------------------------
	get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_)),_,_,NONE))::xs,name) => res

  rule	get_class_from_elementitemlist(xs,name) => res
	----------------------------------------------
	get_class_from_elementitemlist(_::xs,name) => res

  axiom	 get_class_from_elementitemlist([],_) => fail
end

(** relation: class_in_program
 ** This relation takes a name and a Program and returns true if the name exists as a top class in the program.
**)

relation class_in_program:(string,Absyn.Program) => bool = 

  axiom class_in_program (str,Absyn.PROGRAM([],_)) => false
	
  rule	not str = c1 &
	class_in_program(str,Absyn.PROGRAM(p,w)) => res
	-----------------------
	class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_,_)::p,w)) => res
	
  axiom class_in_program (_,_) => true
end

(** relation: get_pathed_class_in_program
 ** This relation takes a `Path' and a `Program` and retrieves the class definition referenced 
 ** by the `Path' from the `Program'.
*)
relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) => Absyn.Class =

  rule	get_class_in_program(str,p) => c1
	---------------------------------
	get_pathed_class_in_program (Absyn.IDENT(str),p) => c1
	
  rule	get_class_in_program(c1,p) => c1def &
	get_classes_in_class(Absyn.IDENT(c1),p,c1def) => classes &
	get_pathed_class_in_program(prest,Absyn.PROGRAM(classes,w)) => res
	------------------------------------------------------------
	get_pathed_class_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res
end

(** relation: get_classes_in_class
 ** This relation takes a `Class' definition and returns a list of local `Class' definitions of that class.-
 **)
relation get_classes_in_class: (Absyn.Path, Absyn.Program,Absyn.Class) => Absyn.Class list =

  rule	get_classes_in_parts(parts)  => res
	--------------------------
	get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_))) => res

  rule	lookup_classdef(path, modelpath,p) => (cdef,newpath) &
	get_classes_in_class(newpath,p,cdef) => res
	--------------------------------------------
	get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_))) => res
end

relation get_classes_in_parts: Absyn.ClassPart list => Absyn.Class list =

  axiom	 get_classes_in_parts [] => []	

  rule	get_classes_in_parts(rest) => l1 &
	get_classes_in_elts(elts) => l2 &
	list_append(l1,l2) => res
	------------------------
	get_classes_in_parts (Absyn.PUBLIC(elts)::rest) => res

  rule	get_classes_in_parts(rest) => l1 &
	get_classes_in_elts(elts) => l2 &
	list_append(l1,l2) => res
	------------------------
	get_classes_in_parts (Absyn.PROTECTED(elts)::rest) => res

  rule	get_classes_in_parts(rest) => res
	---------------------------------
	get_classes_in_parts(_::rest) => res
end

relation get_classes_in_elts: Absyn.ElementItem list => Absyn.Class list =
  axiom	get_classes_in_elts [] => []
  rule	get_classes_in_elts (rest) => res
	---------------------------------
	get_classes_in_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,class),_,_,NONE))::rest)
	    => class::res
  rule	get_classes_in_elts (rest) => res
	---------------------------------
	get_classes_in_elts (_::rest)
	    => res
end

(** relation: get_class_in_program
 ** This relation takes a Path and a Program and returns the class with the name `Path'.
 ** If that class does not exist, the relation fail
**)

relation get_class_in_program:(string, Absyn.Program) => Absyn.Class = 

  axiom get_class_in_program (str,Absyn.PROGRAM([],_)) => fail

  rule	not str = c1 &
	get_class_in_program(str,Absyn.PROGRAM(p,w)) => res
	-----------------------------------------
	get_class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_,_)::p,w)) => res
	
  rule  str = c1name
	------------
	get_class_in_program (str, Absyn.PROGRAM((c1 as Absyn.CLASS(c1name,_,_,_,_,_))::p,w)) => c1
end

(** relation: modification_to_absyn
 ** This relation takes a list of `NamedArg' and returns an absyn `Modification option'.
 ** It collects binding equation from the named argument binding=<expr> and creates
 ** corresponding Modification option Absyn node.
 ** Future extension: add general modifiers. Problem: how to express this using named 
 ** arguments. This is not possible. Instead we need a new data type for storing AST, 
 ** and a constructor function for AST, 
 ** e.g. AST x = ASTModification(redeclare R2 r, x=4.2); // new datatype AST
 **					 // new constructor operator ASTModification
 **)

relation modification_to_absyn: (Absyn.NamedArg list,
				 Absyn.Modification option) 
	  => Absyn.Modification option =

  rule	modification_to_absyn2(nargs) => SOME(mod)
	--------------------------------
	modification_to_absyn(nargs,oldmod) => SOME(mod)

  axiom	modification_to_absyn(nargs,oldmod) => oldmod
end

relation modification_to_absyn2: (Absyn.NamedArg list ) 
	  => Absyn.Modification option =
  axiom	modification_to_absyn2([]) => NONE
	
  axiom	modification_to_absyn2(Absyn.NAMEDARG("binding",exp)::xs) 
	  => SOME(Absyn.CLASSMOD([],SOME(exp)))

  axiom	modification_to_absyn2(Absyn.NAMEDARG("modification",
					     Absyn.CODE(Absyn.C_MODIFICATION(mod)))::xs)
	  => SOME(mod)

  rule	modification_to_absyn2(xs) => res
	--------------------------------
	modification_to_absyn2(x::xs) => res
end
(** relation: annotation_list_to_absyn_comment
 ** This relation takes a list of `NamedArg' and returns an absyn Comment.
 ** for instance [annotation = Placement( ...), comment="stringcomment" ] is converted to SOME(COMMENT(ANNOTATION(Placement(...),SOME("stringcomment")))) 
 **)
relation annotation_list_to_absyn_comment: (Absyn.NamedArg list,
					     Absyn.Comment option) 
	  => Absyn.Comment option =

  rule	annotation_list_to_absyn_comment2(nargs) => SOME(ann)
	----------------
	annotation_list_to_absyn_comment(nargs,oldann) => SOME(ann)

  axiom	annotation_list_to_absyn_comment(nargs,oldann) => oldann
end

relation annotation_list_to_absyn_comment2: (Absyn.NamedArg list) => Absyn.Comment option =

  rule	annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	comment_to_absyn(nargs) => SOME(strcmt)
	----------------------------------
	annotation_list_to_absyn_comment2(nargs) => SOME(Absyn.COMMENT(NONE,SOME(strcmt)))

  rule	annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	comment_to_absyn(nargs) => NONE
	----------------------------------
	annotation_list_to_absyn_comment2(nargs) => NONE

  rule	annotation_list_to_absyn(nargs) => annotation &
	comment_to_absyn(nargs) => strcmt
	----------------------------------
	annotation_list_to_absyn_comment2(nargs) => SOME(Absyn.COMMENT(SOME(annotation),strcmt))
	
  axiom	annotation_list_to_absyn_comment2(_) => NONE
end

relation comment_to_absyn: (Absyn.NamedArg list) => string option =

  axiom	comment_to_absyn(Absyn.NAMEDARG("comment",Absyn.STRING(str))::_) 
	  => SOME(str)

  rule	comment_to_absyn(rest) => res
	--------------------
	comment_to_absyn(_::rest) => res

  axiom	comment_to_absyn(_) => NONE
end

(** relation: annotation_list_to_absyn
 ** This relation takes a list of `NamedArg' and returns an absyn `Annotation'.
 ** for instance [annotation = Placement( ...) ] is converted to ANNOTATION(Placement(...)) 
 **)
relation annotation_list_to_absyn: (Absyn.NamedArg list) => Absyn.Annotation =
  axiom annotation_list_to_absyn( [] ) => Absyn.ANNOTATION([])
	
  rule	record_constructor_to_modification(e) => eltarg
	------------------------------------
	annotation_list_to_absyn(Absyn.NAMEDARG("annotate",e)::_) => Absyn.ANNOTATION([eltarg])
	
  rule	annotation_list_to_absyn(al) => annres
	--------------------------------------
	annotation_list_to_absyn(a::al) => annres
end
	
(** relation:record_constructor_to_modification
 ** This relation takes a record constructor expression and translates it into a `ElementArg'.
 ** Since modifications must be named, only named arguments are treated in the record constructor.
 **)
relation record_constructor_to_modification: (Absyn.Exp ) => Absyn.ElementArg =

  rule	(* Covers the case annotate=Diagram(x=1,y=2) *)
	Util.list_map(nargs,namedarg_to_modification) => eltarglst &
        let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,cr,SOME(Absyn.CLASSMOD(eltarglst,NONE)),NONE)
	-----------------------------------
	record_constructor_to_modification(Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs))) => res	
	
  rule	(* Covers the case annotate=Diagram(SOMETHING(x=1,y=2)) *)
	Util.list_map(nargs,namedarg_to_modification) => eltarglst &
        record_constructor_to_modification(e) => emod &
	let res = Absyn.MODIFICATION(false, Absyn.NON_EACH,
				     cr, SOME(Absyn.CLASSMOD(emod::eltarglst, NONE)), NONE)
	-----------------------------------
	record_constructor_to_modification(Absyn.CALL(cr,
						      Absyn.FUNCTIONARGS([e as Absyn.CALL(_,_)],nargs))) => res	


  rule	Print.print_buf "record_constructor_to_modification failed, exp=" & 
	Absyn.print_absyn_exp e & Print.print_buf "\n" 
	-------------------------
	record_constructor_to_modification(e) => fail
end

(** relation: namedarg_to_modification
 ** This relation takes a `NamedArg' and translates it into a `ElementArg'.
 **)
relation namedarg_to_modification: (Absyn.NamedArg) => Absyn.ElementArg = 

  rule	record_constructor_to_modification(c) => Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(elts,_)),NONE) &
	let cr' = Absyn.CREF_IDENT(id,[]) &
	let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,cr',SOME(Absyn.CLASSMOD(elts,NONE)),NONE)
	----------------------------
	namedarg_to_modification( Absyn.NAMEDARG(id,c as Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs)))) => res

  rule	let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,Absyn.CREF_IDENT(id,[]),SOME(Absyn.CLASSMOD([],SOME(e))),NONE)
	----------------------------------------------------------------
	namedarg_to_modification( Absyn.NAMEDARG(id,e)) => res

  rule	Print.print_buf "- namedarg_to_modification failed\n" 
	----------------
	namedarg_to_modification(_) => fail
end


(** relation: add_instantiated_class
 ** This relation adds an instantiated class to the list of instantiated classes.
 ** If the class path already exists, the class is replaced. 
 **)
 relation add_instantiated_class: (InstantiatedClass list, InstantiatedClass) => InstantiatedClass list =
	 
  axiom	add_instantiated_class ([],cl) => [cl]

  rule	ModUtil.path_equal(path,path2) => true
	---------------------------
	add_instantiated_class(INSTCLASS(path,dae,env)::xs, newc as INSTCLASS(path2,dae',env')) 
	  => newc::xs

  rule	ModUtil.path_equal(path,path2) => false &
	add_instantiated_class(xs, newc) => res 
	---------------------------
	add_instantiated_class((x as INSTCLASS(path,_,_))::xs, newc as INSTCLASS(path2,_,_)) 
	  => x::res
end

(** relation: get_instantiated_class
 ** This relation get an instantiated class from the list of instantiated classes.
 **)
 relation get_instantiated_class: (InstantiatedClass list, Absyn.Path) => InstantiatedClass =
	 
  rule	ModUtil.path_equal(path,path2) => true
	---------------------------
	get_instantiated_class((x as INSTCLASS(path,dae,env))::xs, path2) 
	  => x

  rule	ModUtil.path_equal(path,path2) => false &
	get_instantiated_class(xs, path2) => res 
	---------------------------
	get_instantiated_class((x as INSTCLASS(path,_,_))::xs, path2) 
	  => res
end
