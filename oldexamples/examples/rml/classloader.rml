(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 classloader.rml
 ** module:      ClassLoader
 ** description: Loading of classes from $MODELICAPATH.
 **
 ** RCS: $Id: classloader.rml,v 1.10 2004/09/28 15:09:44 levsa Exp $
 **
 ** This module loads classes from $MODELICAPATH. It exports only one
 ** relation: the load_class relation. It is currently (2004-09-27) 
 ** only used by ceval.rml when using the "loadclass" function in 
 ** the interactive environment.
 ** 
 **)

module ClassLoader:
  with "absyn.rml"

  relation load_class: (Absyn.Path, string) => (Absyn.Program) 

end

with "system.rml"
with "lookup.rml"
with "interactive.rml"
with "util.rml"
with "parse.rml"
with "print.rml"
with "env.rml"
with "dump.rml"

(** relation: load_class
 ** This relation takes a 'Path' and the $MODELICAPATH as a string
 ** and tries to load the class from the path.
 ** If the classname is qualified, the complete package is loaded. 
 ** E.g. load_class(Modelica.SIunits.Voltage) -> whole Modelica package loaded.
 **)
relation load_class: (Absyn.Path, string) => (Absyn.Program) =

	(* Simple names: Just load the file if it can be found in $MODELICAPATH *)
  rule System.group_delimiter => gd &	
	System.strtok(mp,gd) => mps &
	load_class_from_mps(classname,mps) => p
	-------------------------------------
	load_class(Absyn.IDENT(classname),mp) => p

	(* Qualified names: First check if it is defined in a file pack.mo *)
  rule	System.group_delimiter => gd &	
	System.strtok(mp,gd) => mps &
	load_class_from_mps(pack,mps) => p
	-------------------------------------
	load_class(Absyn.QUALIFIED(pack,rest),mp) => p

	(* Qualified names: Else, load the complete package and then check that *)
	(* the package contains the file *) 
  rule	System.group_delimiter => gd &	
	System.strtok(mp,gd) => mps &
	load_complete_package_from_mps(pack,mps,Absyn.TOP,Absyn.PROGRAM([],Absyn.TOP)) => p &
	Interactive.get_pathed_class_in_program(path,p)=> _
	-------------------------------------
	load_class(path as Absyn.QUALIFIED(pack,rest),mp) => p

  rule	print "load_class failed\n"
	-------------------
	load_class(_,_) => fail
end

relation exist_regular_file: (string) => () =

  rule	System.regular_file_exist filename => 0 
	----------------------------
	exist_regular_file(filename) 
end

relation exist_directory_file: (string) => () =

  rule	System.directory_exist filename => 0 
	----------------------------
	exist_directory_file(filename) 
end


relation load_class_from_mps: (Absyn.Ident, string list) => Absyn.Program =
	
  rule	load_class_from_mp(class,mp) => p
	----------------------------------
	load_class_from_mps(class,mp::mps) => p

  rule	load_class_from_mps(class,mps) => p
	----------------------------------
	load_class_from_mps(class,_::mps) => p

end

(** relation: load_class_from_mp
 ** 
 ** This relation loads a modelica class "className" from the file path "<mp>/className.mo"
 ** or it loads complete package from "<mp>/className/package.mo"
 **)
relation load_class_from_mp: (Absyn.Ident, string) => Absyn.Program =
	
  rule	System.path_delimiter => pd &
	string_append(class,".mo") => classfile &
	Util.string_append_list([mp,pd,classfile])=> classfile' &
	exist_regular_file(classfile') &
	print "parsing " & print classfile' & print "\n" &
	Parser.parse(classfile') => p
	---------------------------
	load_class_from_mp(class,mp) => p

  rule	System.path_delimiter => pd &
	Util.string_append_list([mp,pd,class]) => dirfile &
	Util.string_append_list([dirfile, pd, "package.mo"]) => packfile &
	exist_directory_file dirfile &
	exist_regular_file packfile &
	Print.print_buf "Class is package stored in a directory, loading whole package(incl. subdir)\n" &
	load_complete_package_from_mp(class,mp,Absyn.TOP,
				      Absyn.PROGRAM([],Absyn.TOP)) => p 
	--------------------------------------
	load_class_from_mp(class,mp) => p
	
  rule	print "load_class_from_mp failed\n" 
	--------------------
	load_class_from_mp(_,_) => fail
end

relation load_complete_package_from_mps: (Absyn.Ident, string list, Absyn.Within, Absyn.Program) => Absyn.Program =

  rule	load_complete_package_from_mp(pack,mp,within ,oldp) => p
	-------------------------
	load_complete_package_from_mps(pack,mp::_,within,oldp) => p

  rule	load_complete_package_from_mps(pack,mps,within ,oldp) => p
	-------------------------
	load_complete_package_from_mps(pack,_::mps,within,oldp) => p

end

relation load_complete_package_from_mp: (Absyn.Ident, string, Absyn.Within, Absyn.Program) => Absyn.Program =
	
  rule System.path_delimiter => pd &	
	Util.string_append_list([mp,pd,pack]) => mp' &
	Util.string_append_list([mp', pd, "package.mo"]) => packagefile &
	exist_regular_file(packagefile) &
	print "parsing " & print packagefile & print "\n" &
	Parser.parse(packagefile) => Absyn.PROGRAM(p1,w1) &
	Print.print_buf("loading ") & Print.print_buf(packagefile) & Print.print_buf "\n" &
	Interactive.update_program(Absyn.PROGRAM(p1,w1),Absyn.PROGRAM(oldc,Absyn.TOP)) => p1' &
	System.sub_directories(mp') => subdirs &
	Util.string_delimit_list(subdirs, ", ") => subdirstr &
	print "subdirs =" & print subdirstr & print "\n" &
	load_complete_subdirs(subdirs,pack,mp',within,p1') => p2 &
	load_complete_subfiles(pack,mp',within,p2) => p 
	------------------------------
	load_complete_package_from_mp(pack,mp,within as Absyn.TOP,Absyn.PROGRAM(oldc,_)) => p

  rule	System.path_delimiter => pd &
	Util.string_append_list([mp,pd,pack]) => mp' &
	Util.string_append_list([mp',pd, "package.mo"]) => packagefile &
	exist_regular_file(packagefile) &
	print "parsing " & print packagefile & print "\n" &
	Parser.parse(packagefile) => Absyn.PROGRAM(p1,w1) &
	Print.print_buf("loading ") & Print.print_buf(packagefile) & Print.print_buf "\n" &
	Interactive.update_program(Absyn.PROGRAM(p1,Absyn.WITHIN(wpath)),Absyn.PROGRAM(oldc,Absyn.TOP)) => p1' &
	System.sub_directories(mp') => subdirs &
	Util.string_delimit_list(subdirs, ", ") => subdirstr &
	print "subdirs =" & print subdirstr & print "\n" &
	load_complete_subdirs(subdirs,pack,mp',within,p1') => p2 &
	Absyn.join_paths(wpath,Absyn.IDENT(pack))=> wpath' &
	load_complete_subfiles(pack,mp',within,p2) => p
	------------------------------
	load_complete_package_from_mp(pack,mp,within as Absyn.WITHIN(wpath),Absyn.PROGRAM(oldc,_)) => p

  axiom	load_complete_package_from_mp(_,_,_,_) => fail
end

relation load_complete_subdirs: (string list, Absyn.Ident, string, 
				 Absyn.Within, Absyn.Program) 
	  => Absyn.Program =
	  
  axiom	load_complete_subdirs([],_,_,w,Absyn.PROGRAM(oldcls,w2)) => Absyn.PROGRAM(oldcls,w2)
	
  rule	Absyn.join_paths(pack2,Absyn.IDENT(pack1)) => pack' &
	load_complete_package_from_mp(pack,mp,Absyn.WITHIN(pack'),oldp) => p &
	load_complete_subdirs(packs,pack1,mp,within,p) => p' 
	---------------------------------------------
 	load_complete_subdirs(pack::packs,pack1,mp,within as Absyn.WITHIN(pack2),oldp) => p'
 
  rule	Absyn.join_paths(Absyn.IDENT(pack1),Absyn.IDENT(pack)) => pack' &
	load_complete_package_from_mp(pack,mp,Absyn.WITHIN(Absyn.IDENT(pack1)),oldp) => p &
	load_complete_subdirs(packs,pack1,mp,within,p) => p' 
	---------------------------------------------
 	load_complete_subdirs(pack::packs,pack1,mp,within as Absyn.TOP,oldp) => p'

  rule	load_complete_subdirs(packs,pack1,mp,within,p) => p' 
	---------------------------------------------
 	load_complete_subdirs(pack::packs,pack1,mp,within,p) => p'


  rule	print "load_complete_subdirs failed\n"
	----------------
	load_complete_subdirs(_,_,_,_,_) => fail
end

relation load_complete_subfiles: (Absyn.Ident, string, Absyn.Within, Absyn.Program) 
	  => Absyn.Program =

  rule	(* Here *.mo files in same directory as package.mo should be loaded as sub-packages*)
	System.mo_files(mp)=> mofiles &
	Absyn.join_paths(within,Absyn.IDENT(pack)) => within' &
	load_subpackage_files(mofiles,mp,Absyn.WITHIN(within'),oldp) => p 
	------------------------------------------
	load_complete_subfiles(pack,mp,Absyn.WITHIN(within),oldp) => p

  rule	(* Here *.mo files in same directory as package.mo should be loaded as sub-packages*)
	System.mo_files(mp)=> mofiles &
	load_subpackage_files(mofiles,mp,Absyn.WITHIN(Absyn.IDENT(pack)),oldp) => p
	------------------------------------------
	load_complete_subfiles(pack,mp,Absyn.TOP,oldp) => p

  rule	print "load_complete_subfiles failed\n"
	------------------------------------------
	load_complete_subfiles(_,_,_,_) => fail

end

relation load_subpackage_files: (string list, string, Absyn.Within, Absyn.Program) 
	  => Absyn.Program =

  axiom	load_subpackage_files([],mp,within,Absyn.PROGRAM(cls,w)) => Absyn.PROGRAM(cls,w)

  rule	System.path_delimiter => pd &
	Util.string_append_list([mp,pd,f]) => f' &
	print "parsing " & print f' & print "\n" &
	Parser.parse(f') => Absyn.PROGRAM(cls,_) &
	Print.print_buf("loading ") & Print.print_buf(f') & Print.print_buf "\n" &
	Interactive.update_program(Absyn.PROGRAM(cls,within),Absyn.PROGRAM(oldc,Absyn.TOP))=> p' &
	load_subpackage_files(fs, mp, within, p') => p''
	-------------------------------
	load_subpackage_files(f::fs,mp,within,Absyn.PROGRAM(oldc,_)) => p''

  rule	print "load_subpackage_files failed\n"
	---------------------
	load_subpackage_files(_,_,_,_) => fail
end

