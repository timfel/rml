(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 codegen.rml
 ** module:      Codegen
 ** description: Generate C code from DAE (Flat Modelica) for Modelica 
 ** functions. This code is compiled and linked to the simulation code or when
 ** functions are called from the interactive environment.
 **
 ** Input: DAE
 ** Output: -   (generated code through Print module)
 ** Uses: Print Inst ModUtil Util
 **
 **
 ** RCS: $Id: codegen.rml,v 1.39 2004/12/14 14:43:35 petar Exp $
 **
 **)

(* ------------------------------------------------------------------------- *)

module Codegen :
						      
    with "dae.rml"
    with "print.rml"
							  
							  
    type Ident = string
							  
    type ReturnType          = string
    type FunctionName        = string
    type ArgumentDeclaration = string
    type VariableDeclaration = string
    type InitStatement       = string
    type Statement           = string
    type CleanupStatement    = string
    type ReturnTypeStruct    = string list
							  
    datatype CFunction = CFUNCTION of 
							  ReturnType *
							  FunctionName * 
							  ReturnTypeStruct *
							  (ArgumentDeclaration list) *
							  (VariableDeclaration list) *
							  (InitStatement       list) *
							  (Statement           list) *
							  (CleanupStatement    list)
		     | CEXTFUNCTION of
							  ReturnType *
							  FunctionName *
							  ReturnTypeStruct *
							  ArgumentDeclaration list							  
  relation generate_functions : DAE.DAElist => ()

	  
end


with "dump.rml"
with "debug.rml"

with "absyn.rml"
with "algorithm.rml"
with "classinf.rml"
with "exp.rml"
with "modutil.rml"
with "types.rml"
with "util.rml"
with "inst.rml"

(* ------------------------------------------------------------------------- *)


val c_empty_function = CFUNCTION("","",[],[],[],[],[],[])

relation c_make_function : (ReturnType,
			    FunctionName,
			    ReturnTypeStruct,
			    ArgumentDeclaration list)
	  => CFunction =

  axiom	c_make_function (rt,fn,rts,ads) => CFUNCTION(rt,fn,rts,ads,[],[],[],[])

end

relation c_make_function_decl: (ReturnType, FunctionName, ReturnTypeStruct, ArgumentDeclaration list) => CFunction =

  axiom	c_make_function_decl(rt,fn,rts,ads) => CEXTFUNCTION(rt,fn,rts,ads)

end

relation c_add_variables : (CFunction, VariableDeclaration list) => CFunction =

  rule	list_append(vd,nvd) => vd'
	--------------------------
	c_add_variables (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nvd)
			 => CFUNCTION(rt,fn,rts,ads,vd',is,st,cl)

end


relation c_add_inits : (CFunction, InitStatement list) => CFunction =

  rule	list_append(is,nis) => is'
	--------------------------
	c_add_inits (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nis)
			 => CFUNCTION(rt,fn,rts,ads,vd,is',st,cl)

end

relation c_add_statements : (CFunction, Statement list) => CFunction =

  rule	list_append(st,nst) => st'
	--------------------------
	c_add_statements (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nst)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st',cl)

end

relation c_add_cleanups : (CFunction, CleanupStatement list) => CFunction =

  rule	list_append(cl,ncl) => cl'
	--------------------------
	c_add_cleanups (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),ncl)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st,cl')

end

relation c_merge_fns : CFunction list => CFunction =
	
  axiom	c_merge_fns [] => c_empty_function

  rule	c_merge_fns r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	c_merge_fns cfn1::r => cfn

end

relation c_merge_fn : (CFunction, CFunction) => CFunction =

  rule	list_append(vd1,vd2) => vd &
	list_append(is1,is2) => is &
	list_append(st1,st2) => st &
	list_append(cl1,cl2) => cl 	
	-----------------------------
	c_merge_fn (CFUNCTION(rt,fn,rts,ad,vd1,is1,st1,cl1),
		    CFUNCTION(_ , _, _ , _,vd2,is2,st2,cl2)) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)
			 
end

relation c_move_statements_to_inits : CFunction => CFunction =

  rule	list_append(is,st) => is'
	---------------------------
	c_move_statements_to_inits CFUNCTION(rt,fn,rts,ad,vd,is,st,cl) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is',[],cl)
end

relation c_print_functions : CFunction list => () =

  axiom	c_print_functions []

  rule	c_print_function(f) &
	c_print_functions(r)
	---------------------
	c_print_functions f::r
end

relation c_print_function : CFunction => () =

  rule	Util.string_delimit_list(ad,", ") => args_str &
	Util.string_append_list [rt," ",fn,"(",args_str,") {"] => stmt_str &
	
	let i0 = 0 &
	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" &
	c_print_indented (stmt_str,i1) => i2 & Print.print_buf "\n" &
	c_print_indented_list (vd,i2)  => i3 & Print.print_buf "\n" &
	c_print_indented_list (is,i3)  => i4 & Print.print_buf "\n" &
	c_print_indented_list (st,i4)  => i5 & Print.print_buf "\n" &
	c_print_indented_list (cl,i5)  => i6 & Print.print_buf "\n" &
	c_print_indented      ("}",i6) => i7 & Print.print_buf "\n"
	-----------
	c_print_function CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)

  rule	Util.string_delimit_list(ads,", ") => args_str &
	Util.string_append_list [rt," ",fn,"(",args_str,");\n"] => stmt_str &
	let i0 = 0 &
	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" &
	Print.print_buf "extern " & Print.print_buf stmt_str
	---------------------------------------------------
	c_print_function CEXTFUNCTION(rt,fn,rts,ads)

  rule	Print.print_buf "# c_print_function_failed\n"
	-----------
	c_print_function _
end

relation c_print_indented_list : (string list, int) => int =
	
  axiom c_print_indented_list ([],i) => i

  rule	c_print_indented(f,i) => i' & Print.print_buf "\n" &
	c_print_indented_list(r,i') => i''
	-----------------
	c_print_indented_list(f::r,i) => i''

end

relation c_print_indented : (string, int) => int =

  rule	string_list str => strl &
	c_next_level(strl,i) => i' &
	c_this_level(strl,i) => it &
	c_print_indent it &
	Print.print_buf str 
	-----------
	c_print_indented (str,i) => i'
end

relation c_next_level : (char list, int) => int =

  axiom	c_next_level ([],i) => i

  rule	list_string [f] => "{" &
	int_add(i,2) => i' &
	c_next_level(r,i') => i''
	-----
	c_next_level (f::r,i) => i'' (* { *)

  rule	list_string [f] => "}" &
	int_sub(i,2) => i' &
	c_next_level(r,i') => i''
	-----
	c_next_level (f::r,i) => i'' (* } *)

  rule	c_next_level(r,i) => i'
	-----
	c_next_level (_::r,i) => i'

end

relation c_this_level : (char list, int) => int =


  rule	list_string [f] => "#"
	----
	c_this_level(f::_,_) => 0

rule	list_string [f] => "}" &
	int_sub(i,2) => i'
	----
	c_this_level(f::_,i) => i'

  axiom	c_this_level(_,i) => i

end

relation c_print_indent : int => () =

  axiom c_print_indent 0

  rule	Print.print_buf " " &
	int_sub(i,1) => i' &
	c_print_indent i'
	----------------
	c_print_indent i

end

(* ------------------------------------------------------------------------- *)
(*
 generate_functions
 generate_functions_elist
 generate_functions_elist2
 generate_params_type
 generate_function
 generate_result_struct
 generate_return_defs
 generate_return_decls
 generate_return_decl
 is_array
 is_first_in_array
 subs_is_one
 dae_exp_type
 dae_type_str
 dae_short_type_str
 exp_short_type_str
 exp_type_str
 generate_type
 generate_return_type
 generate_array_type
 generate_array_return_type
 print_int
 print_star
 generate_tuple_type
 generate_simple_type
 array_type_string
 generate_function_name
 generate_function_arg
 generate_function_body_tuple
 generate_alloc_outvars
 generate_alloc_outvar
 prefix_cr
 generate_algorithms
 generate_algorithms2
 generate_algorithm
 generate_algorithm_statements
 generate_algorithm_statement
 generate_range_expressions
 generate_else
 generate_vars
 generate_var
 is_var_q
 generate_var_q
 generate_var_q2
 generate_result_vars
 generate_result_var
 generate_equations
 generate_exp
 get_array_dim
 generate_expressions
 generate_expression
 generate_binary
 generate_temp_decl
 generate_scalar_lhs_cref
 generate_rhs_cref
 subs_to_scalar
 generate_scalar_rhs_cref
 generate_array_rhs_cref
 generate_index_spec
 generate_indices_array
 generate_indices
 generate_index_array
 generate_index
 indent_strings
 ident_cstr
 comp_ref_cstr
 generate_lbinary
 generate_lunary
 generate_relation
 generate_matrix
 generate_read_call_write
 invar_names
 generate_read
 generate_write
 is_rcw_output
 is_rcw_input

*)
(* ------------------------------------------------------------------------- *)

relation generate_functions : DAE.DAElist => () =

  rule	Debug.fprintln ("cgtr", "generate_functions") &
	generate_functions_elist elist => cfns &
	Print.print_buf "#include \"modelica.h\"\n" &
	c_print_functions cfns &
	Print.print_buf "\n"
	------------------------------
	generate_functions DAE.DAE(elist)

  rule	Print.print_buf "# generate_functions failed\n"
	--------------------------------------
	generate_functions _ 

end



relation generate_functions_elist : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") &
	Debug.fprintln ("cgtrdumpdae", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae", DAE.dump2, DAE.DAE(els)) &
	DAE.get_matching(els,DAE.is_function) => fns &
	generate_functions_elist2 fns => cfns
	----------------------------
	generate_functions_elist els => cfns
	
end

relation generate_functions_elist2 : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist2") 
	----------------------------------------------------
	generate_functions_elist2 [] => []

  rule	Debug.fprintln ("cgtr", "generate_functions_elist2") &
	generate_function f => cfns1 &
	generate_functions_elist2 rest => cfns2 &
	list_append(cfns1,cfns2) => cfns
	----------------------------
	generate_functions_elist2 f :: rest => cfns
	
end

relation generate_params_type : Ident => string =

  rule	string_append (n, "_params") => s
	---------------------------------
	generate_params_type n => s

end


relation generate_function : DAE.Element => CFunction list =

  rule	generate_function_name fpath => fn_name_str &
	Debug.fprintl ("cgtr", ["generating function ", fn_name_str, "\n"]) &

	Debug.fprintln ("cgtrdumpdae3", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae3", DAE.dump2, DAE.DAE(dae)) &


	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath           => retstr &
	Util.list_map(args, generate_function_arg)  => arg_strs &

	c_make_function(retstr, fn_name_str, struct_strs,arg_strs)=> head_cfn &

	generate_function_body_tuple(fpath, dae, restype) => body_cfn &

	c_merge_fn(head_cfn,body_cfn) => cfn &
	
	generate_read_call_write(fn_name_str,outvars,retstr,invars) => rcw_fn
	---------------------------
	generate_function DAE.FUNCTION(fpath, 
				       DAE.DAE(dae), 
				       (Types.T_FUNCTION(args,restype),_)) 
	  => [cfn,rcw_fn]

  rule	generate_function_name fpath => fn_name_str &
	Debug.fprintl ("cgtr", ["generating external function ", fn_name_str, "\n"]) &


	let  DAE.EXTERNALDECL(extfnname,extargs,extretarg,lang) = extdecl &

	Debug.fprintln ("cgtrdumpdae1", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae1", DAE.dump2, DAE.DAE(orgdae)) &
	Inst.init_vars_modelica_output orgdae => dae &
	Debug.fprintln ("cgtrdumpdae2", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae2", DAE.dump2, DAE.DAE(dae)) &

	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	DAE.get_bidir_vars dae => bivars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath => retstructtype &
	generate_ext_return_type (extretarg) => retstr &
	generate_ext_function_name (extfnname, lang) => extfnname' &
	generate_ext_function_args (extargs, lang) => arg_strs &
        c_make_function_decl(retstr,extfnname',struct_strs,arg_strs) => func_decl &
	generate_read_call_write_external(fn_name_str,outvars,retstructtype,invars,extdecl,bivars) => rcw_fn
	---------------------------------------------------------------------------------------------
	generate_function DAE.EXTFUNCTION(fpath, 
				       DAE.DAE(orgdae), 
				       (Types.T_FUNCTION(args,restype),_),
					  extdecl) 
	  => [func_decl,rcw_fn]

  rule	generate_functions_elist daelist => cfns
	----------------------
	generate_function DAE.COMP(n, DAE.DAE(daelist)) => cfns


  rule	Print.print_buf "# generate_function failed\n" &
	DAE.dump2 DAE.DAE([comp]) 
	------------------------------------
	generate_function comp => fail
	
end

relation generate_ext_function_name : (string, string) => string =

  axiom	generate_ext_function_name (name, "C") => name

  rule	string_append (name, "_") => name'
	----------------------------------
	generate_ext_function_name (name, "FORTRAN 77") => name'

  rule	Print.print_buf "#-- generate_ext_function_name failed\n" &
	Print.print_buf "#-- Unknown language in external declaration\n"
	---------------------------------------------------------
	generate_ext_function_name (_,_) => fail

end	

relation generate_result_struct : (DAE.Element list, Absyn.Path) 
	  => string list =

  rule	generate_return_type fpath => ptname &
	generate_return_decls outvars => (var_strs,var_names) &
	generate_return_defs (ptname,var_names,1) => defs &
	indent_strings var_strs => var_strs' &
	Util.string_append_list(["typedef struct ",ptname,"_s"]) => first_row &
	Util.string_append_list(["} ",ptname,";"]) => last_row &
	Util.list_flatten([defs,[first_row,"{"],var_strs',[last_row]]) => strs
	-----------------------------------------
	generate_result_struct (outvars, fpath) => strs

end

relation generate_return_defs : (string, string list, int) => string list =

  axiom generate_return_defs (_,[],_) => []
	
  rule	int_string i => i_str &
	Util.string_append_list(["#define ",tn,"_",i_str," ",f]) => f' &
	int_add(i,1) => i' &
	generate_return_defs (tn,r,i') => r'
	----
	generate_return_defs (tn,f::r,i) => f'::r'

end

relation generate_return_decls : DAE.Element list => (string list, 
						      string list) =

  axiom	generate_return_decls [] => ([],[])

  rule	generate_return_decl first => ("",_) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (rs,rd)

  rule	generate_return_decl first => (fs,fd) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (fs::rs,fd::rd)

end

relation tmpprintinit : Exp.Exp option => string =

  axiom tmpprintinit NONE => ""

  rule	Exp.print_exp_str e => str &
	Util.string_append_list ([" /* ", str, " */"]) => str1
	--------------------------
	tmpprintinit SOME(e) => str1

end

relation generate_return_decl: DAE.Element => (string, string) =

(* changed DAE.VAR(..., NONE, inst_dims) to ..._, inst_dims) because removed second *)
(* rule *)

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([typ_str," ",id_str,";",
				 " /* [",dims_str,"] */"]) 
	  => decl_str' &
	tmpprintinit initopt => expstr &
	string_append(decl_str', expstr) => decl_str
	---------------------------------------------------
	generate_return_decl (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, 
					     typ, initopt, inst_dims,start,flow,class)) => (decl_str,id_str)

(* not needed here, generate_return_decl is used to create the return struct
  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.string_append_list([typ_str," ",id_str,";"]) => decl_str' &
	Print.print_buf "# default/init values not implemented yet: " &
	Exp.print_exp_str e => str & Print.print_buf str &
	Print.print_buf "\n" &
	Util.string_append_list ([decl_str', " /* ", str, " */"]) => decl_str
	-----------
	generate_return_decl (DAE.VAR(id, 
				      DAE.VARIABLE, 
				      DAE.OUTPUT, 
				      typ, 
				      SOME(e),
				      _,_))
	=> (decl_str,id_str)
*)

  axiom	generate_return_decl (_) => ("","")

end

relation is_array : DAE.Element => bool =
	
(*
  axiom	is_array DAE.VAR(cr,vk,vd,ty,_,[],st,fl,cl) => false
  axiom	is_array DAE.VAR(cr,vk,vd,ty,_,_::_,st,fl,cl) => true
*)

  rule	Debug.fcall("isarrdb", DAE.dump2, DAE.DAE[el])
	-----------------------------------
	is_array (el as DAE.VAR(cr,vk,vd,ty,_,[],st,fl,cl)) => false

  rule	Debug.fcall("isarrdb", DAE.dump2, DAE.DAE[el])
	-----------------------------------
	is_array (el as DAE.VAR(cr,vk,vd,ty,_,_::_,st,fl,cl)) => true

  rule	Print.print_buf "#-- is_array failed\n" &
	Print.print_buf "#-- Not a var?" &
	DAE.dump2 DAE.DAE([el])
	--------------------------
	is_array el => fail

end

relation is_array_or_string : DAE.Element => bool =

  rule	is_array var => true &
	Print.print_buf "#-- array of strings is probably not supported yet\n"
	------------------------------------------------------------------
	is_array_or_string (var as DAE.VAR(cr,vk,vd,DAE.STRING,_,_,st,fl,cl)) => fail

  rule	is_array var => true
	-------------------
	is_array_or_string (var as DAE.VAR(cr,vk,vd,ty,_,_,st,fl,cl)) => true

  axiom	is_array_or_string (var as DAE.VAR(cr,vk,vd,DAE.STRING,_,_,st,fl,cl)) => true

  rule	Print.print_buf "#-- is_array_or_string failed\n" &
	DAE.dump2 DAE.DAE([el])
	------------------------------------------------------------------
	is_array_or_string el => fail
	
end

(*
relation is_first_in_array : Exp.ComponentRef => bool =

  axiom	is_first_in_array Exp.CREF_IDENT(_,[]) => true

  rule	subs_is_one subs => b
	---------------------
	is_first_in_array Exp.CREF_IDENT(_,subs) => b

  rule	is_first_in_array cref => b
	---------------------------
	is_first_in_array Exp.CREF_QUAL(_,[],cref) => b

  rule	subs_is_one subs => b1 &
	is_first_in_array cref => b2 &
	bool_and(b1,b2) => b
	------------------------------
	is_first_in_array Exp.CREF_QUAL(_,subs,cref) => b
end

relation subs_is_one : Exp.Subscript list => bool =

  axiom subs_is_one [] => true

  rule	subs_is_one r => b
	------------------
	subs_is_one Exp.INDEX(Exp.ICONST(1))::r => b

  axiom	subs_is_one _::_ => false

end
*)

relation dae_exp_type : DAE.Type => Exp.Type =

  axiom	dae_exp_type DAE.INT    => Exp.INT
  axiom	dae_exp_type DAE.REAL   => Exp.REAL
  axiom	dae_exp_type DAE.STRING => Exp.STRING
  axiom	dae_exp_type DAE.BOOL   => Exp.BOOL
  axiom	dae_exp_type DAE.ENUM   => Exp.ENUM
  axiom	dae_exp_type _		=> Exp.OTHER

end

relation dae_type_str : (DAE.Type, bool) => string =

  rule	dae_exp_type t => t' &
	exp_type_str (t',a) => str
	--------------------------
	dae_type_str (t,a) => str

end

relation dae_short_type_str : DAE.Type => string =

  rule	dae_exp_type t => t' &
	exp_short_type_str t' => str
	--------------------------
	dae_short_type_str t => str

end

relation exp_short_type_str : Exp.Type => string =

  axiom	exp_short_type_str Exp.INT    => "integer"
  axiom	exp_short_type_str Exp.REAL   => "real"
  axiom	exp_short_type_str Exp.STRING => "string"
  axiom	exp_short_type_str Exp.BOOL   => "boolean"
  axiom	exp_short_type_str Exp.OTHER  => "OTHER"
  axiom	exp_short_type_str Exp.ENUM  => "ENUM_NOT_IMPLEMENTED"

end

relation exp_type_str : (Exp.Type, bool) => string =

  rule	exp_short_type_str t => tstr &
	string_append("modelica_",tstr) => str
	-----------
	exp_type_str (t, false) => str

  rule	exp_short_type_str t => tstr &
	string_append(tstr,"_array") => str
	-----------
	exp_type_str (t, true) => str

end

relation generate_type : Types.Type => string =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => ty_str 
	---------------------------
	generate_type((Types.T_TUPLE(tys),_)) => ty_str


  rule	Debug.fprintln ("cgtr", "generate_type") &
	Types.flatten_array_type tys => (arrayty, dims) &
	generate_array_type (arrayty, dims) => ty_str
	-----------------------------------
	generate_type (tys as (Types.T_ARRAY(_,_),_)) => ty_str


  axiom	generate_type((Types.T_INTEGER(_),_)) => "modelica_integer"
  axiom generate_type((Types.T_REAL(_),_)) => "modelica_real"
  axiom	generate_type((Types.T_STRING(_),_)) => "modelica_string"
  axiom	generate_type((Types.T_BOOL(_),_)) => "modelica_boolean"


  rule	Print.print_buf "#-- generate_type failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type ty => fail

end


relation generate_type_external : Types.Type => string =

  axiom	generate_type_external((Types.T_INTEGER(_),_))  => "int"
  axiom generate_type_external((Types.T_REAL(_),_)) => "double"
  axiom	generate_type_external((Types.T_STRING(_),_)) => "const char*"
  axiom	generate_type_external((Types.T_BOOL(_),_)) => "int"

  rule	generate_type_external ty => str
	--------------------------------
	generate_type_external((Types.T_ARRAY(dim,ty),_)) => str

  rule	Print.print_buf "#-- generate_type_external failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type_external ty => fail

end

relation generate_type_internal : Types.Type => string =

	(* for the basic types, only those must match *)
  rule	Types.basic_type ty => true &
	generate_type_internal_namepart ty => tystr &
	string_append("modelica_",tystr) => str
	---------------------------------------
	generate_type_internal ty => str

  rule	Types.is_array ty => true &
	Types.array_element_type ty => elty &
	generate_type_internal elty => tystr &
	string_append (tystr,"_array") => str
	--------------------------------
	generate_type_internal ty => str

  rule	Print.print_buf "#-- generate_type_internal failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type_internal ty => fail

end

(* for the basic types, only those must match *)
relation generate_type_internal_namepart : Types.Type => string =

  axiom	generate_type_internal_namepart((Types.T_INTEGER(_),_)) => "integer"
  axiom generate_type_internal_namepart((Types.T_REAL(_),_))	=> "real"
  axiom	generate_type_internal_namepart((Types.T_STRING(_),_))	=> "string"
  axiom	generate_type_internal_namepart((Types.T_BOOL(_),_))	=> "boolean"
  axiom	generate_type_internal_namepart((Types.T_ENUM,_))	=> "T_ENUM_NOT_IMPLEMENTED"

end


relation generate_return_type : Absyn.Path => string =

  rule	generate_function_name fpath => fstr &
	string_append (fstr, "_rettype" ) => res
	--------------------------
	generate_return_type fpath => res
end


relation generate_array_type : (Types.Type, int list) => string =

  rule	array_type_string ty => str 
	--------------------------
	generate_array_type (ty, dims) => str
end

relation generate_array_return_type : (Types.Type, int list) => string =

  rule	array_type_string ty => ty_str
	-------------------------------
	generate_array_return_type (ty, dims) => ty_str
end


relation print_int : int => () =

  rule	int_string i => str &
	Print.print_buf str
	---------
	print_int i
end

relation print_star : int => () =

  rule	Print.print_buf "*"
	---------
	print_star i

end



relation generate_tuple_type : Types.Type list => string =


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_1") &
	generate_simple_type ty => str
	--------------------------------
	generate_tuple_type [ty] => str


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_2") &
	generate_simple_type ty => str &
	generate_tuple_type tys => str' &
	string_append (str, str') => str'' &
	string_append ("struct ", str'') => str'''
	----------------------------------
	generate_tuple_type (ty::tys) => str'''

end



relation generate_simple_type : Types.Type => string =

  axiom	generate_simple_type((Types.T_INTEGER(_),_))=> "modelica_integer"
  axiom	generate_simple_type((Types.T_REAL(_),_)) => "modelica_real"
  axiom	generate_simple_type((Types.T_STRING(_),_)) => "modelica_string"
  axiom	generate_simple_type((Types.T_BOOL(_),_)) => "modelica_boolean"

  rule	string_append ("const ", n) => n' &
	string_append (n', "&") => n''
	------------------------------
	generate_simple_type((Types.T_COMPLEX (ClassInf.RECORD(n),_),_)) => n''

  rule	Types.array_element_type t => t' &
	array_type_string t' => t_str
	-----------------------
	generate_simple_type (t as (Types.T_ARRAY(_,_),_)) => t_str

  rule	Print.print_buf "#--generate_simple_type failed " &
	Types.print_type ty & 
	Print.print_buf "\n"
	--------------------------------------
	generate_simple_type ty => fail
end

relation array_type_string : Types.Type => string =

  axiom	array_type_string((Types.T_INTEGER(_),_)) => "integer_array"
  axiom	array_type_string((Types.T_REAL(_),_)) => "real_array"
  axiom	array_type_string((Types.T_STRING(_),_)) => "string_array"
  axiom	array_type_string((Types.T_BOOL(_),_)) => "boolean_array"

end

relation generate_function_name : Absyn.Path => string =

  rule	ModUtil.path_string2 (fpath,"_") => fstr 
	----------------------------------
	generate_function_name fpath => fstr

end

(* input string is language, e.g. "C" or "FORTRAN 77" *)
relation generate_ext_function_args : (DAE.ExtArg list, string) => string list = 

  rule	Util.list_map(extargs,generate_ext_function_arg) => arg_strs
	------------------------------------------------------------
	generate_ext_function_args (extargs, "C") => arg_strs

  rule	Util.list_map(extargs,generate_ext_function_arg_f77) => arg_strs
	------------------------------------------------------------
	generate_ext_function_args (extargs, "FORTRAN 77") => arg_strs

  rule	Print.print_buf "#-- Unknown external language declaration\n" &
	Print.print_buf lang
	--------------------
	generate_ext_function_args (_,lang) => fail

end	


relation generate_function_arg : Types.FuncArg => string =

  rule	generate_tuple_type [ty] => str &
	string_append (str, " ") => str' &
	string_append (str', name) => str''
	-----------------------------------
	generate_function_arg ((name, ty)) => str''

end

(* FIXME : shouldn't it be "const <type> *" instead of
   <type> const *"
   changed this already.
*)

relation generate_ext_arg_type : (Types.Attributes, Types.Type) => string =

  rule	Types.is_array ty => false & 
	generate_type_external ty => str
	--------------------------------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.INPUT), ty) => str

  rule	Types.is_array ty => true & 
	generate_type_external ty => str &
	Util.string_append_list(["const ",str," *"]) => resstr
	----------------------------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.INPUT), ty) => resstr

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => str

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	generate_type_external ty => str
	--------------------------------------------------------
	generate_ext_arg_type (_, ty) => str

  rule	Print.print_buf "#-- generate_ext_arg_type failed\n"
	----------------------------------------------------
	generate_ext_arg_type (_,_) => fail

end	

relation generate_ext_function_arg : DAE.ExtArg => string =

(* LS: Why different names, it's only the declaration anyway *)
(* commenting out *)

(*
  rule	Types.is_array ty => false &
	generate_ext_arg_type (attr,ty) => tystr &
	var_name_external cref => name &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARG(cref, attr, ty) => res
*)

  rule	(* Types.is_array ty => true & *)
	generate_ext_arg_type (attr,ty) => tystr &
	comp_ref_cstr cref => (name,_) &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARG(cref, attr, ty) => res

  rule	generate_type_external ty => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARGEXP(exp, ty) => res

  axiom	generate_ext_function_arg DAE.EXTARGSIZE(_,_,_,_) => "size_t"

  rule	Print.print_buf "#-- generate_ext_function_arg failed\n"
	----------------------------------------------------
	generate_ext_function_arg (_) => fail

end

relation generate_ext_arg_type_f77 : (Types.Attributes, Types.Type) => string =

  rule	generate_type_external ty => str &
	Util.string_append_list(["const ", str, " *"]) => resstr
	----------------------------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.INPUT), ty) => resstr

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => str

  rule	generate_ext_arg_type (attr,ty) => str
	--------------------------------
	generate_ext_arg_type_f77 (attr as Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	generate_ext_arg_type (attr,ty) => str
	--------------------------------
	generate_ext_arg_type_f77 (attr as Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	generate_ext_arg_type (attr,ty) => str
	--------------------------------
	generate_ext_arg_type_f77 (attr, ty) => str

  rule	Print.print_buf "#-- generate_ext_arg_type_f77 failed\n"
	----------------------------------------------------
	generate_ext_arg_type_f77 (_,_) => fail

end	

relation generate_ext_function_arg_f77 : DAE.ExtArg => string =

  rule	generate_ext_arg_type_f77 (attr,ty) => tystr &
	comp_ref_cstr cref => (name,_) &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg_f77 DAE.EXTARG(cref, attr, ty) => res

  rule	generate_ext_function_arg arg => res
	------------------------------------
	generate_ext_function_arg_f77 (arg as DAE.EXTARGEXP (_,_)) => res

  axiom	generate_ext_function_arg_f77 DAE.EXTARGSIZE(_,_,_,_) => "int const *"

  rule	Print.print_buf "#-- generate_ext_function_arg failed\n"
	----------------------------------------------------
	generate_ext_function_arg_f77 (_) => fail

end

(*
relation generate_ext_arg_dims : (Ident, int list) => string =

  rule	generate_ext_arg_dims_2 (name,dims,1) => str	
	-----------------------------------------
       	generate_ext_arg_dims (name,dims) => str

end

relation generate_ext_arg_dims_2 : (Ident, int list, int) => string =

  rule	int_string i => dimno &
	Util.string_append_list (["size_t ", name, "_dim", dimno]) => str
	------------------------------------------
	generate_ext_arg_dims_2 (name, [v], i) => str

  rule	int_add(i,1) => ipp &
	generate_ext_arg_dims_2 (name, rest, ipp) => reststr &
	int_string i => dimno &
	Util.string_append_list(["size_t", name, "_dim", dimno, ", ", reststr]) => str
	--------------------------------------------------------------------
	generate_ext_arg_dims_2 (name, v::rest, i) => str

end
*)

relation generate_ext_return_type : DAE.ExtArg => string =

  rule	generate_type_external ty => res
	--------------------------------------------------
	generate_ext_return_type DAE.EXTARG(cref, attr, ty) => res

  axiom generate_ext_return_type DAE.NOEXTARG => "void"

  rule	Print.print_buf "#-- generate_ext_return_type failed\n" 
	--------------------------------------------------------
	generate_ext_return_type _ => fail
end

relation generate_ext_return_type_f77 : DAE.ExtArg => string =

  rule	generate_ext_return_type arg => str
	-----------------------------------
	generate_ext_return_type_f77 arg => str

end	


relation generate_function_body_tuple : (Absyn.Path, 
					 DAE.Element list, 
					 Types.Type) 
	  => CFunction =
	  
  rule	Debug.fprintln ("cgtr", "generate_function_body_tuple") &
	
	let tnr = 1 &

	generate_return_type fpath => ret_type_str &
	generate_temp_decl(ret_type_str,tnr) => (ret_decl, ret_var, tnr_ret') &
	Util.string_append_list(["return ",ret_var,";"]) => ret_stmt &

	DAE.get_output_vars dae => outvars &
	generate_alloc_outvars(outvars,ret_decl,ret_var,tnr_ret')
	  => (out_fn,tnr_ret) &

	generate_temp_decl("state",tnr_ret) 
	      => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var," = get_memory_state();"]) 
	  => mem_stmt1 &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => mem_stmt2 &

	c_add_variables (out_fn, [mem_decl])  => mem_fn' &
	c_add_inits     (mem_fn',[mem_stmt1]) => mem_fn &

	generate_vars        (dae, is_var_q, tnr_mem)=> (var_fn,tnr_var) &
	generate_algorithms  (dae, tnr_var)          => (alg_fn,tnr_alg) &
	generate_result_vars (dae, ret_var, tnr_alg) => (res_var_fn,tnr_res) &
	
	c_merge_fn(mem_fn, var_fn)     => cfn' &
	c_merge_fn(cfn'  , alg_fn)     => cfn'' &
	c_merge_fn(cfn'' , res_var_fn) => cfn''' &

	c_add_cleanups(cfn''',[mem_stmt2,ret_stmt]) => cfn
	--------------
	generate_function_body_tuple (fpath, dae, restype) => cfn

end

relation generate_alloc_outvars : (DAE.Element list, string, string, int) 
	  => (CFunction,int) =

  axiom	generate_alloc_outvars([],"",rv,tnr) => (c_empty_function,tnr)

  rule	c_add_variables(c_empty_function,[rd]) => cfn
	---------------------------------------------
	generate_alloc_outvars([],rd,rv,tnr) => (cfn,tnr)

  rule	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars(r,rd,rv,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars ((var as DAE.VAR(cr,vk,vd,t,e,id,start,flow,class))::r,
				rd,rv,tnr)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars(r,rd,rv,tnr) => (cfn2,tnr2)
	--------------------------------------------------
	generate_alloc_outvars (_::r,rd,rv,tnr) => (cfn2,tnr2)

end

relation is_empty_string : string => bool =

  axiom is_empty_string "" => true
  axiom is_empty_string _ => false
end
	
relation generate_alloc_outvar : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	Util.string_append_list([prefix,".",cref_str1]) => cref_str2 &
	is_empty_string prefix => emptypre &
	Util.if (emptypre, cref_str1, cref_str2) => cref_str &
	generate_size_subscripts(cref_str,inst_dims,tnr) => (cfn1,dim_strs,tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	c_add_inits(cfn1',[alloc_str]) => cfn' &
	Util.if (is_a,cfn',cfn1') => cfn
	--------------------------------
	generate_alloc_outvar(var as DAE.VAR(id, vk, vd, typ, e, 
					     inst_dims,start,flow,class),
			      prefix,
			      tnr) 
	  => (cfn,tnr1)

  rule	not DAE.is_var e
	----------------
	generate_alloc_outvar (e,_,tnr) => (c_empty_function,tnr)

end

relation generate_alloc_outvars_ext : (DAE.Element list, string,int, DAE.ExternalDecl) 
	  => (CFunction,int) =

	  
  axiom	generate_alloc_outvars_ext([],rv,tnr,extdecl) => (c_empty_function,tnr)


  rule	let DAE.EXTERNALDECL(_,_,_,"C") = extdecl &
	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars_ext(r,rv,tnr1,extdecl) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars_ext ((var as DAE.VAR(cr,vk,vd,t,e,
						    id,start,flow,class))::r,
				rv,tnr,extdecl)
	  => (cfn,tnr2)

  rule	let DAE.EXTERNALDECL(_,_,_,"FORTRAN 77") = extdecl &
	generate_alloc_outvar_f77(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars_ext(r,rv,tnr1,extdecl) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars_ext ((var as DAE.VAR(cr,vk,vd,t,e,
						    id,start,flow,class))::r,
				rv,tnr,extdecl)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars_ext(r,rv,tnr,extdecl) => (cfn2,tnr2)
	------------------------------------------------------
	generate_alloc_outvars_ext (_::r,rv,tnr,extdecl) => (cfn2,tnr2)

end


relation generate_alloc_outvar_f77 : (DAE.Element,string,int) => (CFunction,int) =


  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	Util.string_equal (prefix, "") => emptypre &
	comp_ref_cstr id => (cref_str1,_) &
	Util.string_append_list ([prefix,".",cref_str1]) => cref_str2 &
	Util.if (emptypre, cref_str1, cref_str2) => cref_str &
(*	list_reverse inst_dims => inst_dims' & *)
	generate_size_subscripts(cref_str, inst_dims,tnr) => (cfn1,dim_strs,tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &

	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	c_add_inits(cfn1',[alloc_str]) => cfn' &
	Util.if (is_a,cfn',cfn1') => cfn
	--------------------------------
	generate_alloc_outvar_f77(var as DAE.VAR(id, vk, vd, typ, e, 
						 inst_dims,start,flow,class),
				  prefix,
				  tnr) 
	  => (cfn,tnr1)

  rule	not DAE.is_var e
	-------------
	generate_alloc_outvar_f77 (e,_,tnr) => (c_empty_function,tnr)

end

relation generate_size_subscripts : (string, Exp.Subscript list,int)
	  => (CFunction,string list,int) =

  axiom	generate_size_subscripts (_,[],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (e,tnr) => (cfn1,var1,tnr1) &
	generate_size_subscripts (id, r, tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_size_subscripts (id, Exp.INDEX(e)::r, tnr)
	  => (cfn, var1::vars2, tnr2)

(*
  rule	generate_temp_decl("WHOLEDIM",tnr) => (decl,var1,tnr1) &
	c_add_variables (c_empty_function, [decl]) => cfn1 &
	generate_size_subscripts (r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_size_subscripts (Exp.WHOLEDIM::r,tnr)
	  => (cfn,var1::vars2,tnr2)
*)

  rule	Print.print_buf "# generate_size_subscripts failed\n" & 
	Util.string_append_list ([" - ", id, "["]) => s &
	Print.print_buf s &
	Dump.print_list(subs,Exp.print_subscript,", ") & Print.print_buf "]\n"
	----------------------------------------------------------------------
	generate_size_subscripts(id,subs,_) => fail

end

relation generate_alloc_array_f77 : (string , Types.Type) => CFunction =

  rule	Types.is_array ty => true &
	Types.flatten_array_type ty => (elty, dims) &
	Exp.int_subscripts dims => dimsubs &
	tick => tnr &
	generate_size_subscripts(crefstr, dimsubs, tnr) => (cfn1, dim_strs, tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &
	generate_type ty => typ_str &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,
			"(&",crefstr,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	  
	  c_add_inits(cfn1',[alloc_str]) => cfn
	---------------------------------------
	generate_alloc_array_f77 (crefstr, ty) => cfn


  rule	Print.print_buf "#-- generate_alloc_array_f77 failed\n"
	-------------------------------------------------------
	generate_alloc_array_f77 (_,_) => fail

end

relation prefix_cr : (string, Exp.ComponentRef) => Exp.ComponentRef =

  axiom	prefix_cr (prf,cref) 
	  => Exp.CREF_QUAL(prf,[],cref)
	  
end

relation generate_algorithms: (DAE.Element list, int)
	  => (CFunction, int) =

  rule	DAE.get_matching(els,DAE.is_algorithm) => algs &
	generate_algorithms2(algs,tnr) => (cfn,tnr') 
	------------------------
	generate_algorithms (els, tnr) => (cfn,tnr')

end

relation generate_algorithms2: (DAE.Element list, int)
	  => (CFunction, int) =

  axiom	generate_algorithms2 ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm (first,tnr) => (cfn1,tnr1) &
	generate_algorithms2 (rest,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------
	generate_algorithms2 (first::rest, tnr) => (cfn,tnr2)

end



relation generate_algorithm: (DAE.Element, int)
	  => (CFunction, int) =

  rule	generate_algorithm_statements (stmts,tnr) => (cfn,tnr') 
	----------------------------------------
	generate_algorithm (DAE.ALGORITHM(Algorithm.ALGORITHM(stmts)),tnr)
	  => (cfn,tnr')

  rule	Print.print_buf "# generate_algorithm failed\n"
	------------------------------------
  	generate_algorithm (_,_) => fail

end

relation generate_algorithm_statements : (Algorithm.Statement list, int)
	  => (CFunction, int) =

  axiom	generate_algorithm_statements ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm_statement (f,tnr) => (cfn1,tnr1) &
	generate_algorithm_statements(r,tnr1) =>(cfn2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn
	-----------
	generate_algorithm_statements (f::r, tnr) => (cfn,tnr2)
end


(*
 relation : generate_algorithm_statement

 returns:
   CFunction | Code
   string    | expression result: variable name, or 'c' expression
   int       | next temporary number 
 *)

relation generate_algorithm_statement : (Algorithm.Statement, int)
	  => (CFunction, int) =

  rule	Debug.fprintln("cgas","generate_algorithm_statement") &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_scalar_lhs_cref(typ,cref,tnr1)
	  => (cfn2,var2,tnr2) &
	Util.string_append_list([var2," = ",var1,";"]) => stmt &

	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	----------------
	generate_algorithm_statement (Algorithm.ASSIGN(typ,cref,exp),tnr)
	  => (cfn, tnr2)

  rule	comp_ref_cstr cref => (cref_str,[]) &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["copy_",type_str,"_data(&",
			var1,", &",cref_str,");"]) => stmt &
	  c_add_statements(cfn1,[stmt]) => cfn2
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn2,tnr1)

  rule	comp_ref_cstr cref => (cref_str,subs as _::_) &
	
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_index_spec(subs,tnr1) => (cfn2,var2,tnr2) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["indexed_assign_",type_str,"(&",
			var1,", &",cref_str,", &",var2,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn,tnr2)

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	
	Util.string_append_list(["if (",var1,") {"]) => if_begin &
	c_add_statements(cfn1,[if_begin]) => cfn1' &
	generate_algorithm_statements(then,tnr1) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	generate_else (else,tnr2) => (cfn3,tnr3) &
	c_merge_fns([cfn1',cfn2',cfn3]) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.IF(e,then,else),tnr) 
	  => (cfn,tnr3)

  rule	Exp.is_range e => true &
	generate_temp_decl("state",tnr) => (sdecl,svar,tnr') &
	generate_temp_decl("",tnr') => (_,dvar,tnr1) &
	exp_type_str (t,a) => ident_type_str &
	exp_short_type_str t => short_type &
	generate_temp_decl(ident_type_str,tnr1) => (rdecl1,rvar1,tnr2'') &
	generate_temp_decl(ident_type_str,tnr2'') => (rdecl2,rvar2,tnr2''') &
	generate_temp_decl(ident_type_str,tnr2''') => (rdecl3,rvar3,tnr2) &

	generate_range_expressions(e,tnr2) => (cfn3,e1var,e2var,e3var,tnr3) &
	Util.string_append_list([rvar1," = ",e1var,"; ",
				 rvar2," = ",e2var,"; ",
				 rvar3," = ",e3var,";"]) => r_stmt &
	Util.string_append_list(["for (",i," = ",rvar1,"; ",
			    "in_range_",short_type,"(",i,", ",rvar1,", ",rvar3,"); ",
			    i," += ",rvar2,") {"]) => for_begin &

	Util.string_append_list(["{\n  ",ident_type_str," ",i,";\n"]) => def_beg1 &

	Util.string_append_list([svar," = get_memory_state();"]) => mem_begin &

	generate_algorithm_statements(stmts,tnr3) => (cfn4,tnr4) &
	Util.string_append_list(["restore_memory_state(",svar,");"]) 
	  => mem_end &

	let for_end = "}" &
	let def_end1 = "} /* end for*/\n" &

	c_add_variables(cfn3,[sdecl,rdecl1,rdecl2,rdecl3]) => cfn3' &
	c_add_statements(cfn3',[r_stmt,
				def_beg1,
				for_begin,
				mem_begin]) => cfn3'' &
	
	c_add_statements(cfn4,[mem_end,
			       for_end,
			       def_end1]) => cfn4' &

	c_merge_fns([cfn3'',cfn4']) => cfn
	
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(t,a,i,e,stmts),tnr)
	  => (cfn,tnr4)

  rule	generate_temp_decl("state",tnr) => (sdecl,svar,tnr') &
	generate_temp_decl("",tnr') => (_,dvar,tnr'') &
	generate_temp_decl("int",tnr'') => (tdecl,tvar,tnr1) &
	exp_type_str (t,a) => ident_type_str &
	generate_temp_decl(ident_type_str,tnr1) => (idecl,ivar,tnr2) &
	exp_type_str (t,true) => array_type_str &
	generate_expression(e,tnr2) => (cfn3,evar,tnr3) &
	Util.string_append_list(["for (",tvar," = 0; ",
			    tvar," < size_of_dimension_",array_type_str,"(",evar,", 1); ",
			    "++",tvar,") {"]) => for_begin &
	Util.string_append_list(["{\n  ",ident_type_str," ",i,";\n"]) => def_beg1 &
	Util.string_append_list([svar," = get_memory_state();"]) => mem_begin &
	Util.string_append_list(["simple_index_alloc_",ident_type_str,
			    "1(&",evar,", ",tvar,", &",ivar,"));"]) 
	  => stmt_array &
	Util.string_append_list([i," = *(",array_type_str,"_element_addr1(&",
			    evar,", 1, ",tvar,"));"]) => stmt_scalar & (* Use fast implementation for 1 dim *)

	Util.if(a,stmt_array,stmt_scalar) => stmt &
	generate_algorithm_statements(stmts,tnr3) => (cfn4,tnr4) &
	Util.string_append_list(["restore_memory_state(",svar,");"]) 
	  => mem_end &
	let for_end = "}" &
	let def_end1 = "} /* end for*/\n" &
	c_add_variables(cfn3,[sdecl,tdecl,idecl]) => cfn3' &
	c_add_statements(cfn3',[def_beg1,
				for_begin,
				mem_begin,stmt]) => cfn3'' &
	
	c_add_statements(cfn4,[mem_end,
			       for_end,
			       def_end1]) => cfn4' &

	c_merge_fns([cfn3'',cfn4']) => cfn	
	
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(t,a,i,e,stmts),tnr)
	  => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["while (1) {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (!",var2,") break;"]) => crit_stmt &
	c_add_statements(cfn2,[crit_stmt]) => cfn2' &

	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1,cfn2',cfn3']) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.WHILE(e,stmts),tnr) 
	  => (cfn,tnr3)

  rule	Print.print_buf "# when statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.WHEN(_,_),_) => fail

  rule	Print.print_buf "# generate_algorithm_statement failed\n"
	-------------------------
	generate_algorithm_statement (_,_) => fail

end

relation generate_range_expressions : (Exp.Exp, int)
	  => (CFunction, string, string, string, int) =


  rule	generate_expression (e1,tnr) => (cfn1,var1,tnr1) &
	let var2 = "(1)" &
	generate_expression (e3,tnr1) => (cfn3,var3,tnr3) &
	
	c_merge_fn(cfn1,cfn3) => cfn 
	-----------------------
	generate_range_expressions(Exp.RANGE(t,e1,NONE,e3),tnr) 
	  => (cfn,var1,var2,var3,tnr3)

  rule	generate_expression (e1,tnr)  => (cfn1,var1,tnr1) &
	generate_expression (e2,tnr1) => (cfn2,var2,tnr2) &
	generate_expression (e3,tnr2) => (cfn3,var3,tnr3) &
	
	c_merge_fns([cfn1,cfn2,cfn3]) => cfn 
	-----------------------
	generate_range_expressions(Exp.RANGE(t,e1,SOME(e2),e3),tnr) 
	  => (cfn,var1,var2,var3,tnr3)

  rule	Print.print_buf "# generate_range_expressions failed\n"
	-----------------------
	generate_range_expressions(_,_) => fail

end

relation generate_else : (Algorithm.Else, int) => (CFunction, int) =

  axiom	generate_else (Algorithm.NOELSE,tnr) => (c_empty_function,tnr)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (",var2,") {"]) => if_begin &
	c_add_statements(cfn2,[if_begin]) => cfn2' &
	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &
	generate_else(else,tnr3) => (cfn4,tnr4) &
	c_add_statements(cfn4,["}"]) => cfn4' &
	c_merge_fns([cfn1,cfn2',cfn3',cfn4']) => cfn
	-------
	generate_else (Algorithm.ELSEIF(e,stmts,else),tnr) => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_algorithm_statements(stmts,tnr) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	--------
	generate_else (Algorithm.ELSE(stmts),tnr) => (cfn,tnr)

  rule	Print.print_buf "# generate_else failed\n"
	---------------
	generate_else (_,_) => fail
end

relation generate_vars : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_vars ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var (first,tnr)  => (cfn1,tnr1) & 
	generate_vars (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_vars (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_vars failed\n"
	---------------------------------
	generate_vars (_,_,_) => fail
	
end

relation generate_var_decls : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_var_decls ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var_decl (first,tnr)  => (cfn1,tnr1) & 
	generate_var_decls (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_var_decls (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_var_decls (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_var_decls (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_var_decls failed\n"
	---------------------------------
	generate_var_decls (_,_,_) => fail
	
end

relation generate_var_inits : (DAE.Element list, DAE.Element => (), int, string) => (CFunction, int) =

  axiom	generate_var_inits ([],_,tnr,_) => (c_empty_function, tnr)

  rule	verify first &
	generate_var_init (first, tnr, pre) => (cfn1, tnr1) &
	generate_var_inits(rest, verify, tnr1, pre) => (cfn2, tnr2) &
	c_merge_fn(cfn1, cfn2) => cfn
	-----------------------------
	generate_var_inits (first::rest, verify, tnr, pre) => (cfn, tnr2)

  rule	not verify first &
	generate_var_inits (rest,verify,tnr,pre)  => (cfn,tnr2)
	--------------------
	generate_var_inits (first::rest,verify,tnr,pre)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_var_inits failed\n"
	---------------------------------
	generate_var_inits (_,_,_,_) => fail
	
end

(*
relation generate_var_init : (DAE.Element, int) => (CFunction, int) =

  rule	is_array var => is_a &
	dae_type_str (typ, is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Exp.print_exp_str e => expstr & 
	Util.string_append_list (["copy_", typ_str,
				  "_data(", id_str, ",", expstr, ");"
				  ]) => init_str &
	c_add_statements(c_empty_function,[init_str]) => cfn
	-----------
	generate_var_init    (var as DAE.VAR(id, 
					     DAE.VARIABLE, 
					     DAE.OUTPUT, 
					     typ, 
					     SOME(e),
					     _,
					     _,start,flow,class),tnr)
	  => (cfn, tnr)

  axiom	generate_var_init (_, tnr) => (c_empty_function, tnr)

end
*)

relation generate_var : (DAE.Element,int) => (CFunction,int) =
(*
 parameters are put in the params struct

  rule	generate_var_q2 (vd) &
	indent 2 &
	DAE.dump_type typ &
	Exp.print_component_ref id &
	Print.print_buf " = 0;  /* Warning: without value, set to zero */\n"
	-----------
	generate_var(DAE.VAR(id, DAE.PARAM, vd, typ, NONE,_,class))
*)

(*
  rule	is_first_in_array id => false
	-----------------------------
	generate_var(DAE.VAR(id,_,_,_,_,_,_,_,_),tnr) => (c_empty_function,tnr)
*)

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(cref_str,inst_dims,tnr) => (cfn1',vars1,tnr1) &
	c_move_statements_to_inits cfn1' => cfn1 &
	Util.string_delimit_list(vars1,", ") => dimvars_str &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dimvars_str,");"]) => alloc_str &
	c_add_variables(cfn1,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn
	----------------------------------------------------
	generate_var(var as DAE.VAR(id, vk, vd, typ, NONE,inst_dims,start,flow,class),tnr) => (cfn,tnr1)

  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(cref_str,inst_dims,tnr) => (cfn1',vars1,tnr1) &
	c_move_statements_to_inits cfn1' => cfn1 &
	Util.string_delimit_list(vars1,", ") => dimvars_str &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])
	  => decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dimvars_str,");"]) => alloc_str &
	c_add_variables(cfn1,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var(var as DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims,start,flow,class),tnr) 
	  => (cfn,tnr1)

  
  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.string_append_list([typ_str," ",cref_str,";"]) => decl_str &
	generate_expression(e,tnr) => (cfn,var,tnr1) &
	c_add_variables(cfn,[decl_str]) => cfn' &
	Util.string_append_list([cref_str," = ",var,";"]) => init_stmt &
	c_add_inits(cfn',[init_stmt]) => cfn'' &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var(var as DAE.VAR(id, vk, vd, typ, SOME(e),
				    inst_dims,start,flow,class),tnr) 
	  => (cfn'',tnr1)
	
  rule	Print.print_buf "# generate_var failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var (e,_) => fail
end

relation generate_var_decl : (DAE.Element,int) => (CFunction,int) =

(*
  rule	is_first_in_array id => false
	-----------------------------
	generate_var_decl(DAE.VAR(id,_,_,_,_,_,_,_,_),tnr) => (c_empty_function,tnr)
*)


  rule	is_array var => is_a &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	
	c_add_variables(c_empty_function,[decl_str]) => cfn
	----------------------------------------------------
	generate_var_decl(var as DAE.VAR(id, vk, vd, typ, NONE,
					 inst_dims,start,flow,class),tnr) 
	  => (cfn,tnr)

  rule	generate_var_decl(DAE.VAR(id, vk, vd, typ, NONE, inst_dims, start, flow,class), tnr) => (cfn,tnr1)
	--------------------------------------------------------------------------------------------
	generate_var_decl(var as DAE.VAR(id, vk, vd, typ, SOME(e), inst_dims,start,flow,class),tnr) 
	  => (cfn,tnr1)

	
  rule	Print.print_buf "# generate_var_decl failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var_decl (e,_) => fail
end


relation generate_var_init : (DAE.Element,int,string) => (CFunction,int) =

(*
  rule	is_first_in_array id => false
	-----------------------------
	generate_var_init(DAE.VAR(id,_,_,_,_,_,_,_,_),tnr) => (c_empty_function,tnr)
*)


  axiom	generate_var_init(var as DAE.VAR(id, vk, vd, typ, NONE,
					 inst_dims,start,flow,class),tnr,pre)
	  => (c_empty_function, tnr)

  rule	is_array var => is_a &
	Util.string_equal (pre, "") => emptyprep &
	Exp.prepend_string_cref ("out.", id) => id' &
	Util.if (emptyprep, id, id') => idstr &
	dae_exp_type typ => exptype &
	let scalarassign = Algorithm.ASSIGN(exptype, idstr, e) &
	let arrayassign = Algorithm.ASSIGN_ARR(exptype, idstr, e) &
	Util.if (is_a,arrayassign,scalarassign) => assign &
	generate_algorithm_statement (assign,tnr) => (cfn,tnr1)
	-------------------------------------------------------
	generate_var_init(var as DAE.VAR(id, vk, vd, typ, SOME(e),
					 inst_dims,start,flow,class),tnr,pre)
	  => (cfn,tnr1)

	
  rule	Print.print_buf "# generate_var_init failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var_init (e,_,_) => fail
end

relation dim_string : Exp.Subscript => string =

  rule	int_string i => str
	---------------------
	dim_string Exp.INDEX(Exp.ICONST(i)) => str
	
  rule	Exp.print_subscript_str e => str 
	-------------------
	dim_string e => ":"

end
relation is_var_q : DAE.Element => () =

  rule	generate_var_q(vk) &
	generate_var_q2(vd)
	---------------------
	is_var_q DAE.VAR(id,vk,vd,_,_,_,_,_,_)

end
relation generate_var_q : DAE.VarKind => () =

  axiom	generate_var_q DAE.VARIABLE
(*  axiom	generate_var_q DAE.PARAM *)
  axiom	generate_var_q DAE.CONST 

end

relation generate_var_q2 : DAE.VarDirection => () =

  axiom	generate_var_q2 DAE.OUTPUT
  axiom	generate_var_q2 DAE.BIDIR

end


relation generate_result_vars : (DAE.Element list,string, int) 
	  => (CFunction, int) =

  axiom	generate_result_vars ([],_,tnr) => (c_empty_function,tnr)

  rule	generate_result_var (first,varname,tnr) => (cfn1,tnr1) &
	generate_result_vars (rest,varname,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------------------
	generate_result_vars (first :: rest,varname,tnr) => (cfn,tnr2)

end

relation generate_result_var : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array var => false &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list([varname,".",cref_str1," = ",cref_str2,";"])
	  =>stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_,_,_,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array var => true &
	dae_type_str (typ, true) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list(["copy_",typ_str,"_data(&",
			cref_str1,", &",varname,".",cref_str2,");"]) 
	  => stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_,_,_,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array var => true
	-----------
	generate_result_var (var as DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_,_,_,_),
			     varname,
			     tnr)
	  => (c_empty_function,tnr)

  axiom	generate_result_var (_,_,tnr) => (c_empty_function,tnr)

end


(* LS: ATT! These can only be assignments for the moment, 
 since no sorting or solving exists *)

relation generate_equations : DAE.Element list => () =

  axiom	generate_equations []

  rule	Exp.print_exp e1 &
	Print.print_buf " = " &
	Exp.print_exp e2 &
	Print.print_buf ";\n" &
	generate_equations rest
	------------------
	generate_equations DAE.EQUATION(e1,e2) :: rest

  rule	generate_equations rest
	-----------------------
	generate_equations _ :: rest

end

relation generate_exp : Exp.Exp => () =

  rule	Print.print_buf "{" &
	Exp.print_list (es, generate_exp, ", ") &
	Print.print_buf "}"
	---------------------------------------
	generate_exp Exp.ARRAY(_,_,es)

  rule	Exp.print_exp e
	---------------
	generate_exp e

end



relation get_array_dim : Types.Type => int =

  axiom	get_array_dim((Types.T_ARRAY(Types.DIM(SOME(ad)), ty2),_)) => ad

	(** LS: Fail if not array, or if there is no dim value **)

end




relation generate_expressions : (Exp.Exp list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_expressions ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (f,tnr) => (cfn1,var1,tnr1) &
	generate_expressions(r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn 
	----
	generate_expressions (f::r,tnr) => (cfn,var1::vars2,tnr2)

end




(*
 generate_expression

 returns
   CFunction | the generated code
   string    | expression result variable name, or c expression
   int       | next temporary number 
*)
 
relation generate_expression : (Exp.Exp, int) => (CFunction,string,int) =
	  
  rule	int_string i => istr
	-----------------------------------------------------
	generate_expression(Exp.ICONST(i),tnr) => (c_empty_function,istr,tnr)

  rule	real_string r => rstr
	------------------
	generate_expression(Exp.RCONST(r),tnr) => (c_empty_function,rstr,tnr)
	
  rule	Util.string_append_list(["\"",s,"\""]) => sstr
	---------------------------------------------
	generate_expression(Exp.SCONST(s),tnr) => (c_empty_function,sstr,tnr)

  rule	Util.if(b,"(1)","(0)") => var
	-------------------------
	generate_expression(Exp.BCONST(b),tnr) => (c_empty_function,var,tnr)

  rule	generate_rhs_cref(cref, t, tnr) => (cfn,var,tnr')
	-------------------------------------------------
	generate_expression(Exp.CREF(cref,t),tnr) => (cfn,var,tnr')

  rule	generate_binary(e1,op,e2,tnr) => (cfn, var, tnr')
	-------------------------------------------------
	generate_expression(Exp.BINARY(e1,op,e2),tnr) => (cfn, var, tnr')

  rule	generate_unary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.UNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_lbinary(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LBINARY(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_lunary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LUNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_relation(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.RELATION(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	generate_temp_decl("modelica_boolean",tnr1) => (decl,tvar,tnr1') &
	Util.string_append_list([tvar," = ",var1,";"]) => b_stmt &
	Util.string_append_list(["if (",tvar,") {"]) => if_begin &
	c_add_statements(cfn1,[b_stmt,if_begin]) => cfn1'' &
	c_add_variables(cfn1'',[decl]) => cfn1' &	

	generate_expression(then,tnr1') => (cfn2,var2,tnr2) &
	c_add_statements(cfn2,["}","else {"]) => cfn2' &

	generate_expression(else,tnr2) => (cfn3,var3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1',cfn2',cfn3']) => cfn &

	Util.string_append_list(["((",tvar,")?",var2,":",var3,")"]) => var
	-------------------------
	generate_expression(Exp.IFEXP(e,then,else),tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = ",fn_name,"(", args_str,");"])
	  => stmt &

	c_add_statements(cfn2,[stmt]) => cfn &

	Util.string_append_list([tvar,".",ret_type,"_1"]) => var_not_bi &
	Util.if(builtin,tvar,var_not_bi) => var
	-------------------------
	generate_expression(Exp.CALL(fn,args,false,builtin),tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = ",fn_name,"(", args_str,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn
	-------------------------
	generate_expression(Exp.CALL(fn,args,true,builtin),tnr) 
	  => (cfn,tvar,tnr2)

  rule	generate_expression (crexp,tnr) => (cfn1,var1,tnr1) &
	generate_temp_decl("size_t",tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
	exp_type_str (ty,true) => typestr &
	generate_expression (dim,tnr2) => (cfn3, var2, tnr3) & 
	Util.string_append_list([tvar," = size_of_dimension_", typestr,"(", var1, ",",var2,");"]) => stmt &
	c_merge_fn(cfn2,cfn3) => cfn4 &
	c_add_statements(cfn4,[stmt]) => cfn
	-------------------------
	generate_expression(Exp.SIZE(crexp as Exp.CREF(cr,ty), SOME(dim)), tnr)
	  => (cfn,tvar,tnr2)

  rule	Print.print_buf "#-- Codegen.generate_expression: size(X) not implemented"
	--------------------------------------------------------------------------
	generate_expression(Exp.SIZE(cr, NONE), tnr) => fail

  rule	generate_expressions(elist,tnr) => (cfn1,vars1,tnr1) &
	list_length vars1 => nvars &
	int_string nvars => nvars_str &
	exp_type_str (t,true) => array_type_str &
	exp_short_type_str t => short_type_str &
	generate_temp_decl(array_type_str,tnr1) => (tdecl,tvar,tnr2) &
	Util.if(a,"","scalar_") => scalar &
	Util.if(a,"&","") => scalar_ref &
	string_append(", ",scalar_ref) => scalar_delimit &
	Util.string_delimit_list (vars1, scalar_delimit) => args_str &
	Util.string_append_list ["array_",scalar,array_type_str,"(&",
				 tvar,", ",nvars_str,", ",
				 scalar_ref,args_str,");"
				 ] => stmt &
	c_add_variables(cfn1,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------
	generate_expression(Exp.ARRAY(t,a,elist),tnr) => (cfn,tvar,tnr2)

  rule	generate_matrix(t,maxn,ell,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.MATRIX(t,maxn,ell),tnr) => (cfn,var,tnr')

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	exp_type_str (t,true) => type_string &
	generate_temp_decl(type_string,tnr2) => (tdecl,tvar,tnr3) &
	Util.string_append_list(["range_alloc_",type_string,"(",
				 var1,", ",var2,", 1, &",tvar,");"]) => stmt &

	c_add_variables(cfn1,[tdecl]) => cfn1' &
	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fns([cfn1',cfn2']) => cfn
	-------------------------
	generate_expression(Exp.RANGE(t,e1,NONE,e2),tnr) => (cfn,tvar,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	generate_expression(e3,tnr1)=> (cfn3,var3,tnr3) &
	exp_type_str (t,true) => type_string &
	generate_temp_decl(type_string,tnr3) => (tdecl,tvar,tnr4) &
	Util.string_append_list(["range_alloc_",type_string,"(",
				 var1,", ",var3,", ",var2,", &",tvar,");"]) 
	  => stmt &

	c_add_variables(cfn1,[tdecl]) => cfn1' &
	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fns([cfn1',cfn2']) => cfn
	-------------------------
	generate_expression(Exp.RANGE(t,e1,SOME(e2),e3),tnr) => (cfn,tvar,tnr4)

  rule	Print.print_buf "# Codegen.generate_expression: tuple not implemented\n"
	-------------------------
	generate_expression(Exp.TUPLE(_),_) => fail

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_int)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.INT,e),tnr) => (cfn,var',tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_real)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.REAL,e),tnr) => (cfn,var',tnr')

  rule	Print.print_buf "# Codegen.generate_expression: asub not implemented\n"
	-------------------------
	generate_expression(Exp.ASUB(_,_),_) => fail

  
  rule	(*Debug.fprintln("failtrace","# generate_expression failed") &
	Debug.fcall("failtrace",Exp.print_exp,e) &
	Debug.fprintln("failtrace","")*)
	----------------
	generate_expression(e,_) => fail
end

relation generate_unary : (Exp.Operator, Exp.Exp, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS(Exp.REAL), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS(Exp.INT), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list ["(-",var,")"] => var'
	------------------------
	generate_unary (Exp.UMINUS(Exp.REAL), e, tnr) => (cfn, var', tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list ["(-",var,")"] => var'
	------------------------
	generate_unary (Exp.UMINUS(Exp.INT), e, tnr) => (cfn, var', tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS_ARR(Exp.REAL), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS_ARR(Exp.INT), e, tnr) => (cfn, var, tnr')

  rule	Print.print_buf "# unary minus for arrays not implemented\n"
	------------------------
	generate_unary (Exp.UMINUS_ARR(_), _, _) => fail



end

(*

 generate_binary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_binary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =
	  
  rule	generate_expression(e1,tnr ) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) => (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," + ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.ADD(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," - ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.SUB(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," * ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.MUL(_),e2,tnr) => (cfn,var,tnr2)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," / ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.DIV(_),e2,tnr) => (cfn,var,tnr2)

  rule	Print.print_buf "# pow not implemented yet"
	-------------------------------
	generate_binary(e1,Exp.POW(_),e2,tnr) => fail

  rule	Print.print_buf "# Unary minus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UMINUS(_),_,_) => fail
	
  rule	Print.print_buf "# Unary plus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UPLUS(_),_,_) => fail
		
  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_real_array(&",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.REAL),e2, tnr) => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_real_array(&",var1,", &",
			var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.INT),e2, tnr)
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_real_array(",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_integer_array(",var1,
		       ", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_real_scalar_product(&",var1,
			", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.REAL),e2, tnr)
	  => (cfn,var,tnr2)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_integer_scalar_product(&",var1,
		       ", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_matrix_product_smart(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_matrix_product_smart(&",
				 var1,", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["div_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.DIV_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["div_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.DIV_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	Print.print_buf "# div_array_scalar FAILING BECAUSE IT SUX\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	Print.print_buf "# pow_array not implemented\n"
	-------------------------
	generate_binary(_,Exp.POW_ARR(_),_,_) => fail

  rule	Print.print_buf "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	Print.print_buf "# generate_binary failed\n"
	-------------------------
	generate_binary(_,_,_,_) => fail



end

relation generate_temp_decl : (string, int) => (string, string, int) =
	 
  rule	int_string(tnr) => tnr_str &
	int_add(tnr,1) => tnr' &
	string_append("tmp",tnr_str) => tmp_name &
	Util.string_append_list([t," ",tmp_name,";"]) => t' 
	------------------------------	
	generate_temp_decl(t, tnr) => (t', tmp_name, tnr')

end
 
relation generate_scalar_lhs_cref : (Exp.Type, Exp.ComponentRef, int)
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[])
	--------------------
	generate_scalar_lhs_cref(t,cref,tnr)
	  => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	generate_scalar_rhs_cref(cref_str,t,subs,tnr) => (cfn,var,tnr')
	--------------------
	generate_scalar_lhs_cref(t,cref,tnr)
	  => (cfn,var,tnr')

	    (* two special cases rules for 1 and 2 dimensions for faster code (no vararg) *)
  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 1 &  (* ndims == 1*)
	int_string 1 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr1(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
 
  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 2 & (* ndims == 2 *)
	int_string 2 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr2(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)


  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
  
  rule	Print.print_buf "# generate_scalar_lhs_cref failed\n"
	-----------------------------
	generate_scalar_lhs_cref(_,_,_) => fail

end

relation generate_rhs_cref : (Exp.ComponentRef, Exp.Type, int) 
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[]) 
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => true &
	generate_scalar_rhs_cref(cref_str,crt, subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => false &
	generate_array_rhs_cref(cref_str,crt,subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

end

relation subs_to_scalar : Exp.Subscript list => bool =

  axiom subs_to_scalar [] => true
  axiom subs_to_scalar Exp.SLICE(_)::_ => false
  axiom	subs_to_scalar Exp.WHOLEDIM::_ => false

  rule	subs_to_scalar r => b
	---------------------
	subs_to_scalar Exp.INDEX(_)::r => b

end

relation generate_scalar_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

	   (* Two special rules for faster code when ndims == 1 or 2 *)
	
  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 1 & (* ndims == 1*)
	int_string 1 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr1(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 2 & (* ndims == 2*)
	int_string 2 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr2(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)
end

relation generate_array_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_index_spec(subs,tnr) => (cfn1,spec1,tnr1) &
	exp_type_str(crt,true) => array_type_str &
	generate_temp_decl(array_type_str,tnr1) => (decl,temp,tnr2) &
	Util.string_append_list(["index_alloc_",array_type_str,"(&",cref_str,
				 ", &",spec1,", &",temp,");"]) => stmt &
	c_add_variables(cfn1,[decl]) => cfn'&
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------------------------
	generate_array_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn,temp,tnr2)
end

relation generate_index_spec : (Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices_array(subs,tnr) => (cfn1,idxs1,idxsizes,tnr1) &
	generate_temp_decl("index_spec_t",tnr1) => (decl,spec,tnr2) &
	list_length idxs1 => nridx &
	int_string nridx => nridx_str &
	Util.list_thread(idxsizes,idxs1) => idxs' &
	Util.string_delimit_list(idxs',", ") => idxs_str &
	Util.string_append_list(["create_index_spec(&",
				 spec,", ",nridx_str,", ",idxs_str,");"]) 
	  => stmt &
  
	c_add_variables(cfn1,[decl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	
	---------------------------------------------
	generate_index_spec (subs, tnr) => (cfn,spec,tnr2)

  rule	Print.print_buf "# generate_index_spec failed\n"
	-----------------------------
	generate_index_spec(_,_) => fail

end

relation generate_indices_array : (Exp.Subscript list, int) 
	  => (CFunction, string list, string list, int) =

  axiom	generate_indices_array ([],tnr) => (c_empty_function,[],[],tnr)

  rule	generate_index_array(f,tnr) => (cfn1,idx1,idxsize1, tnr1) &
	generate_indices_array(r,tnr1)=>(cfn2,idxs2,idxsizes2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2 &
	let idxsizes = idxsize1::idxsizes2
	---------
	generate_indices_array (f::r, tnr) => (cfn,idxs,idxsizes,tnr2)

  rule	Print.print_buf "# generate_indices_array failed\n"
	-----------------------------
	generate_indices_array(_,_) => fail

end

relation generate_indices : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index(f,tnr) => (cfn1, idx1, tnr1) &
	generate_indices(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices (f::r, tnr) => (cfn,idxs,tnr2)

  rule	Print.print_buf "# generate_indices failed\n"
	-----------------------------
	generate_indices(_,_) => fail

end

relation generate_index_array : (Exp.Subscript, int)
	  => (CFunction, string, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1) &
	Util.string_append_list(["make_index_array(1, ",var1,")"]) => idx &
	let idxsize = "(0)"
	------------------------------------
	generate_index_array(Exp.INDEX(e), tnr) 
	  => (cfn,idx,idxsize,tnr1)

  rule	let idx = "(0)" &
	let idxsize = "(1)"
	------------------------------------
	generate_index_array(Exp.WHOLEDIM, tnr) 
	  => (c_empty_function,idx,idxsize,tnr)

	  
  rule	Print.print_buf "# generate_index_array failed\n"
	-----------------------------
	generate_index_array(_,_) => fail

end

relation generate_index : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1)	
	------------------------------------
	generate_index(Exp.INDEX(e), tnr) => (cfn,var1,tnr1)

  rule	Print.print_buf "# generate_index failed\n"
	-----------------------------
	generate_index(_,_) => fail

end

relation indent_strings : string list => string list =

  axiom	indent_strings [] => []

  rule	string_append("  ",f) => f' &
	indent_strings r => r'
	-----------------------------
	indent_strings f::r => f'::r'
	
end

relation ident_cstr : string => string =
  axiom ident_cstr s => s
end

relation comp_ref_cstr : Exp.ComponentRef => (string, Exp.Subscript list) =

  rule	ident_cstr id => id_str
	---------------------
	comp_ref_cstr Exp.CREF_IDENT(id,subs) => (id_str,subs)

  rule	ident_cstr id => id_str &
	comp_ref_cstr cref => (cref_str,cref_subs) &
	Util.string_append_list([id,"__",cref_str]) => cref_str' &
	Util.list_flatten([subs,cref_subs]) => subs'
	------------------------------
	comp_ref_cstr Exp.CREF_QUAL(id,subs,cref) => (cref_str',subs')

end


(*

 generate_lbinary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_lbinary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.AND,e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.OR,e2,tnr) => (cfn, var, tnr2)


  rule	Print.print_buf "# generate_lbinary failed\n"
	-----------------------------
	generate_lbinary (_,_,_,_) => fail

end

(*

 generate_lunary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_lunary : (Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	Util.string_append_list(["(!",var1,")"]) => var
	-------
	generate_lunary (Exp.NOT,e,tnr) => (cfn1, var, tnr1)


  rule	Print.print_buf "# generate_lbinary failed\n"
	-----------------------------
	generate_lunary (_,_,_) => fail

end

(*

 generate_relation

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_relation : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESS(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATER(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && !",var2,") || (",
			var1," && ",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," == ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# Reals can't be compared with ==\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.REAL),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && ",var2,") || (",
			var1," && !",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," != ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# Reals can't be compared with <>\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.REAL),e2,tnr) => fail


  rule	Print.print_buf "# generate_relation failed\n"
	-----------------------------
	generate_relation (_,_,_,_) => fail

end

relation generate_matrix : (Exp.Type, int, (Exp.Exp*bool) list list, int) 
	  => (CFunction, string, int) =


  rule	generate_matrix_expressions(typ,exps,maxn,tnr) => (cfn1,vars1,tnr1) &
	concatenate_matrix_rows(typ,vars1,tnr1) => (cfn2,vars2,tnr2) &
	
	exp_type_str(typ,true) => array_type_str &
	Util.string_delimit_list(vars2,", &") => args_str &
	list_length(vars2) => n &
	int_string n => n_str &
	generate_temp_decl(array_type_str,tnr2) => (tdecl,tvar,tnr3) &
	Util.string_append_list(["cat_alloc_",array_type_str,"(1, &",
				 tvar,", ",n_str,
				 ", &",args_str,");"]) => stmt &

	c_add_variables(cfn2,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn'' &
	c_merge_fn(cfn1,cfn'') => cfn
	
	(*

	 Generate code for every expression and
	 promote it to maxn dimensions
	 for every row create cat(2,rowvar1,....)
	 for every column create cat(1,row1,....)

	 *)
	---------------------
	generate_matrix(typ,maxn,exps,tnr) => (cfn,tvar,tnr3)

end

relation concatenate_matrix_rows : (Exp.Type, string list list, int)
	=> (CFunction, string list, int) =

  axiom	concatenate_matrix_rows (_,[],tnr) => (c_empty_function, [], tnr)

  rule	concatenate_matrix_row(typ,f,tnr) => (cfn1,var1,tnr1) &
	concatenate_matrix_rows(typ,r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------
	concatenate_matrix_rows (typ,f::r,tnr) => (cfn,var1::vars2,tnr2)

end

relation concatenate_matrix_row : (Exp.Type, string list, int) 
	  => (CFunction, string, int) =

  rule	exp_type_str(typ,true) => array_type_str &
	Util.string_delimit_list(vars,", &") => args_str &
	list_length(vars) => n &
	int_string n => n_str &
	generate_temp_decl(array_type_str,tnr) => (tdecl,tvar,tnr1) &
	Util.string_append_list(["cat_alloc_",array_type_str,"(2, &",
				 tvar,", ",n_str,
				 ", &",args_str,");"]) => stmt &

	c_add_variables(c_empty_function,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	---------
	concatenate_matrix_row (typ,vars,tnr) => (cfn,tvar, tnr1)
end

relation generate_matrix_expressions : (Exp.Type,(Exp.Exp*bool) list list, int, int) =>
	(CFunction, string list list, int) =

  axiom	generate_matrix_expressions(_,[],_,tnr) => (c_empty_function,[],tnr)


  rule	generate_matrix_expr_row (typ,fr,maxn,tnr) => (cfn1,vars1,tnr1) &
	generate_matrix_expressions(typ,rr,maxn,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_matrix_expressions(typ,fr::rr,maxn,tnr) 
	  => (cfn,vars1::vars2,tnr2)


end

relation generate_matrix_expr_row : (Exp.Type,(Exp.Exp*bool) list, int, int)
	  => (CFunction,string list, int) =

  axiom	generate_matrix_expr_row (_,[],_,tnr) => (c_empty_function,[],tnr)

  rule	generate_matrix_expression(t,f,maxn,tnr) => (cfn1,var1,tnr1) &
	generate_matrix_expr_row(t,r,maxn,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------
	generate_matrix_expr_row(t,f::r,maxn,tnr) => (cfn,var1::vars2,tnr2)


end
	
relation generate_matrix_expression : (Exp.Type,(Exp.Exp*bool), int, int) 
	=> (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(t,true) => array_type_str &
	int_string maxn => maxn_str &
	generate_temp_decl(array_type_str,tnr1) => (tdecl,tvar,tnr2) &
	Util.if(b,"","scalar_") => scalar &
	Util.if(b,"&","") => sc_ref &
	Util.string_append_list(["promote_",scalar,array_type_str,"(",
				 sc_ref,var1,
				 ", ",maxn_str,", &",tvar,");"]) => stmt &
	c_add_variables(cfn1,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	---------------------------------
	generate_matrix_expression(t,(e,b),maxn,tnr) => (cfn,tvar,tnr2)

end
(* generate_read_call_write(fpath,outvars,retstr,args) => rcw_fn *)
relation generate_read_call_write : (string,
				     DAE.Element list,
				     string,
				     DAE.Element list)
	=> CFunction =


  rule	Debug.fprintln ("cgtr", "generate_read_call_write") &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES",
			       out_decl]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)
	generate_var_decls(invars,is_rcw_input,1) => (cfn31,tnr21) &
	generate_var_inits(invars,is_rcw_input,tnr21,"") => (cfn32,tnr2) &
	c_merge_fns([cfn31,cfn32]) => cfn3 &
	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &
	invar_names invars => in_names &
	Util.string_delimit_list(in_names,", ") => in_args &
	
	generate_read(invars) => cfn4 &
	Util.string_append_list(["out = ",fnname,"(",in_args,");"]) => fn_call &
	c_add_statements(cfn4,["PRE_READ_DONE",
			       fn_call,
			       "PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE",
			       "return 0;"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',cfn4',cfn5']) => cfn 
	------------------------------------------------------
	generate_read_call_write(fnname,outvars,retstr,invars) => cfn

end

(*


  rule	Debug.fprintln ("cgtr", "generate_read_call_write_external") &
	let tnr = 1 &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl &
	c_add_inits(cfn1, ["PRE_VARIABLES"]) => cfn11' &
	c_add_variables(cfn11', [out_decl]) => cfn1' &

	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)

	generate_alloc_outvars_ext(outvars, "out", tnr, extdecl) 
	  => (allocstmts, tnr_ret) &
	generate_alloc_outvars_ext(bivars, "", tnr_ret, extdecl) 
	  => (biallocstmts, tnr_bialloc) &

	generate_temp_decl("state",tnr_bialloc) => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var, " = get_memory_state();"])
	  => mem_stmt1 &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => mem_stmt2 &
	
	c_add_variables(mem_stmt1, [mem_decl]) => mem_fn' &
	c_add_inits(mem_fn', [allocstmts]) => mem_fn &

	generate_var_decls(invars,is_rcw_input,tnr_mem) => (cfn31,tnr_invars1) &
	generate_var_inits(invars,is_rcw_input,tnr_invars1,"") => (cfn32,tnr_invars) &

	generate_var_decls(bivars,is_rcw_bidir,tnr_invars) => (cfn33, tnr_bivars1) &
	generate_var_inits(bivars,is_rcw_bidir,tnr_bivars1,"") => (cfn34, tnr_bivars) &
	
	c_merge_fns([cfn31, cfn32, cfn33, cfn34]) => cfn3 &

	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &

	generate_read(invars) => readinvars & 
	c_add_inits(readinvars, ["PRE_READ_DONE"]) => readdone &

	list_append (invars, outvars) => vars' &
	list_append (vars', bivars) => vars &

	generate_ext_call (vars, extdecl, tnr_bivars) => (extcall, tnr_extcall) &
	c_add_statements(extcall,["PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',readdone,mem_fn,biallocstmts,cfn4',cfn5']) => cfn' &

	c_add_cleanups(cfn', [mem_stmt2, "return 0;"]) => cfn
	------------------------------------------------------
	generate_read_call_write_external(fnname,outvars,retstr,invars,extdecl,bivars) => cfn

  rule	Print.print_buf "#-- generate_read_call_write_external failed\n"
	----------------------------------------------------------------
	generate_read_call_write_external (_,_,_,_,_,_) => fail

end

*)


relation generate_read_call_write_external : (string,
				     DAE.Element list,
				     string,
				     DAE.Element list,
				     DAE.ExternalDecl,
				     DAE.Element list)
	=> CFunction =


  rule	Debug.fprintln ("cgtr", "generate_read_call_write_external") &
	let tnr = 1 &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES"]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)

	generate_alloc_outvars_ext(outvars, "out", tnr, extdecl) 
	  => (allocstmts', tnr_ret) &
	c_add_variables(allocstmts', [out_decl]) => allocstmts &
	generate_alloc_outvars_ext(bivars, "", tnr_ret, extdecl) 
	  => (biallocstmts, tnr_bialloc') &

	generate_var_inits(outvars,is_rcw_output,tnr_bialloc',"out") =>	(cfnoutinit,tnr_bialloc) &
	c_merge_fns([allocstmts,biallocstmts,cfnoutinit]) => cfnoutbialloc &

	generate_temp_decl("state",tnr_bialloc) => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var, " = get_memory_state();"])
	  => get_mem_stmt &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => rest_mem_stmt &
	
	c_add_variables(c_empty_function, [mem_decl]) => mem_fn' &
	c_add_inits(mem_fn', [get_mem_stmt]) => mem_fn'' &
	c_merge_fns([mem_fn'',cfnoutbialloc]) => mem_fn &
	

	generate_var_decls(invars,is_rcw_input,tnr_mem) => (cfn31,tnr_invars1) &
	generate_var_inits(invars,is_rcw_input,tnr_invars1,"") => (cfn32,tnr_invars) &

	generate_var_decls(bivars,is_rcw_bidir,tnr_invars) => (cfn33, tnr_bivars1) &
	generate_var_inits(bivars,is_rcw_bidir,tnr_bivars1,"") => (cfn34, tnr_bivars) &
	
	c_merge_fns([cfn31, cfn32, cfn33, cfn34]) => cfn3 &

	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &

	generate_read(invars) => readinvars & 
	c_add_inits(readinvars, ["PRE_READ_DONE"]) => readdone &

	list_append (invars, outvars) => vars' &
	list_append (vars', bivars) => vars &

(*
	generate_var_inits(outvars, tnr_bivars) => (cfnvarinits1, tnr_varinits1) &
	generate_var_inits(bivars, tnr_varinits1) => (cfnvarinits2, tnr_varinits2) &

	c_merge_fns([cfnvarinits1,cfnvarinits2]) => cfnvarinits &

	generate_ext_call (vars, extdecl, tnr_varinits2) => (extcall, tnr_extcall) &
*)

	generate_ext_call (vars, extdecl, tnr_bivars) => (extcall, tnr_extcall) &
	c_add_statements(extcall,["PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE"]) => cfn5' &

(*	c_merge_fns([cfn1',cfn3',readdone,mem_fn,biallocstmts,cfnvarinits,cfn4',cfn5']) => cfn' & *)

	c_merge_fns([cfn1',cfn3',readdone,mem_fn,cfn4',cfn5']) => cfn' &

	c_add_cleanups(cfn', [rest_mem_stmt, "return 0;"]) => cfn
	------------------------------------------------------
	generate_read_call_write_external(fnname,outvars,retstr,invars,extdecl,bivars) => cfn

  rule	Print.print_buf "#-- generate_read_call_write_external failed\n"
	----------------------------------------------------------------
	generate_read_call_write_external (_,_,_,_,_,_) => fail

end


relation generate_ext_call : (DAE.Element list, DAE.ExternalDecl, int) => (CFunction, int) =

  rule	Debug.fcall ("cgtrdumpdaeextcall", DAE.dump2, DAE.DAE(vars)) &
	DAE.dump_ext_decl_str extdecl => extdeclstr &
	Debug.fprintln ("cgtrdumpdaeextcall", extdeclstr) &
	generate_extcall_vardecls (vars, arglist, retarg, lang, tnr) => (argdecls,arglist',tnr') &
	generate_ext_call_fcall (n, arglist', retarg, lang) => fcall &
	Util.list_matching (arglist', is_extarg_output_or_bidir) => outbiarglist &
	generate_extcall_varcopy (outbiarglist, retarg, lang, tnr') => (argcopies,tnr'') &
	c_merge_fns([argdecls,fcall,argcopies]) => extcall
	-------------------------------------------------------------
	generate_ext_call (vars, extdecl as DAE.EXTERNALDECL(n,arglist,retarg,lang), tnr) => (extcall,tnr'')

  rule	Print.print_buf "#-- generate_ext_call failed\n"
	------------------------------------------------
	generate_ext_call (_,_,_) => fail
end


relation generate_extcall_vardecls : (DAE.Element list, DAE.ExtArg list,
				      DAE.ExtArg, string, int) 
	  => (CFunction, DAE.ExtArg list, int) =

  rule	generate_extcall_vardecls2 (args, retarg) => (decls)
	----------------------------------------------------
	generate_extcall_vardecls (vars, args, retarg, "C", tnr) => (decls,args,tnr)

  rule	generate_extcall_copydecls_f77 (vars,tnr) => (copydecls,tnr') &
	generate_extcall_vardecls2_f77 (args, retarg, tnr') => (decls, args', tnr'') &
	c_merge_fn (copydecls, decls) => res
	-----------------------------------------------------------------
	generate_extcall_vardecls (vars, args, retarg, "FORTRAN 77",tnr) => (res, args', tnr'')

  rule	Print.print_buf "#-- generate_extcall_vardecls failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls (_,_,_,_,_) => fail

end

relation generate_extcall_copydecls_f77 : (DAE.Element list, int) => (CFunction, int) =

  axiom	generate_extcall_copydecls_f77 ([], tnr) => (c_empty_function, tnr)

  rule	let DAE.VAR(cref, vk, vd, ty, value, dims,start,_,_) = var &
	is_array var => true &
	var_name_external_cref cref => cref' &
	list_reverse dims => dims' &
	let extvar = DAE.VAR(cref', vk, vd, ty, value, dims',NONE,DAE.NON_FLOW,Absyn.IDENT("$extvar$")) &
	generate_var_decl (extvar, tnr) => (fn, tnr') &
	generate_extcall_copydecls_f77 (rest, tnr') => (restfn, tnr''') &
	c_merge_fn (fn, restfn) => resfn
	--------------------------------
	generate_extcall_copydecls_f77 (var::rest, tnr) => (resfn,tnr''')

  rule	Debug.fprint("cgtr", "#--Ignoring: ") &
	Debug.fcall("cgtr", DAE.dump2, DAE.DAE([var])) &
	Debug.fprintln("cgtr", "") &
	generate_extcall_copydecls_f77 (rest, tnr) => (fn,tnr')
	-------------------------------------------------------
	generate_extcall_copydecls_f77 (var::rest, tnr) => (fn, tnr')

end

relation generate_extcall_vardecls2 : (DAE.ExtArg list, DAE.ExtArg) => CFunction =

  axiom	generate_extcall_vardecls2 ([],DAE.NOEXTARG) => c_empty_function

  rule	generate_extcall_vardecl retarg => retdecl
	-----------------------------------------
	generate_extcall_vardecls2 ([],retarg) => retdecl

  rule	generate_extcall_vardecl var => decl &
	generate_extcall_vardecls2 (rest, retarg) => decls &
	c_merge_fn(decl, decls) => res
	---------------------------------------------
	generate_extcall_vardecls2 (var::rest, retarg) => res

  rule	Print.print_buf "#-- generate_extcall_vardecls2 failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls2 (_,_) => fail

end

relation generate_vardecl_func : (string, string, string option) => CFunction =

  rule	Util.string_append_list ([tystr, " ", name, " = (", tystr, ")", expr, ";"]) => str &
	c_add_variables(c_empty_function, [str]) => res
	-----------------------------------------------
	generate_vardecl_func (tystr, name, SOME(expr)) => res

  rule	Util.string_append_list ([tystr, " ", name, ";"]) => str &
	c_add_variables(c_empty_function, [str]) => res
	-----------------------------------------------
	generate_vardecl_func (tystr, name, NONE) => res

end

relation generate_extcall_vardecl : DAE.ExtArg => CFunction =

	(* INPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) = arg &
	Types.is_array ty => false &
	Types.is_string ty => false &
	generate_type_external ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_vardecl_func (tystr, name, SOME(orgname)) => res
	--------------------------------------------------------
	generate_extcall_vardecl arg => res

	(* INPUT NON-ARRAY STRING *)
	(* do nothing *)

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) = arg &
	Types.is_array ty => true
	--------------------------------------------------------
	generate_extcall_vardecl arg => c_empty_function

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.OUTPUT), ty) = arg &
	Types.is_array ty => false &
	generate_type_external ty => tystr &
	var_name_external cref => name &
	generate_vardecl_func (tystr, name, NONE) => res
	--------------------------------------------------------
	generate_extcall_vardecl arg => res

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.OUTPUT), ty) = arg &
	Types.is_array ty => true
	---------------------------
	generate_extcall_vardecl arg => c_empty_function

(*
	(* INPUT/OUTPUT ARRAY/NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	generate_type_external ty => tystr &
	comp_ref_cstr cref => (name,_) &
	generate_vardecl_func (tystr, name, NONE) => res
	---------------------------
	generate_extcall_vardecl arg => res
*)

  axiom	generate_extcall_vardecl DAE.EXTARG(cr, attr, ty) => c_empty_function
  axiom	generate_extcall_vardecl DAE.EXTARGEXP(exp, ty) => c_empty_function

	(* SIZE *)
  axiom	generate_extcall_vardecl DAE.EXTARGSIZE(_,_,_,_) => c_empty_function


  rule	Print.print_buf "#-- generate_extcall_vardecl failed\n"
	-------------------------------------------------------
	generate_extcall_vardecl _ => fail

end



relation generate_extcall_vardecls2_f77 : (DAE.ExtArg list, DAE.ExtArg, int)
	  => (CFunction, DAE.ExtArg list, int) =

  axiom	generate_extcall_vardecls2_f77 ([],DAE.NOEXTARG,tnr) => (c_empty_function,[],tnr)

  rule	generate_extcall_vardecl_f77 (retarg,tnr) => (retdecl,_,tnr')
	-------------------------------------------------
	generate_extcall_vardecls2_f77 ([],retarg,tnr) => (retdecl,[],tnr')

  rule	generate_extcall_vardecl_f77 (var,tnr) => (decl,var',tnr') &
	generate_extcall_vardecls2_f77 (rest, retarg, tnr') => (decls,varr, tnr'') &
	c_merge_fn(decl,decls) => res
	---------------------------------------------
	generate_extcall_vardecls2_f77 (var::rest, retarg, tnr) => (res, var'::varr, tnr'')

  rule	Print.print_buf "#-- generate_extcall_vardecls2_f77 failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls2_f77 (_,_,_) => fail

end

relation generate_c_to_f77_converter : Types.Type => string =

  rule	Types.array_element_type ty => elty &
	generate_type_internal_namepart elty => eltystr &
	Util.string_append_list (["convert_alloc_",eltystr,"_array_to_f77"]) => str
	---------------------------------------------------------------------
	generate_c_to_f77_converter (ty as (Types.T_ARRAY(_,_),_)) => str

  rule	Print.print_buf "#-- generate_c_to_f77_converter failed\n" &
	Print.print_buf "#-- Not an array?\n" &
	Types.print_type ty
	---------------------------------------------
	generate_c_to_f77_converter ty => fail

end

relation generate_f77_to_c_converter : Types.Type => string =

  rule	Types.array_element_type ty => elty &
	generate_type_internal_namepart elty => eltystr &
	Util.string_append_list (["convert_alloc_",eltystr,"_array_from_f77"]) => str
	---------------------------------------------------------------------
	generate_f77_to_c_converter (ty as (Types.T_ARRAY(_,_),_)) => str

  rule	Print.print_buf "#-- generate_f77_to_c_converter failed\n" &
	Print.print_buf "#-- Not an array?\n"
	---------------------------------------------
	generate_f77_to_c_converter _ => fail

end

relation is_output_or_bidir : Types.Attributes => bool =

  rule	Types.is_output_attr attr => outvar &
	Types.is_bidir_attr attr => bivar &
	bool_or (outvar, bivar) => res
	---------------------------------
	is_output_or_bidir attr => res
end

relation generate_extcall_vardecl_f77 : (DAE.ExtArg,int) => (CFunction, DAE.ExtArg, int) =

	(* INPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_1") &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77 (arg,tnr) => (res, arg, tnr)

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_2") &
	Types.is_input_attr attr => true &
	Types.is_array ty => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	----------------------------------------------------------------
	generate_extcall_vardecl_f77 (extarg, tnr) => (res, extarg, tnr)

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_3") &
	Types.is_output_attr attr => true &
	Types.is_array ty => false &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res,arg, tnr)

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_4") &
	Types.is_array ty => true &
	Types.is_output_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&out.", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	---------------------------
	generate_extcall_vardecl_f77 (extarg, tnr) => (res, extarg, tnr)

	(* INPUT/OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => true &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_41") &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res, arg, tnr)

	(* INPUT/OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_41") &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res, arg, tnr)


  rule	let DAE.EXTARGEXP(exp, ty) = arg &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res, arg, tnr)


	(* SIZE *)
  rule	let DAE.EXTARGSIZE(cr, attr, ty, dim) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_5") &
	var_name_array (cr,attr) => tmpname' &
	int_string tnr => tnrstr &
	int_add(tnr,1) => tnr' &
	Util.string_append_list([tmpname',"_size_",tnrstr]) => tmpstr &
	let tmpcref = Exp.CREF_IDENT(tmpstr,[]) &
	generate_ext_array_size_call arg => callstr &
	Util.string_append_list(["int ",tmpstr,";"]) => declstr &
	c_add_variables(c_empty_function, [declstr]) => decl &
	Util.string_append_list([tmpstr," = ",callstr,";"]) => callstr &
	c_add_statements(decl, [callstr]) => res &
	let newarg = DAE.EXTARGSIZE(tmpcref, attr, ty, dim)
	-----------------------------------------------------------------
	generate_extcall_vardecl_f77 (arg, tnr)  => (res, newarg, tnr')


  rule	Print.print_buf "#-- generate_extcall_vardecl_f77 failed\n#-- " &
	DAE.dump_ext_arg_str arg => argstr &
	Print.print_buf argstr & Print.print_buf "\n"
	-------------------------------------------------------
	generate_extcall_vardecl_f77 (arg,_) => fail

end

(* input string is language *)
relation generate_ext_call_fcall : (Ident, DAE.ExtArg list, DAE.ExtArg, string) => CFunction =

	(* call without return value *)
  rule	generate_ext_call_fcall2 (fnname,args,lang) => fcall2 &
	string_append(fcall2, ";") => str &
	c_add_statements(c_empty_function, [str]) => res
	---------------------------------------------
	generate_ext_call_fcall (fnname, args, DAE.NOEXTARG, lang) => res

	(* return value assignment, shouldn't happen for arrays *)
  rule	Types.is_array ty => false &
	generate_ext_call_fcall2 (fnname,args,lang) => fcall2 &
	var_name_external cr => crstr &
	Util.string_append_list([crstr," = ", fcall2, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	---------------------------------------------
	generate_ext_call_fcall (fnname, args, DAE.EXTARG(cr,_,ty), lang) => res

  rule	Print.print_buf "#-- generate_ext_call_fcall failed\n"
	------------------------------------------------------
	generate_ext_call_fcall (_,_,_,_) => fail

end	


relation generate_ext_call_fcall2 : (Ident, DAE.ExtArg list, string) => string =

  rule	Util.list_map (args, generate_ext_call_fcall_arg) => strlist &
	Util.string_delimit_list (strlist, ", ") => str &
	Util.string_append_list([n,"(",str,")"]) => res
	-----------------------------------------------
	generate_ext_call_fcall2 (n, args, "C") => res

  rule	Util.list_map (args, generate_ext_call_fcall_arg_f77) => strlist &
	Util.string_delimit_list (strlist, ", ") => str &
	Util.string_append_list([n,"_(",str,")"]) => res
	-----------------------------------------------
	generate_ext_call_fcall2 (n, args, "FORTRAN 77") => res

  rule	Print.print_buf "#-- generate_ext_call_fcall2 failed\n"
	------------------------------------------------------
	generate_ext_call_fcall2 (_,_,_) => fail

end

(* HERE!!! is_array AND is_string
   string has also .data
*)
relation generate_ext_call_fcall_arg : DAE.ExtArg => string =

	(* INPUT NON-ARRAY NON-STRING *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	Types.is_string ty => false &
	var_name_external cref => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* INPUT/OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => true &
	var_name_array (cref,attr) => name &
	string_append(name,".data") => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* INPUT/OUTPUT STRING *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_string ty => true &
	comp_ref_cstr cref => (name,_) &
	string_append(name, ".data") => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

	(* INPUT/OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res
	-----------------------------
	generate_ext_call_fcall_arg arg => res

  rule	let DAE.EXTARGEXP(exp, ty) = arg &
	generate_expression (exp,1) => (_, res, _)
	------------------------------------------
	generate_ext_call_fcall_arg arg => res

(*
  rule	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.BIDIR), ty) => res
*)

	(* SIZE *)
  rule	generate_array_size_call arg => str
	-----------------------------
	generate_ext_call_fcall_arg (arg as DAE.EXTARGSIZE(_,_,_,_)) => str


  rule	Print.print_buf "#-- generate_ext_call_fcall_arg failed\n" &
	DAE.dump_ext_arg_str arg => str &
	Print.print_buf str & Print.print_buf "\n"
	----------------------------------------------------------
	generate_ext_call_fcall_arg arg => fail

end

relation generate_ext_call_fcall_arg_f77 : DAE.ExtArg => string =

	(* INPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_output_attr attr => true &
	Types.is_array ty => false &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_input_attr attr => true &
	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name,".data") => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_output_attr attr => true &
	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name,".data") => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* INPUT/OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name, ".data") => res
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res

	(* INPUT/OUTPUT NON-ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Types.is_array ty => false &
	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res
	-----------------------------
	generate_ext_call_fcall_arg_f77 arg => res


  rule	let DAE.EXTARGEXP(exp, ty) = arg &
	generate_ext_call_fcall_arg arg => res
	--------------------------------------
	generate_ext_call_fcall_arg_f77 arg => res


	(* SIZE *)
  rule	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 DAE.EXTARGSIZE(cref, attr, ty, dim) => res


  rule	Print.print_buf "#-- generate_ext_call_fcall_arg_f77 failed\n#-- " &
	DAE.dump_ext_arg_str arg => str &
	Print.print_buf str &
	Print.print_buf "\n"
	----------------------------------------------------------
	generate_ext_call_fcall_arg_f77 arg => fail

end


relation generate_array_size_call : DAE.ExtArg => string = 

  rule	Types.array_element_type ty => ((Types.T_INTEGER(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_integer_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Types.array_element_type ty => ((Types.T_REAL(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_real_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Print.print_buf "#-- generate_array_size_call failed\n#-- Not a DAE.EXTARGSIZE?\n"
	----------------------------------------------------------------------------------
	generate_array_size_call _ => fail
	
end

relation generate_ext_array_size_call : DAE.ExtArg => string = 

  rule	Types.array_element_type ty => ((Types.T_INTEGER(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_integer_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_ext_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Types.array_element_type ty => ((Types.T_REAL(_),_)) &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_real_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_ext_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Print.print_buf "#-- generate_array_size_call failed\n#-- Not a DAE.EXTARGSIZE?\n"
	----------------------------------------------------------------------------------
	generate_ext_array_size_call _ => fail
	
end


relation is_extarg_output : DAE.ExtArg => () =

  axiom	is_extarg_output DAE.EXTARG(_,Types.ATTR(_,_,_,Absyn.OUTPUT),_)

end

relation is_extarg_bidir : DAE.ExtArg => () =

  axiom	is_extarg_bidir DAE.EXTARG(_,Types.ATTR(_,_,_,Absyn.BIDIR),_)

end

relation is_extarg_output_or_bidir : DAE.ExtArg => () =

  rule	is_extarg_output arg
	--------------------
	is_extarg_output_or_bidir arg

  rule	is_extarg_bidir arg
	--------------------
	is_extarg_output_or_bidir arg

end

relation generate_extcall_varcopy : (DAE.ExtArg list, DAE.ExtArg, string, int) => (CFunction, int) =

  axiom	generate_extcall_varcopy ([],DAE.NOEXTARG,_,tnr) => (c_empty_function,tnr)

  rule	is_extarg_output retarg & 
	generate_extcall_varcopy_single retarg => retcopy
	--------------------------------------------------------------
	generate_extcall_varcopy ([],retarg,lang,tnr) => (retcopy,tnr)

  rule	not is_extarg_output retarg
	-----------------------------------------
	generate_extcall_varcopy ([],retarg,lang,tnr) => (c_empty_function,tnr)

	(* extarg list is already filtered and contains only outputs *)
  rule	generate_extcall_varcopy_single var => vc &
	generate_extcall_varcopy (rest, retarg, lang,tnr) => (vcr,tnr') &
	c_merge_fn(vc, vcr) => res
	--------------------------------------------------
	generate_extcall_varcopy (var::rest, retarg, lang as "C", tnr) => (res,tnr')

  rule	generate_extcall_varcopy_single_f77 var => vc &
	generate_extcall_varcopy (rest, retarg, lang, tnr) => (vcr,tnr') &
	c_merge_fn(vc, vcr) => res
	--------------------------------------------------
	generate_extcall_varcopy (var::rest, retarg, lang as "FORTRAN 77", tnr) => (res,tnr')

  rule	Print.print_buf "#-- generate_extcall_varcopy failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy (_,_,_,_) => fail

end

relation generate_extcall_varcopy_single : DAE.ExtArg => CFunction =

  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) => res

  rule	Types.is_array ty => true &
	Types.is_output_attr attr => true
	---------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) 
	  => c_empty_function

(*
  rule	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str
	--------------------------------------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str
*)

  axiom	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) => c_empty_function

  rule	Print.print_buf "#-- generate_extcall_varcopy_single failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy_single _ => fail

end

relation generate_extcall_varcopy_single_f77 : DAE.ExtArg => CFunction =

	(* INPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_input_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res 
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res

	(* OUTPUT NON-ARRAY *)
  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, attr, ty) => res

	(* OUTPUT ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_output_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &out.", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res


	(* BIDIR ARRAY *)
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_bidir_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res

(*
  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_output_attr attr => true &
	Types.is_array ty => true
	---------------------------
	generate_extcall_varcopy_single_f77 extarg => c_empty_function
*)

(*
  rule	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str
	--------------------------------------------------------
	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str
*)

  axiom	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, attr, ty) => c_empty_function

  rule	Print.print_buf "#-- generate_extcall_varcopy_single_f77 failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy_single_f77 _ => fail

end


relation invar_names : DAE.Element list => string list =

  axiom	invar_names [] => []


  rule	comp_ref_cstr id => (cref_str,_) &
	invar_names r => r'
	----------
	invar_names DAE.VAR(id,vk,DAE.INPUT,t,_,_,_,_,_)::r => cref_str::r'

  rule	invar_names r => cfn
	-------
	invar_names _::r => cfn

end

relation is_input_or_output_var : DAE.Element => () =
	
  axiom	is_input_or_output_var DAE.VAR(_,_,DAE.INPUT,_,_,_,_,_,_)
  axiom	is_input_or_output_var DAE.VAR(_,_,DAE.OUTPUT,_,_,_,_,_,_)

end

relation var_name_external : Exp.ComponentRef => string =

  rule	var_name_external_cref cref => cref' &
	comp_ref_cstr cref' => (str, _)
	---------------------------------------
	var_name_external cref => str

end

relation var_name_external_cref : Exp.ComponentRef => Exp.ComponentRef =

  rule	suffix_cref (cref,"_ext") => cref'
	---------------------------------------
	var_name_external_cref cref => cref'
end

relation suffix_cref : (Exp.ComponentRef, string) => Exp.ComponentRef =

  rule	string_append(id, str) => id'
	--------------------------------
	suffix_cref (Exp.CREF_IDENT(id,subs), str) => Exp.CREF_IDENT(id',subs)

  rule	suffix_cref (cref,str) => cref'
	---------------------------------------
	suffix_cref (Exp.CREF_QUAL(id,subs,cref), str) => Exp.CREF_QUAL(id,subs,cref')
end

relation var_name_array : (Exp.ComponentRef, Types.Attributes) => string =

	(* INPUT *)
  rule	comp_ref_cstr cref => (str, _) &
	Types.is_input_attr attr => true
	---------------------------------------
	var_name_array (cref,attr) => str

	(* OUTPUT *)
  rule	comp_ref_cstr cref => (cref_str, _) &
	Types.is_output_attr attr => true &
	string_append ("out.", cref_str) => str
	---------------------------------------
	var_name_array (cref,attr) => str

	(* INPUT/OUTPUT *)
  rule	comp_ref_cstr cref => (str, _)
	---------------------------------------
	var_name_array (cref,attr) => str

end

relation var_arg_names_external : DAE.Element list => string list =

  axiom	var_arg_names_external [] => []


  rule	var_name_external id => cref_str &
	var_arg_names_external r => r'
	----------------------------
	var_arg_names_external DAE.VAR(id,vk,DAE.INPUT,t,_,_,_,_,_)::r => cref_str::r'

  rule	var_name_external id => cref_str &
	string_append("&", cref_str) => cref_str2 &
	var_arg_names_external r => r'
	----------------------------
	var_arg_names_external DAE.VAR(id,vk,DAE.OUTPUT,t,_,_,_,_,_)::r => cref_str2::r'

  rule	var_arg_names_external r => cfn
	-----------------------------
	var_arg_names_external _::r => cfn

end


relation generate_read : DAE.Element list => CFunction =

  axiom	generate_read [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["if(read_",type_string,"(in_file, &",cref_str,")) return 1;"])
	  => stmt &
	  
	c_add_inits(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,[],_,_,_)::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["if(read_",type_string,"(in_file, &",cref_str,")) return 1;"])
	  => stmt &
	  
	c_add_inits(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,_::_,_,_,_)::r => cfn

	
  rule	generate_read r => cfn
	-------
	generate_read _::r => cfn


end


relation generate_write : DAE.Element list => CFunction =

  axiom	generate_write [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,[],_,_,_)::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,_::_,_,_,_)::r => cfn

	
  rule	generate_write r => cfn
	-------
	generate_write _::r => cfn


end

relation is_rcw_output : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_output_var e
	--------------------
	is_rcw_output e 

end

relation is_rcw_input : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_input_var e
	--------------------
	is_rcw_input e 

end

relation is_rcw_bidir : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_bidir_var e
	--------------------
	is_rcw_bidir e 

end


relation new_ident : string => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append(str,is) => s
	-----------------------------------------------------------------
	new_ident str => Exp.CREF_IDENT(s,[])

end
