(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 static.rml
 ** module:      Static
 ** description: Static analysis of expressions
 **
 ** RCS: $Id: staticexp.rml,v 1.137 2005/01/11 10:49:04 petar Exp $
 ** 
 ** This module does static analysis on expressions.
 ** The analyzed expressions are built using the
 ** constructors in the `Exp' module from expressions defined in 'Absyn'.  
 ** Also, a set of properties of the expressions is calculated during analysis.
 ** Properties of expressions include type information and a boolean indicating if the
 ** expression is constant or not.
 ** If the expression is constant, the 'Ceval' module is used to evaluate the expression
 ** value. A value of an expression is described using the 'Values' module.

 ** The main relation in this module is 'eval_exp' which takes an Absyn.Exp and transform it 
 ** into an Exp.Exp, while performing type checking and automatic type conversions, etc.
 ** To determine types of builtin functions and operators, the module also contain an elaboration
 ** handler for functions and operators. This relation is called 'elab_builtin_handler'. 
 ** NOTE: These relations should only determine the type and properties of the builtin functions and
 ** operators and not evaluate them. Constant evaluation is performed by the 'Ceval' module.
 ** The module also contain a relation for deoverloading of operators, in the 'deoverload' relation.
 ** It transforms operators like '+' to its specific form, ADD, ADD_ARR, etc.
 **
 ** Interactive function calls are also given their types by 'elab_exp', which calls 
 ** 'elab_call_interactive'.
 **
 ** Elaboration for functions involve checking the types of the arguments by filling slots of the
 ** argument list with first positional and then named arguments to find a matching function. The 
 ** details of this mechanism can be found in the Modelica specification.
 ** The elaboration also contain function deoverloading which will be added to Modelica in the future.
 **)

module Static :

  with "absyn.rml"
  with "exp.rml"
  with "explode.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "interactive.rml"

  type Ident = string


  datatype Slot = SLOT of Types.FuncArg *  (* An argument to a function *)
			  bool *	   (* True if the slot has been filled, *)
					   (* i.e. argument has been given a value*)
			  Exp.Exp option   (* Contain the elaborated expression *)
                                           (* for the actual argument *)


  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp,bool,Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option)
  relation elab_graphics_exp : (Env.Env, Absyn.Exp) => (Exp.Exp,
							Types.Properties) 
	  (* Special relation for graphics annotations, because of inhomogenous *)
	  (* array of graphics primitives *) 
  relation elab_exp_list : (Env.Env, Absyn.Exp list,bool (* Implicit inst *)
			    , Interactive.InteractiveSymbolTable option) 
	    => (Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option)

  relation elab_exp_list_list : (Env.Env, Absyn.Exp list list, bool (* Implicit inst *)
				 , Interactive.InteractiveSymbolTable option) 
	  => (Exp.Exp list list, Types.Properties list list, Interactive.InteractiveSymbolTable option)

  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Types.Properties, SCode.Accessibility)
  relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	  => (Exp.Exp list, Types.Properties list, SCode.Accessibility list)
  relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool)
	  
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef

  relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list) 
					  => (Exp.Exp, Types.Properties)) 


  (* Property matching (type conversions etc.) *)

  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : (Absyn.Operator, Env.Env, Types.Type, Types.Type)
	  => (Exp.Operator * Types.Type list * Types.Type) list
	    
  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp
  relation component_ref_to_path: Exp.ComponentRef => Absyn.Path 
relation is_function_in_cflist : ((Absyn.Path * Types.Type) list, Absyn.Path) 
	  => bool
end

with "classinf.rml"
with "dump.rml"
with "print.rml"
with "system.rml"
with "lookup.rml"
with "debug.rml"
with "inst.rml"
with "codegen.rml"
with "modutil.rml"
with "dae.rml"
with "util.rml"
with "rtopts.rml"
with "parse.rml"
with "classloader.rml"
with "mod.rml"
with "prefix.rml"
with "ceval.rml"

(** LS:
 ** - Expression elaboration
 **)

relation elab_exp_list : (Env.Env, Absyn.Exp list, bool, Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option ) =

  axiom	elab_exp_list (_,[],impl,st) => ([],[],st)

  rule	elab_exp (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list (env, e::rest,impl,st) => (exp::exps, p::props,st'') 
end

relation elab_exp_list_list : (Env.Env, Absyn.Exp list list, bool
			       , Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list list, Types.Properties list list, Interactive.InteractiveSymbolTable option ) =

  axiom	elab_exp_list_list (_,[],impl,st) => ([],[],st)

  rule	elab_exp_list (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list_list (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list_list (env, e::rest,impl,st) => (exp::exps, p::props,st'') 
end

(** relation: ceval_if_constant
 ** This relation calls Ceval.ceval if the boolean parameter is true
 ** on the expression.
 **)
relation ceval_if_constant: (Exp.Exp,bool (* constant *),Env.Env) => Exp.Exp =

  axiom	ceval_if_constant(e,false,_) => e 
 
  rule	Ceval.ceval(env,e,false,NONE,NONE) => (v,_) &
	value_exp(v) => e'
	---------------------------------
	ceval_if_constant(e,true,env) => e'
end

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Types.Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

(* The types below should contain the default values of the attributes of the builtin
 * types. But since they are default, we can leave them out for now, unit="" is not 
* that interesting to find out.
*)
  axiom	elab_exp(_, Absyn.INTEGER(x),impl,st)
	  => (Exp.ICONST(x), Types.PROP((Types.T_INTEGER([]),NONE),true),st)
  axiom	elab_exp(_, Absyn.REAL(x),impl,st)
	  => (Exp.RCONST(x), Types.PROP((Types.T_REAL([]),NONE),   true),st)
  axiom	elab_exp(_, Absyn.STRING(x),impl,st)
	  => (Exp.SCONST(x), Types.PROP((Types.T_STRING([]),NONE), true),st)
  axiom	elab_exp(_, Absyn.BOOL(x),impl,st)
	  => (Exp.BCONST(x), Types.PROP((Types.T_BOOL([]),NONE),   true),st)

  axiom elab_exp(_,Absyn.END,impl,st)
	  => (Exp.END, Types.PROP((Types.T_INTEGER([]),NONE),true),st)


  rule	(*Debug.fprintln("setr", "elab_exp_cref") &*)
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr),impl,st) => (exp,prop,st) 

	(**  Binary and unary operations *)

  rule	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.BINARY(e1'',op',e2''),c) => exp' &
	ceval_if_constant(exp',c,env) => exp''
	---------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2),impl,st)
	  => (exp'',Types.PROP(rtype,c),st'')

  rule	(*Debug.fprintln("setr", "elab_exp_unary") &*)
	elab_exp (env,e,impl,st) => (e',Types.PROP(t,c),st') &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	replace_operator_with_fcall(Exp.UNARY(op',e''),c) => exp' &
	ceval_if_constant(exp',c,env) => exp''
	---------------------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e),impl, st)
	  => (exp'', Types.PROP(rtype,c),st')
	
  rule	(*Debug.fprintln("setr", "elab_exp_lbinary") &*)
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.LBINARY(e1'',op',e2''),c) => exp' &
	ceval_if_constant(exp',c,env) => exp''
	-----------------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2),impl,st)
	  => (exp'', Types.PROP(rtype,c),st'')

  rule	(*Debug.fprintln("setr", "elab_exp_lunary") &*)
	elab_exp (env,e,impl,st) => (e',Types.PROP(t,c),st') &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	replace_operator_with_fcall(Exp.LUNARY(op',e''),c) => exp' &
	ceval_if_constant(exp',c,env) => exp''
	----------------------------------------------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e),impl,st)
	  => (exp'',Types.PROP(rtype,c),st')

  rule	(*Debug.fprintln("setr", "elab_exp_relation") &*)
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') & 
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.RELATION(e1'',op',e2''),c) => exp' &
	ceval_if_constant(exp',c,env) => exp''
	-----------------------------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2),impl,st)
	  => (exp'', Types.PROP(rtype,c),st'')

	(**  Conditional expressions *)

  rule	(*Debug.fprintln("setr", "elab_exp_ifexp") &*)
	elab_exp (env,e1,impl,st) => (e1', prop1,st') &
	elab_exp (env,e2,impl,st') => (e2', prop2,st'') &
	elab_exp (env,e3,impl,st'') => (e3', prop3,st''') &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	(*TODO elseif part *)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3,_),impl,st) => (e,prop,st''')

	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)

  rule	Dump.print_component_ref_str fn => fnstr &
	(*Debug.fprintl("setr", ["elab_exp_call: ",fnstr,"\n"]) &*)
	elab_call(env,fn,args,nargs,impl,st) => (e,prop as Types.PROP(t,c),st') &
	ceval_if_constant(e,c,env) => e'
	--------------------------------------
	elab_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs)),impl,st) 
		=> (e',prop,st')


	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	(*Debug.fprintln("setr", "elab_exp_tuple") &
	Debug.print "\n#####################elab_exp tuple.####################" &*)
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
(*	Debug.print "\nThe elaborated tuple." &*)
	split_props(props) => (types, consts) 
(*	& Debug.print "\n split_props was just executed."*)
	-------------------------------------
	elab_exp (env,Absyn.TUPLE(e as e1::rest),impl,st) 
	  => (Exp.TUPLE(e'),Types.PROP_TUPLE((Types.T_TUPLE(types),NONE), Types.TUPLE_CONST(consts)),st)


	(**  Array-related expressions *)

	(** Elab reduction expressions, including array() constructor **)

  rule	elab_call_reduction(env,fn,exp,id,iterexp,impl,st) => (e,prop,st') 
	-------------------------------------------------------------------
	elab_exp (env,Absyn.CALL(fn,Absyn.FOR_ITER_FARG(exp,id,iterexp)),impl,st) 
	  => (e,prop,st')


  rule	(*Debug.fprintln("setr", "elab_exp_range1") &*)
	elab_exp (env, start,impl,st) => (start', Types.PROP(start_t, c_start),st') &
	elab_exp (env, stop,impl,st') => (stop', Types.PROP(stop_t, c_stop),st'') &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop),impl,st)
	  => (Exp.RANGE(rt,start',NONE,stop'), Types.PROP(t, const),st'')

  rule	(*Debug.fprintln("setr", "elab_exp_range2") &*)
	elab_exp (env,start,impl,st) => (start', Types.PROP(start_t, c_start),st') &
	elab_exp (env,step,impl,st') => (step', Types.PROP(step_t, c_step),st'') &
	elab_exp (env,stop,impl,st'') => (stop', Types.PROP(stop_t, c_stop),st''') &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop),impl,st)
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), Types.PROP(t, const),st''')

  rule	(*Debug.fprintln("setr", "elab_exp_array") &*)
	elab_array (env, es,impl,st) => (es', Types.PROP(t, const)) & list_length es' => l&
	Types.elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es),impl,st)
	  => (Exp.ARRAY(at,a,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(l)), t),NONE),
		   const),st)
	
  rule	(*Debug.fprintln("setr", "elab_exp_matrix") &*)
	elab_exp_list_list(env,es,impl,st) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	(*Debug.fprintln("setr", "calculated havereal\n") &*)
	elab_matrix_semi (env,es,impl,st,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	Types.elab_type t => at
	------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es),impl,st)
	  => (Exp.MATRIX(at,nmax,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 (Types.T_ARRAY(Types.DIM(SOME(dim2)), t),NONE)),NONE),
		   c),st)

  rule	elab_code_type(env,c) => tp &
	Types.elab_type tp => tp'
	-------------------
	elab_exp (env, Absyn.CODE(c),impl,st) =>  (Exp.CODE(c,tp'),Types.PROP(tp,true),st)

  rule	Debug.fprint("failtrace", "- elab_exp failed: ") & 
	Debug.fcall("failtrace", Dump.print_exp, e) & 
	Debug.fprint("failtrace", "\n") 
	-----------------------------------------------------------
	elab_exp(_,e,_,_) => fail


end

(** relation: add_for_loop_scope_const 
 ** Creates a new scope on the environment used for loops and adds a loop variable 
 ** which is named by the second argument. The variable is given the value 1 (one) such that
 ** elaboration of expressions of containing the loop variable become constant.
 **)
relation add_for_loop_scope_const : (Env.Env, Ident, Types.Type) => Env.Env =

  rule	Env.open_scope (env,false,SOME("$for loop scope$")) => env' &
	Env.extend_frame_v(env',
			   Types.VAR(i,
				     Types.ATTR(false,
						SCode.RW,
						SCode.PARAM,
						Absyn.BIDIR),
				     false,
				     typ, 
				     Types.VALBOUND(Values.INTEGER(1))),NONE,false
			   ) => env''
	--------------------------------------------------------------------------
	add_for_loop_scope_const(env,i,typ) => env''

end


(** relation: elab_call_reduction
 * 
 * This relation elaborates reduction expressions, that look like function
 * calls. For example an array constructor.
 *)
relation elab_call_reduction : (Env.Env, Absyn.ComponentRef, Absyn.Exp,
				Ident, Absyn.Exp, bool,
				Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =


  rule	elab_exp (env,iterexp,impl,st)
	  => (iterexp', 
	      Types.PROP((Types.T_ARRAY(arraydim as Types.DIM(_), iterty),_),
			 iterconst),
	      _) &
	add_for_loop_scope_const(env,iter,iterty) => env' &
	(** const so that expr is elaborated to const **)
	elab_exp (env', exp, impl, st) => (exp', Types.PROP(expty, expconst), st) &
	bool_and (expconst, iterconst) => const &
	let prop = Types.PROP((Types.T_ARRAY(arraydim, expty),NONE), const) &
	Absyn.cref_to_path fn => fn'
	---------------------------------------------------
	elab_call_reduction (env,fn,exp,iter,iterexp,impl,st) 
	  => (Exp.REDUCTION (fn',exp',iter,iterexp'), prop, st)

end


(* HL bort
relation elab_exp_dim : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option,int)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

  axiom elab_exp_dim(_,Absyn.END,impl,st,dim)
	  => (Exp.ICONST(dim), Types.PROP((Types.T_INTEGER([]),NONE),true),st)

end
*)
(** relation: replace_operator_with_fcall
 ** Replaces a userdefined operator expression with a corresponding function call expression.
 ** Other expressions just passes through.
**)
relation replace_operator_with_fcall: (Exp.Exp,bool (*builtin*)) => Exp.Exp =

  axiom	replace_operator_with_fcall(Exp.BINARY(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,c))
	  
  axiom	replace_operator_with_fcall(Exp.UNARY(Exp.USERDEFINED(funcname),e1),c) 
	  => (Exp.CALL(funcname,[e1],false,c))

  axiom	replace_operator_with_fcall(Exp.LBINARY(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,c))

  axiom	replace_operator_with_fcall(Exp.LUNARY(Exp.USERDEFINED(funcname),e1),c) 
	  => (Exp.CALL(funcname,[e1],false,c))

  axiom	replace_operator_with_fcall(Exp.RELATION(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,c))
	  
  axiom	replace_operator_with_fcall(e,_) => e
end

(** relation: elab_code_type
 ** This relation will construct the correct type for the given Code expression.
 ** The types are built-in classes of different types. E.g. the class TypeName is the type
 ** of Code expressions corresponding to a type name Code expression. 
**)
relation elab_code_type: (Env.Env, Absyn.Code) => Types.Type =

  axiom	elab_code_type(env, Absyn.C_TYPENAME(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_VARIABLENAME(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("VariableName"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_EQUATIONSECTION(_,_))
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("EquationSection"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_ALGORITHMSECTION(_,_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("AlgorithmSection"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_ELEMENT(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("Element"),[]),NONE))
	  
  axiom	elab_code_type(env, Absyn.C_EXPRESSION(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("Expression"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_MODIFICATION(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("Modification"),[]),NONE))

end

relation elab_graphics_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Types.Properties) =

  axiom	elab_graphics_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), Types.PROP((Types.T_INTEGER([]),NONE),true))
  axiom	elab_graphics_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), Types.PROP((Types.T_REAL([]),NONE),   true))
  axiom	elab_graphics_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), Types.PROP((Types.T_STRING([]),NONE), true))
  axiom	elab_graphics_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), Types.PROP((Types.T_BOOL([]),NONE),   true))

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_cref") &*)
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_graphics_exp(env, Absyn.CREF(cr)) => (exp,prop) 

	(**  Binary and unary operations *)

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_binary") &*)
	elab_graphics_exp (env,e1) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2) => (e2', Types.PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),Types.PROP(rtype,c))

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_unary") &*)
	elab_graphics_exp (env,e) => (e',Types.PROP(t,c)) &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),Types.PROP(rtype,c))
	
  rule	(*Debug.fprintln("setr", "elab_graphics_exp_lbinary") &*)
	elab_graphics_exp (env,e1) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2) => (e2', Types.PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),Types.PROP(rtype,c))

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_lunary") &*)
	elab_graphics_exp (env,e) => (e',Types.PROP(t,c)) &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),Types.PROP(rtype,c))

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_relation") &*)
	
	elab_graphics_exp (env,e1) => (e1', Types.PROP(t1, c1)) &
	
	elab_graphics_exp (env,e2) => (e2', Types.PROP(t2, c2)) &
	
	bool_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_graphics_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),Types.PROP(rtype,c))

	(**  Conditional expressions *)

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_ifexp") &*)
	elab_graphics_exp (env,e1) => (e1', prop1) &
	elab_graphics_exp (env,e2) => (e2', prop2) &
	elab_graphics_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	(* TODO elseif part*)
	------------------------------------------------------
	elab_graphics_exp (env,Absyn.IFEXP(e1,e2,e3,_)) => (e,prop)

	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)

  rule	Dump.print_component_ref_str fn => fnstr &
	(*Debug.fprintl("setr", ["elab_graphics_exp_call: ",fnstr,"\n"]) &*)
	elab_call(env,fn,args,nargs,true,NONE) => (e,prop,_) 
	--------------------------------------
	elab_graphics_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs))) 
		=> (e,prop)

	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	(*Debug.fprintln("setr", "elab_graphics_exp_tuple") &
	Debug.print "\n#####################elab_graphics_exp tuple.####################" &*)
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
(*	Debug.print "\nThe elaborated tuple." &*)
	split_props(props) => (types, consts) 
(*	Debug.print "\n split_props was just executed."*)
	-------------------------------------
	elab_graphics_exp (env,Absyn.TUPLE(e as e1::rest)) 
	  => (Exp.TUPLE(e'),Types.PROP_TUPLE((Types.T_TUPLE(types),NONE), Types.TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_range1") &*)
	elab_graphics_exp (env, start) => (start', Types.PROP(start_t, c_start)) &
	elab_graphics_exp (env, stop) => (stop', Types.PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt) => t
	--------------------------------------------------
	elab_graphics_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(rt,start',NONE,stop'), Types.PROP(t, const))

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_range2") &*)
	elab_graphics_exp (env, start) => (start', Types.PROP(start_t, c_start)) &
	elab_graphics_exp (env, step) => (step', Types.PROP(step_t, c_step)) &
	elab_graphics_exp (env, stop) => (stop', Types.PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt) => t
	---------------------
	elab_graphics_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), Types.PROP(t, const))


	  (** FIXME: what is a below? Why true if is array? **)
  rule	(*Debug.fprintln("setr", "elab_graphics_exp_array") &*)
	elab_graphics_array (env, es) => (es', Types.PROP(t, const)) & list_length es' => l&
(*	Ceval.ceval_list(env,es',false,NONE) => vl &
	Util.list_map(vl, value_exp) => es'' &*)
	Types.elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_graphics_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(at,a,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(l)), t),NONE),
		   const))
	
  rule	(*Debug.fprintln("setr", "elab_graphics_exp_matrix") &*)
	elab_exp_list_list(env,es,false,NONE) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	elab_matrix_semi (env,es,false,NONE,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	Types.elab_type t => at
	------------------------------------------------------------
	elab_graphics_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(at,nmax,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 (Types.T_ARRAY(Types.DIM(SOME(dim2)), t),NONE)),NONE),
		   c))

  rule	Print.print_buf "- elab_graphics_exp failed: " & Dump.print_exp e & Print.print_buf "\n"
	-----------------------------------------------------------
	elab_graphics_exp(_,e) => fail

end

relation deoverload_range : ((Exp.Exp*Types.Type), 
			     (Exp.Exp*Types.Type) option,
			     (Exp.Exp*Types.Type)) 
	  => (Exp.Exp, Exp.Exp option, Exp.Exp, Exp.Type) =
	  
  axiom	deoverload_range((e1,(Types.T_INTEGER(_),_)),
			 NONE,
			 (e3,(Types.T_INTEGER(_),_))) => (e1,NONE,e3,Exp.INT)
  axiom	deoverload_range((e1,(Types.T_INTEGER(_),_)),
			 SOME((e2,(Types.T_INTEGER(_),_))),
			 (e3,(Types.T_INTEGER(_),_)))  => (e1,SOME(e2),e3,Exp.INT)

  rule	elab_arglist([(Types.T_REAL([]),NONE),(Types.T_REAL([]),NONE)],
		     [(e1,t1),(e3,t3)]) => ([e1',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),NONE,(e3,t3)) => (e1',NONE,e3',Exp.REAL)

  rule	elab_arglist([(Types.T_REAL([]),NONE),(Types.T_REAL([]),NONE),(Types.T_REAL([]),NONE)],
		     [(e1,t1),(e2,t2),(e3,t3)]) => ([e1',e2',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),SOME((e2,t2)),(e3,t3)) 
	  => (e1',SOME(e2'),e3',Exp.REAL)

end
(** relation: elab_range_type *)

relation elab_range_type : (Env.Env, Exp.Exp,
			    Exp.Exp option, Exp.Exp, bool,Exp.Type) => Types.Type =

  rule	Ceval.ceval (env,start,false,NONE,NONE) => (Values.INTEGER(startv),_) &
	Ceval.ceval (env,stop,false,NONE,NONE) => (Values.INTEGER(stopv),_) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true,_)
	  => ((Types.T_ARRAY(Types.DIM(SOME(n')), (Types.T_INTEGER([]),NONE)),NONE))

  rule	Ceval.ceval (env,start,false,NONE,NONE) => (Values.INTEGER(startv),_) &
	Ceval.ceval (env,step,false,NONE,NONE) => (Values.INTEGER(stepv),_) &
	Ceval.ceval (env,stop,false,NONE,NONE) => (Values.INTEGER(stopv),_) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true,_)
	  => ((Types.T_ARRAY(Types.DIM(SOME(n'')), (Types.T_INTEGER([]),NONE)),NONE))

  rule	Ceval.ceval (env,start,false,NONE,NONE) => (Values.REAL(startv),_) &
	Ceval.ceval (env,stop,false,NONE,NONE) => (Values.REAL(stopv),_) &
	real_sub (stopv,startv) => n &
	real_floor n => n'' &
	real_int n'' => n''' &
	int_add (n''',1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true,_)
	  => ((Types.T_ARRAY(Types.DIM(SOME(n')), (Types.T_REAL([]),NONE)),NONE))

  rule	Ceval.ceval (env,start,false,NONE,NONE) => (Values.REAL(startv),_) &
	Ceval.ceval (env,step,false,NONE,NONE) => (Values.REAL(stepv),_) &
	Ceval.ceval (env,stop,false,NONE,NONE) => (Values.REAL(stopv),_) &
	real_sub (stopv,startv) => n &
	real_div (n,stepv) => n' &
	real_floor n' => n''' &
	real_int n''' => n'''' &
 	int_add (n'''',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true,_)
	  => ((Types.T_ARRAY(Types.DIM(SOME(n'')), (Types.T_REAL([]),NONE)),NONE))

  axiom	elab_range_type (_,_,_,_,false,Exp.INT)
	  => ((Types.T_ARRAY(Types.DIM(NONE), (Types.T_INTEGER([]),NONE)),NONE))

  axiom	elab_range_type (_,_,_,_,false,Exp.REAL)
	  => ((Types.T_ARRAY(Types.DIM(NONE), (Types.T_REAL([]),NONE)),NONE))

end

relation elab_tuple : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Types.Properties list) =

  rule	(*Debug.print "\nEntered elab_tuple." &*)
	elab_exp (env,e,false,NONE) => (e',p,_) &
(*	Debug.print "\nElaborated expression." &*)
	elab_tuple(env,exps) => (exps',props) 
(*	Debug.print "\nThe last element was just elaborated."*)
	-----------------------------
	elab_tuple(env,e::exps) => (e'::exps', p::props) 

(*PR.  rule	elab_exp (env,e) => (e',p) 
	-----------------------------
	elab_tuple(env,e::[]) => (e', p) 
*)
  rule 	(*Debug.print "elaborating last element."*)
	----------------
	elab_tuple(env,[]) => ([], []) 

(*  axiom elab_tuple(env,[]) => ([], []) 
*)
end


(** relation: elab_array *)

relation elab_array : (Env.Env, Absyn.Exp list,bool,Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties) =

  rule	elab_exp (env,e,impl,st) => (e',prop,_)
	-----------------------------
	elab_array (env,[e],impl,st) => ([e'],prop)

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t1,c1),_) &
	elab_array (env,es,impl,st) => (es',Types.PROP(t2,c2)) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es,impl,st) => (e'::es',Types.PROP(t1,c))

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t1,c1),_) &
	elab_array (env,es,impl,st) => (es',Types.PROP(t2,c2)) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in array expression\n" &
	Print.print_buf "  " & Dump.print_exp e & Print.print_buf " is of type " &
 	Types.print_type t1 & Print.print_buf "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	Print.print_buf "] are of type " & Types.print_type t2 & Print.print_buf "\n"
	---------------------------------------------------------
	elab_array (env,e::es,impl,st) => fail

  rule	Print.print_buf "- elab_array failed\n"
	-----------------------------
	elab_array (_,_,_,_) => fail

end

relation elab_graphics_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Types.Properties) =

  rule	elab_graphics_exp (env,e) => (e',prop)
	-----------------------------
	elab_graphics_array (env,[e]) => ([e'],prop)

  rule	elab_graphics_exp (env,e) => (e',Types.PROP(t1,c1)) &
	elab_graphics_array (env,es) => (es',Types.PROP(t2,c2)) &
	bool_and (c1,c2) => c
	---------------------------------
	elab_graphics_array (env,e::es) => (e'::es',Types.PROP(t1,c))

  rule	Print.print_buf "- elab_graphics_array failed\n"
	-----------------------------
	elab_graphics_array (_,_) => fail

end

relation elab_matrix_comma : (Env.Env, Absyn.Exp list, bool(*implicit inst.*)
			      , Interactive.InteractiveSymbolTable option, bool (*have real*))
	=> ((Exp.Exp*bool) list, Types.Properties, int, int) =


  rule	elab_exp (env,el,impl,st) => (el', Types.PROP(t,c),_) &
	Types.ndims t => ndims &
	int_max(2,ndims) => maxn &
	int_gt(ndims,0) => array
	----------------------------------------
	elab_matrix_comma (env,[el],impl,st,havereal) => ([(el',array)],Types.PROP(t,c),1,maxn)


  rule	elab_exp (env,el,impl,st) => (el', Types.PROP(t1,c1),_) &
	elab_matrix_comma(env,els,impl,st,havereal) => (els', Types.PROP(t2,c2), _,maxn2) &

	Types.match_with_promote(Types.PROP(t1,c1),Types.PROP(t2,c2),havereal) => props &

	list_length el::els => dim &

	Types.ndims t1 => maxn1 &
	int_max (maxn1,maxn2) => maxn &
	int_gt(maxn1,0) => array
	-------------------------------------
	elab_matrix_comma (env,el::els,impl,st,havereal) 
	  => ((el',array)::els',props,dim,maxn)
	  
  rule	(*Debug.fprint("failtrace","- elab_matrix_comma failed\n")*)
	-------------------------------------
	elab_matrix_comma (_,_,_,_,_) => fail
end

(** relation: elab_matrix_semi *)

relation elab_matrix_semi : (Env.Env, Absyn.Exp list list, bool(*implicit inst.*), Interactive.InteractiveSymbolTable option, bool(*contain real*))
	=> ((Exp.Exp*bool) list list, Types.Properties, int, int, int) =
	  

  rule	elab_matrix_comma(env,el,impl,st,havereal) => (el', props, dim, maxn)
	---------------------------------
	elab_matrix_semi(env,[el],impl,st,havereal) => ([el'], props, 1, dim, maxn)

  rule	list_length(el) => dim &
	elab_matrix_comma(env,el,impl,st,havereal) => (el',props1,dim1,maxn1) &
	elab_matrix_semi(env,els,impl,st,havereal) => (els',props2,_,dim2,maxn2) &

	dim1 = dim2 &
			
	Types.match_with_promote(props1,props2,havereal) => props &

	int_max(maxn1,maxn2) => maxn
	--------------------
	elab_matrix_semi(env,el::els,impl,st,havereal) => (el'::els',props,dim,dim1,maxn)

  rule	(*Debug.fprint("failtrace", "- elab_matrix_semi failed\n" )*)
	-------------------
	elab_matrix_semi(_,_,_,_,_) => fail

	(**  Error messages *)
(*
  rule	Print.print_buf "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix_semi(_,[]) => fail

  rule	elab_array(env,el) => (el',Types.PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in matrix rows\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix is of " &
	Types.print_type t2 & Print.print_buf "\n"
	--------------------------------
	elab_matrix_semi(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	Print.print_buf "# Incompatible row length in matrix expression\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of size " &
	int_string dim1 => s & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix rows are of size " &
	int_string dim2 => s & Print.print_buf s & Print.print_buf "\n"
	--------------------------------------------
	elab_matrix_semi(env,el::els) => fail
*)
end


relation elab_builtin_size : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule	(** size(A,x) that returns size of x:th dimension *)
  	elab_exp(env,dim,false,NONE) => (dimp,Types.PROP(_,c1),_) &
	elab_exp(env,arraycr,false,NONE) => (arraycrefe,Types.PROP(arrtp,_),_) &
	Types.dimensions_known(arrtp) => c2 &
	bool_and(c1,c2) => c &
	let exp = Exp.SIZE(arraycrefe,SOME(dimp))
	---------------------------------------------------------------
	elab_builtin_size (env, [arraycr,dim]) => (exp,Types.PROP((Types.T_INTEGER([]),NONE),c))

  rule	(* size(A) *)
	elab_exp(env,arraycr,false,NONE) => (arraycrefe,Types.PROP(arrtp,_),_) &
	Types.dimensions_known(arrtp) => c &
	let exp = Exp.SIZE(arraycrefe,NONE)
	---------------------------------------------------------------
	elab_builtin_size (env, [arraycr]) 
	  => (exp,Types.PROP((Types.T_ARRAY(Types.DIM(SOME(1)),(Types.T_INTEGER([]),NONE)),NONE),c))


  rule	(*Debug.fprint("failtrace", "- elab_builtin_size failed\n")*)
	----------------------------------------------------------
	elab_builtin_size (env,expl) => fail
end


relation elab_builtin_fill : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties)	=

  rule	elab_exp (env,s,false,NONE) => (s', Types.PROP(sty, sconst),_) &
	elab_exp_list (env,dims,false,NONE) => (dims', dimprops,_) &
	Ceval.ceval_list (env, dims',false,NONE) => dimvals &
	elab_builtin_fill_2 (env, s', sty, dimvals) => (exp, prop) 
	--------------------------------------------------
	elab_builtin_fill (env, s::dims) => (exp, prop)

  rule	print"#-- elab_builtin_fill: Couldn't elaborate fill()\n"
	---------------------------------------------------------
	elab_builtin_fill (_,_) => fail

end


relation elab_builtin_fill_2 : (Env.Env, Exp.Exp, Types.Type, Values.Value list) 
	  => (Exp.Exp, Types.Properties) =

  rule	build_exp_list (s, v) => arraylist &
	int_string v => dimension & Debug.fprint("failtrace", " 1 elab_builtin_fill_2 dimension: ") & Debug.fprint("failtrace", dimension) & Debug.fprint("failtrace", "\n") &
	Types.elab_type sty => at &
	Types.is_array sty => a
	----------------------------------
	elab_builtin_fill_2 (env, s, sty, [Values.INTEGER(v)])
	  => (Exp.ARRAY(at,a,arraylist), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(v)), sty),NONE), true))
			     
  rule	elab_builtin_fill_2 (env, s, sty, rest) 
	  => (exp, Types.PROP(ty,con)) &
        build_exp_list (exp, v) => arraylist &
	int_string v => dimension & Debug.fprint("failtrace", " 2 elab_builtin_fill_2 dimension: ") & Debug.fprint("failtrace", dimension) & Debug.fprint("failtrace", "\n") &
	Types.elab_type ty => at &
	Types.is_array ty => a
	----------------------------------------------------------
	elab_builtin_fill_2 (env, s, sty, Values.INTEGER(v)::rest) 
	  => (Exp.ARRAY(at,a,arraylist), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(v)), ty),NONE), true))
	
  rule	Print.print_buf "#-- elab_builtin_fill_2: Failed to elaborate fill()\n"
	-------------------------------------------------------------
	elab_builtin_fill_2 (_,_,_,_) => fail

end

relation elab_builtin_transpose : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,matexp,false,NONE) => (matexp', Types.PROP(matty, true),_) &
	elab_builtin_transpose_2(env,matexp',matty) => (exp,prop)
	------------------------------------------------------
	elab_builtin_transpose (env, [matexp]) => (exp, prop)

  rule	elab_exp (env,matexp,false,NONE) 
	  => (exp', Types.PROP((Types.T_ARRAY(d1,(Types.T_ARRAY(d2,eltp),_)),_),_),_) &
	let newtp = ((Types.T_ARRAY(d2,(Types.T_ARRAY(d1,eltp),NONE)),NONE)) &
	let exp = Exp.CALL(Absyn.IDENT("transpose"),
			   [exp'],false,true) &
	let prop = Types.PROP(newtp,false)
	------------------------------------
	elab_builtin_transpose (env, [matexp]) => (exp, prop)
end

relation elab_builtin_transpose_2 : (Env.Env, Exp.Exp, Types.Type) => 
	(Exp.Exp, Types.Properties) =

  rule	print "- elab_builtin_transpose_2 not implemented yet\n" &
	Print.print_buf "- elab_builtin_transpose_2 not implemented yet\n" 
	------------------------
	elab_builtin_transpose_2(env, exp, tp) => fail
end

relation build_exp_list : (Exp.Exp, int) => Exp.Exp list =

  axiom	build_exp_list(e,0) => []
  axiom	build_exp_list (e,1) => [e]

  rule	int_sub (c,1) => c' &
	build_exp_list (e, c') => rest
	------------------------------
	build_exp_list (e, c) => e::rest

end

relation elab_builtin_sum : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  rule	(* For constant expressions *)
	elab_exp(env,arrexp,false,NONE) 
	      => (exp',Types.PROP((Types.T_ARRAY(dim,tp),_),c as true),_) &
	Ceval.ceval(env, exp',false,NONE,NONE) => (Values.ARRAY(vals),_) &
	Values.sum_arrayelt(vals) => value &
	value_exp value => exp''
	----------------------
	elab_builtin_sum(env,[arrexp]) => (exp'', Types.PROP(tp,c))

  rule	(* For non-constant expressions *)
	elab_exp(env,arrexp,false,NONE) 
	      => (exp',Types.PROP((Types.T_ARRAY(dim,tp),_),c as false),_) &
	let exp'' = Exp.CALL(Absyn.IDENT("sum"),
			   [exp'],false,true)
	---------------------------------------
	elab_builtin_sum(env,[arrexp]) => (exp'', Types.PROP(tp,c))
end

relation elab_builtin_pre : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp(env,exp,false,NONE) => (exp',Types.PROP(tp,c),_) &
	Types.basic_type(tp) => true &
	let exp'' = Exp.CALL(Absyn.IDENT("pre"),
			   [exp'],false,true)
	------------------------------------
	elab_builtin_pre(env,[exp]) => (exp'', Types.PROP(tp,c))

  rule	elab_exp(env,exp,false,NONE) => (exp,Types.PROP(tp,c),_) &
	Types.basic_type(tp) => false &
	Print.print_buf "#Error, operand of pre must be of built-in type.\n"
	------------------------------------
	elab_builtin_pre(env,[exp]) => fail

  rule	Print.print_buf "#Error, wrong type or wrong number of arguments to pre operator.\n"
	------------------------------------
	elab_builtin_pre(env,_) => fail
end

relation elab_builtin_initial : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_builtin_initial(env,[]) 
	  => (Exp.CALL(Absyn.IDENT("initial"),
			   [],false,true), Types.PROP((Types.T_BOOL([]),NONE),false))

  rule	Print.print_buf "#Error, initial takes no arguments.\n"
	------------------
	elab_builtin_initial(env,_) => fail
end

relation elab_builtin_terminal : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_builtin_terminal(env,[]) 
	  => (Exp.CALL(Absyn.IDENT("terminal"),
			   [],false,true), Types.PROP((Types.T_BOOL([]),NONE),false))

  rule	Print.print_buf "#Error, terminal takes no arguments.\n"
	------------------
	elab_builtin_terminal(env,_) => fail

end


relation elab_builtin_array : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp, Types.Properties) =
  rule	elab_exp_list(env, expl, false, NONE) 
	  => (exp', typel, _) &
	elab_builtin_array2 (exp',  typel) => (exp'', Types.PROP(tp,c)) &  
	list_length(expl) => len &
	let newtp = ((Types.T_ARRAY(Types.DIM(SOME(len)),tp),NONE)) &
	Types.elab_type(newtp) => newtp' &
	let exp = Exp.ARRAY(newtp',c,exp') 
	---------------------------------
	elab_builtin_array(env,expl) => (exp, Types.PROP(newtp,c))
end

(* Asserts that all types are of same dimensionality and of same builtin types *)
relation elab_builtin_array2: (Exp.Exp list, Types.Properties list)
	=> (Exp.Exp list, Types.Properties) =

  rule	same_dimensions(tpl) => false &
	Print.print_buf "#Error, different dimension sizes in arguments to array.\n"
	------------------------
	elab_builtin_array2(expl,tpl) => fail

  rule	(* If first elt is Integer but arguments contain Real, convert all to Real *)
	Util.list_map(tpl,Types.get_prop_type) => tpl' &
	Types.contain_real(tpl') => true &
	elab_builtin_array3(expl,tpl,Types.PROP((Types.T_REAL([]),NONE),false)) 
	      => (expl', tp)
	-------------------------------------------
	elab_builtin_array2(expl,tpl) => (expl', tp)
	
  rule	elab_builtin_array3(expl,tpl,tp) => (expl',tp)
	---------------------------
	elab_builtin_array2(expl,tpl as (tp::_)) => (expl', tp)
end

relation elab_builtin_array3: (Exp.Exp list, Types.Properties list, Types.Properties)
	=> (Exp.Exp list, Types.Properties) =
  axiom	elab_builtin_array3([],[],tp) => ([],tp)

  rule	Types.match_prop(e1,t1,tp) => e1' &
	elab_builtin_array3(expl,tpl,tp) => (expl',_)
	----------------------------------------
	elab_builtin_array3(e1::expl,t1::tpl,tp) => (e1'::expl', t1)
end

relation elab_builtin_zeros : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(0)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_zeros (env, args) => (e,p)
end

relation same_dimensions: (Types.Properties list ) => bool =

  rule	Util.list_map(tpl,Types.get_prop_type) => tpl' &
	Util.list_map(tpl',Types.get_dimension_sizes) => dimsizes &
	same_dimensions2(dimsizes) => res
	--------------------------------
	same_dimensions(tpl) => res
end

relation same_dimensions2:( int list list) => bool =

  rule	Util.list_flatten(l) => []
	------------------
	same_dimensions2(l) => true
	
  rule	Util.list_map(l,Util.list_first) => elts &
	Util.list_map(l,Util.list_rest) => restelts &
	same_dimensions3(elts) => true &
	same_dimensions2(restelts) => true
	----------------------------------
	same_dimensions2(l) => true
  axiom	same_dimensions2(_) => false
end
			
relation same_dimensions3: (int list) => bool =

  axiom same_dimensions3([]) => true
  axiom	same_dimensions3([_]) => true

  rule	int_eq(i1,i2) => res 
	--------------------
	same_dimensions3([i1,i2]) => res

  rule	same_dimensions3(i2::rest) => res &
	int_eq(i1,i2) => res2 &
	bool_and(res,res2) => res'
	--------------------------
	same_dimensions3(i1::i2::rest) => res'

  axiom	same_dimensions3(_) => false
end

relation elab_builtin_ones : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(1)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_ones (env, args) => (e,p)
end

relation elab_builtin_max : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,arrexp',false,NONE,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_max_2 (Values.ARRAY(vals)) => (Values.INTEGER(i),ty)
	-------------------------------------------------------
	elab_builtin_max(env, [arrexp]) => (Exp.ICONST(i),Types.PROP(ty,true))

  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,arrexp',false,NONE,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_max_2 (Values.ARRAY(vals)) => (Values.REAL(r),ty)
	-------------------------------------------------------
	elab_builtin_max(env, [arrexp]) => (Exp.RCONST(r),Types.PROP(ty,true))

	(* max(x,y) where x & y are scalars *)
  rule	elab_exp (env,s1,false,NONE) 
	  => (s1', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,s1',false,NONE,NONE) => (Values.INTEGER(i1),_) &
	elab_exp (env,s2,false,NONE) 
	  => (s2', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,s2',false,NONE,NONE) => (Values.INTEGER(i2),_) &
	int_max(i1,i2) => res
	-------------------------------------------------------
	elab_builtin_max(env, [s1, s2]) 
	  => (Exp.ICONST(res),Types.PROP((Types.T_INTEGER([]),NONE),true))

  rule	elab_exp (env,s1,false,NONE) 
	  => (s1', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,s1',false,NONE,NONE) => (Values.REAL(r1),_) &
	elab_exp (env,s2,false,NONE) 
	  => (s2', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,s2',false,NONE,NONE) => (Values.REAL(r2),_) &
	real_max(r1,r2) => res
	-------------------------------------------------------
	elab_builtin_max(env, [s1, s2]) 
	  => (Exp.RCONST(res),Types.PROP((Types.T_REAL([]),NONE),true))
end

relation elab_builtin_max_2 : (Values.Value) => (Values.Value, Types.Type) =

  rule	elab_builtin_max_2(v1)
	      => (Values.INTEGER(i1),(Types.T_INTEGER(_),_)) &
      elab_builtin_max_2(Values.ARRAY(vls)) 
	      => (Values.INTEGER(i2),(Types.T_INTEGER(_),_)) &
	int_max(i1,i2) => res
	---------------------
	elab_builtin_max_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res),(Types.T_INTEGER([]),NONE))

  rule	elab_builtin_max_2(v1) => (Values.REAL(i1),(Types.T_REAL(_),_)) &
	elab_builtin_max_2(Values.ARRAY(vls)) => (Values.REAL(i2),(Types.T_REAL(_),_)) &
	real_max(i1,i2) => res
	---------------------
	elab_builtin_max_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.REAL(res),(Types.T_REAL([]),NONE))

  rule	elab_builtin_max_2(vl) => (v,t)
	------------------
	elab_builtin_max_2(Values.ARRAY([vl]))
	  => (v,t)

  axiom	elab_builtin_max_2(Values.INTEGER(i))
	  => (Values.INTEGER(i),(Types.T_INTEGER([]),NONE))

  axiom	elab_builtin_max_2(Values.REAL(i))
	  => (Values.REAL(i),(Types.T_REAL([]),NONE))
end

relation elab_builtin_min : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,arrexp',false,NONE,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_min_2 (Values.ARRAY(vals)) => (Values.INTEGER(i),ty)
	-------------------------------------------------------
	elab_builtin_min(env, [arrexp]) => (Exp.ICONST(i),Types.PROP(ty,true))

  rule	elab_exp (env,arrexp,false,NONE) 
	  => (arrexp', Types.PROP(arrty, arrconst),_) &
	Ceval.ceval(env,arrexp',false,NONE,NONE) => (Values.ARRAY(vals),_) &
	elab_builtin_min_2 (Values.ARRAY(vals)) => (Values.REAL(r),ty)
	-------------------------------------------------------
	elab_builtin_min(env, [arrexp]) => (Exp.RCONST(r),Types.PROP(ty,true))
end

relation elab_builtin_min_2 : (Values.Value) => (Values.Value, Types.Type) =

  rule	elab_builtin_min_2(v1) => (Values.INTEGER(i1),(Types.T_INTEGER(_),_)) &
	elab_builtin_min_2(Values.ARRAY(vls)) 
	  => (Values.INTEGER(i2),(Types.T_INTEGER(_),_)) &
	int_min(i1,i2) => res
	---------------------
	elab_builtin_min_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res),(Types.T_INTEGER([]),NONE))

  rule	elab_builtin_min_2(v1) => (Values.REAL(i1),(Types.T_REAL(_),_)) &
	elab_builtin_min_2(Values.ARRAY(vls)) => (Values.REAL(i2),(Types.T_REAL(_),_)) &
	real_min(i1,i2) => res
	---------------------
	elab_builtin_min_2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.REAL(res),(Types.T_REAL([]),NONE))

  rule	elab_builtin_min_2(vl) => (v,t)
	------------------
	elab_builtin_min_2(Values.ARRAY([vl]))
	  => (v,t)

  axiom	elab_builtin_min_2(Values.INTEGER(i))
	  => (Values.INTEGER(i),(Types.T_INTEGER([]),NONE))

  axiom	elab_builtin_min_2(Values.REAL(i))
	  => (Values.REAL(i),(Types.T_REAL([]),NONE))
end

relation elab_builtin_floor : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule (*print "# floor function not implemented yet\n" &*)
      elab_exp (env,s1,false,NONE) 
	   => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
     --------------------------------------
     elab_builtin_floor(env,[s1]) 
        => (Exp.CALL(Absyn.IDENT("floor"),[s1'],false,false),
            Types.PROP((Types.T_REAL([]),NONE),c))
end

relation elab_builtin_ceil : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
        
  rule (**print "# ceil function not implemented yet\n" &**)
        elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_ceil(env,[s1]) 
          => (Exp.CALL(Absyn.IDENT("ceil"),[s1'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))
end

relation elab_builtin_abs : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,s1,false,NONE) 
	  => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
	  --------------------------------------
	elab_builtin_abs(env,[s1]) 
          => (Exp.CALL(Absyn.IDENT("abs"),[s1'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))
	
  rule	elab_exp (env,s1,false,NONE) 
	  => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_abs(env,[s1]) 
          => (Exp.CALL(Absyn.IDENT("abs"),[s1'],false,false),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
	
end


relation elab_builtin_sqrt : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule 
        elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          (**print "# sqrt function not implemented yet REAL\n" **)
     --------------------------------------
     elab_builtin_sqrt(env,[s1]) 
        => (Exp.CALL(Absyn.IDENT("sqrt"),[s1'],false,false),
            Types.PROP((Types.T_REAL([]),NONE),c))

end

relation elab_builtin_div : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c),_) 
        --------------------------------------
        elab_builtin_div(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_div(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))
        
  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_div(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
        --------------------------------------
        elab_builtin_div(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,false),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
        
end

relation elab_builtin_mod : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c),_) 
        --------------------------------------
        elab_builtin_mod(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_mod(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))
        
  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_mod(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
        --------------------------------------
        elab_builtin_mod(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,false),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
        
end

relation elab_builtin_rem : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c),_) 
        --------------------------------------
        elab_builtin_rem(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_rem(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))
        
  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_rem(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,false),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
          elab_exp (env,s2,false,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
        --------------------------------------
        elab_builtin_rem(env,[s1,s2]) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,false),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
        
end

relation elab_builtin_integer : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties) =
  rule 
        elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          (**print "# integer function not implemented yet REAL\n" **)
     --------------------------------------
     elab_builtin_integer(env,[s1]) 
        => (Exp.CALL(Absyn.IDENT("integer"),[s1'],false,false),
            Types.PROP((Types.T_INTEGER([]),NONE),c))

end

relation elab_builtin_diagonal : (Env.Env, Absyn.Exp list) => (Exp.Exp, Types.Properties)	=

  rule 	Debug.fprint("failtrace", "elab_builtin_diagonal\n") &
		elab_exp (env,s1,false,NONE) 
	      => (s1', Types.PROP((Types.T_ARRAY(dim as Types.DIM(SOME(dimension)),
                                             arrType),NONE),c),_)
          (**print "# integer function not implemented yet REAL\n" **)
        --------------------------------------
        elab_builtin_diagonal(env,[s1]) 
          => (
              Exp.CALL(Absyn.IDENT("diagonal"),[s1'],false,false),
              Types.PROP((Types.T_ARRAY(dim,(Types.T_ARRAY(dim,arrType),NONE)),NONE),c))

      
  rule  print"#-- elab_builtin_diagonal: Couldn't elaborate diagonal()\n"
	    ---------------------------------------------------------
	    elab_builtin_diagonal (_,_) => fail

end


     

relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list) 
					  => (Exp.Exp, Types.Properties)) =

  axiom	elab_builtin_handler "size" => elab_builtin_size
  axiom	elab_builtin_handler "zeros" => elab_builtin_zeros
  axiom	elab_builtin_handler "ones" => elab_builtin_ones
  axiom	elab_builtin_handler "fill" => elab_builtin_fill
  axiom	elab_builtin_handler "max" => elab_builtin_max
  axiom	elab_builtin_handler "min" => elab_builtin_min
  axiom elab_builtin_handler "transpose" => elab_builtin_transpose
  axiom	elab_builtin_handler "array" => elab_builtin_array
  axiom	elab_builtin_handler "sum" => elab_builtin_sum
  axiom	elab_builtin_handler "pre" => elab_builtin_pre
  axiom	elab_builtin_handler "initial" => elab_builtin_initial
  axiom	elab_builtin_handler "terminal" => elab_builtin_terminal
  axiom elab_builtin_handler "floor" => elab_builtin_floor
  axiom elab_builtin_handler "ceil" => elab_builtin_ceil
  axiom elab_builtin_handler "abs" => elab_builtin_abs
  axiom elab_builtin_handler "sqrt" => elab_builtin_sqrt
  axiom elab_builtin_handler "div" => elab_builtin_div
  axiom elab_builtin_handler "integer" => elab_builtin_integer
  axiom elab_builtin_handler "mod" => elab_builtin_mod
  axiom elab_builtin_handler "rem" => elab_builtin_rem
  axiom	elab_builtin_handler "diagonal" => elab_builtin_diagonal

end


(** relation: elab_call_builtin
 **
 **)

relation elab_call_builtin : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Types.Properties) =

  rule	elab_builtin_handler name => handler &
	handler (env, args) => (exp,prop)
	-------------------
	elab_call_builtin (env, Absyn.CREF_IDENT(name,[]), args) => (exp, prop)
end


(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg list, bool, Interactive.InteractiveSymbolTable option)
	=> (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =

	  (** LS: Check if a builtin function call, e.g. size()
	      and calculate if so **)

  rule	(* Elaborate interactive function calls *)
	elab_call_interactive(env,fn,args,nargs,impl,st) => (e,prop,st)
	-------------------------------------------------------
	elab_call(env,fn,args,nargs,impl,st) => (e,prop,st)

  rule	(* PA. Built in functions have only possitional arguments *)
	elab_call_builtin (env, fn, args) => (e,prop)
	---------------------------------------------
	elab_call (env,fn,args,nargs,impl,st) => (e,prop,st)

  rule	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args,nargs,st) => (e,prop) &
	generate_compiled_function(env,fn,e,prop,st) => st' 
	(*& Debug.fprintln ("sei", "elab_call succeeded")*)
	------------------------------------
	elab_call (env,fn,args,nargs,impl,st) => (e,prop,st')

  rule	Debug.fprint("failtrace", "- elab_call failed\n") &
	Debug.fprint("failtrace", " function: ") &
	Debug.fcall("failtrace", Dump.print_component_ref,fn) &
	Debug.fprint("failtrace", " posargs: ") &
	Debug.fprint_list("failtrace", args, Dump.print_exp,", ") &	
	Debug.fprint("failtrace", "\n") 
	----------------------------
	elab_call (env,fn,args,nargs,impl,st) => fail

end

(** relation: elab_call_interactive
 *
 * This relation elaborates the functions defined in the interactive environment.
 * Since some of these functions are meta-functions, they can not be described in the type 
 * system, and is thus given the the type T_NOTYPE
 *)
relation elab_call_interactive : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg list, bool, Interactive.InteractiveSymbolTable option)
 	  => (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =

  rule	Absyn.cref_to_path(cr) => path & path_to_component_ref(path) => cr'
	-------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("lookupClass",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("lookupClass"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("typeOf",_),
			      [ Absyn.CREF(Absyn.CREF_IDENT(varid,[]))],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("typeOf"),
		       [Exp.CREF(Exp.CREF_IDENT(varid,[]),Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clear",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clear"), [], false, true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clearVariables",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clearVariables"), [], false, true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("list",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("list"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("list",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("list"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	let recordtype = 
	((Types.T_COMPLEX(ClassInf.RECORD("SimulationObject")
			,[Types.VAR("flatClass",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
,Types.VAR("exeFile",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
			  ]
			),NONE))
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("translateModel",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("translateModel"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP(recordtype,false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' 
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("instantiateModel",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("instantiateModel"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	get_optional_named_arg(env,SOME(st),"startTime",args,Exp.RCONST(0.0)) 
	  => startTime &
	  int_real(1) => realone &
	get_optional_named_arg(env,SOME(st),"stopTime",args,Exp.RCONST(realone)) 
	  => stopTime &
	get_optional_named_arg(env,SOME(st),"numberOfIntervals",args,Exp.ICONST(500)) 
	  => numberOfIntervals &
	let recordtype = 
	((Types.T_COMPLEX(ClassInf.RECORD("SimulationResult")
			,[Types.VAR("resultFile",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
			  ]
			),NONE)) 
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("simulate",_),
			      [ Absyn.CREF(cr)],args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("simulate"),
		       [Exp.CREF(cr',Exp.OTHER),startTime,
			stopTime,numberOfIntervals], (* Fill in rest of defaults here*)
		       false,
		       true),
	      Types.PROP(recordtype,false),
	      SOME(st))

  rule	elab_variablenames(vars) => vars'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("readSimulationResult",_),
			      [ Absyn.STRING(filename),
			       Absyn.ARRAY(vars),
			       Absyn.INTEGER(size)
			       ],args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("readSimulationResult"),
		       [Exp.SCONST(filename),
			Exp.ARRAY(Exp.OTHER,false,vars'),
			Exp.ICONST(size)], 
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_variablenames(vars) => vars'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("plot",_),
			      [Absyn.ARRAY(vars)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("plot"),
		       [Exp.ARRAY(Exp.OTHER,false,vars')],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))


  rule	elab_exp(env,exp,impl,SOME(st)) => (exp',prop,st')
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("timing",_),
			      [exp],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("timing"),
		       [exp'],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),false),
	      st')


  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("generateCode",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("generateCode"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompiler",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompiler"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompilerFlags",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompilerFlags"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setDebugFlags",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setDebugFlags"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("cd",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("cd"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("cd",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("cd"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("system",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("system"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_INTEGER([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("readFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("readFile"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

	(* Returns an array of "component references" *)
axiom	elab_call_interactive(env, Absyn.CREF_IDENT("listVariables",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("listVariables"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_ARRAY(Types.DIM(NONE),(Types.T_NOTYPE,NONE)),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("getErrorString",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getErrorString"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("runScript",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("runScript"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("loadModel",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("loadModel"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("loadFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("loadFile"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("saveModel",_),
			      [ Absyn.STRING(str),Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("saveModel"),
		       [Exp.SCONST(str),Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("saveAll",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("saveAll"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("help",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("help"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getUnit",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getUnit"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getQuantity",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getQuantity"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getDisplayUnit",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getDisplayUnit"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getMin",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getMin"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getMax",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getMax"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getStart",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getStart"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getFixed",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getFixed"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getNominal",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getNominal"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),false),
	      SOME(st))

  rule	elab_untyped_cref(env,cr) => cr' &
	elab_untyped_cref(env,cr2) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getStateSelect",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getStateSelect"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_ENUMERATION(["never", "avoid", "default", "prefer", "always"],[]),NONE),false),
	      SOME(st))



(* FIXME: test code: remove *)

  rule	elab_exp(env,aexp,impl,SOME(st)) => (exp1',prop1,SOME(st')) &
	elab_exp(env,acref,impl,SOME(st')) => (exp2',prop2,SOME(st''))
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("exp_contains",_),
			      [ aexp, acref],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("exp_contains"),
		       [exp1', exp2'],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),false),
	      SOME(st''))

  rule	elab_exp(env,aexp1,impl,SOME(st)) => (exp1',prop1,SOME(st')) &
	elab_exp(env,aexp2,impl,SOME(st')) => (exp2',prop2,SOME(st'')) &
	elab_exp(env,acref,impl,SOME(st'')) => (exp3',prop3,SOME(st'''))
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("solve",_),
			      [ aexp1, aexp2, acref],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("solve"),
		       [exp1', exp2', exp3'],
		       false,
		       true),
	      prop3,
	      SOME(st'''))

(* /FIXME: test code: remove *)


end

(* This relation elaborates variablenames to Exp.Exp. A variablename can
 * be used in e.g. plot(model,{v1[3],v2.t}) It should only be used in interactive functions that uses variablenames as componentreferences.
*)
relation elab_variablenames: Absyn.Exp list => Exp.Exp list =

  axiom	elab_variablenames [] => []

  rule	(* Use simplified conversion, all indexes integer constants *)
	Exp.to_exp_cref(cr) => cr' &
	elab_variablenames(xs) => xs' 
	-----------------------------
	elab_variablenames(Absyn.CREF(cr)::xs) 
	  => Exp.CREF(cr',Exp.OTHER)::xs'
end


(* This relation is used to "elaborate" interactive functions optional parameters, e.g. simulate(A.b, startTime=1), startTime is an optional parameter *)

relation get_optional_named_arg: (Env.Env, Interactive.InteractiveSymbolTable option,
				  Ident,Absyn.NamedArg list,Exp.Exp) 
	=> Exp.Exp =

  axiom	get_optional_named_arg(_,_,_,[],exp) => exp

  rule	id = id2 &
	elab_exp(env,exp,true,st) => (exp',_,_)
	--------------------------------------------------
	get_optional_named_arg(env,st,id,Absyn.NAMEDARG(id2,exp)::xs,dexp) => exp'

  rule	get_optional_named_arg(env,st,id,xs,dexp) => exp'
	--------------------------------------------------
	get_optional_named_arg(env,st,id,Absyn.NAMEDARG(id2,exp)::xs,dexp) => exp'
end

(* This relation elaborates a ComponentRef without adding type information. *)
(* Environment is passed along, such that constant subscripts can be elabed using existing
 relations *)	
relation elab_untyped_cref: (Env.Env, Absyn.ComponentRef) => Exp.ComponentRef =

  rule	elab_subscripts(env, subs) => (subs',_)
	----------------------------------
	elab_untyped_cref(env, Absyn.CREF_IDENT(id,subs)) => Exp.CREF_IDENT(id,subs')

  rule	elab_subscripts(env,subs) => (subs',_) &
	elab_untyped_cref(env, cr) => cr'
	-----------------------------
	elab_untyped_cref(env, Absyn.CREF_QUAL(id,subs,cr)) => Exp.CREF_QUAL(id,subs',cr')
end

relation path_to_component_ref: Absyn.Path => Exp.ComponentRef =

  axiom	path_to_component_ref(Absyn.IDENT(s)) => Exp.CREF_IDENT(s,[])

  rule	path_to_component_ref(path) => cref
	----------------
	path_to_component_ref(Absyn.QUALIFIED(id,path)) => Exp.CREF_QUAL(id,[],cref)
end

relation component_ref_to_path: Exp.ComponentRef => Absyn.Path =

  axiom	component_ref_to_path(Exp.CREF_IDENT(s,[])) => Absyn.IDENT(s)

  rule	component_ref_to_path(cref) => path
	----------------
	component_ref_to_path(Exp.CREF_QUAL(id,_,cref)) => Absyn.QUALIFIED(id,path)
end

(* relation: generate_compiled_function 
 ** TODO: This currently only works for top level functions. For functions inside packages 
 ** we need to reimplement without using lookup functions, since we can not build
 ** correct env for packages containing functions.   
   *)
relation generate_compiled_function: (Env.Env, Absyn.ComponentRef, Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =>
	(Interactive.InteractiveSymbolTable option) =

(*  axiom generate_compiled_function(_,_,_,_,NONE) => NONE *)
	
  rule	(*Debug.fprintln("sei", "generate_compiled_function: start1") &*)
	Absyn.cref_to_path(fn) => pfn &
	is_function_in_cflist (cflist,pfn) => true
	-----------------------------------------------
	generate_compiled_function(env,fn,e,Types.PROP(t,_),SOME(st as Interactive.SYMBOLTABLE(p,_,_,_,cflist))) => SOME(st)

  rule	(*Debug.fprintln("sei", "generate_compiled_function: start2") &*)
	Absyn.cref_to_path(fn) => path &
	is_function_in_cflist (cflist, path) => false &
	SCode.elaborate(p) => p' &
	(*Debug.fprintln("sei", "generate_compiled_function: elaborated") &*)
(*	Inst.instantiate_implicit(p') => d & *)
	Lookup.lookup_class(env, path, false) => (cls, env') &
	(*Debug.fprintln("sei", "generate_compiled_function: class looked up") &*)
	Inst.implicit_function_instantiation(env', Types.NOMOD,
					     Prefix.NOPRE, [], cls, [], false)
	  => (env'',d) &
	(*Debug.fprintln("sei", "generate_compiled_function: function instantiated") &*)
	Print.clear_buf() &
	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Codegen.generate_functions(d') &
	(*Debug.fprintln("sei", "generate_compiled_function: function generated") &*)
	ModUtil.path_string2 (path,"_") => pathstr &	
	string_append(pathstr,".c") => filename &
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf "\nint main(int argc, char** argv)\n{\n\n  if (argc != 3)\n    {\n      fprintf(stderr,\"# Incorrrect number of arguments\\n\");\n      return 1;\n    }\n" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
	Print.write_buf(filename)& Print.clear_buf() &
	System.compile_c_file(filename) 
(*	& Debug.fprintln("sei", "generate_compiled_function: compiled")*)
	-----------------------------------------------
	generate_compiled_function(env,fn,e,Types.PROP(t,_),SOME(st as Interactive.SYMBOLTABLE(p,a,b,c,cflist))) => SOME(Interactive.SYMBOLTABLE(p,a,b,c,(path,t)::cflist))



  rule	(*Debug.fprintln("sei", "generate_compiled_function: start3")*)
	-----------------------------------------------
	generate_compiled_function(env,fn,e,Types.PROP(t,_),NONE) => NONE
	(* PROP_TUPLE? *)

  rule	(* If fails, skip it. *)
	--------------------------------------------------
	generate_compiled_function(_,_,_,_,st) => st


  rule	Debug.fprint("failtrace", "- generate_compiled_function failed4\n") &
	Dump.print_component_ref_str cr => str1 &
	Exp.print_exp_str exp => str2 &
	Print.print_buf str1 &
	Print.print_buf " -- " &
	Print.print_buf str2 &
	Print.print_buf "\n"
	------------------------------------------------------------------
	generate_compiled_function(env,cr,exp,_,_) => fail

end


relation is_function_in_cflist : ((Absyn.Path * Types.Type) list, Absyn.Path) => bool =

  axiom	is_function_in_cflist ([],_) => false

  rule	ModUtil.path_equal (path1, path2) => true
	-----------------------------------------
	is_function_in_cflist ((path1, ty)::rest, path2) => true

  rule	ModUtil.path_equal (path1, path2) => false &
	is_function_in_cflist (rest, path2) => res
	------------------------------------------
	is_function_in_cflist ((path1, ty)::rest, path2) => res
end

(** relation: elab_call_args
 **
 ** Given the name of a function and two lists of expression and 
 ** NamedArg respectively to be used 
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, Absyn.Path, Absyn.Exp list, Absyn.NamedArg list, Interactive.InteractiveSymbolTable option)
	=> (Exp.Exp, Types.Properties) =

  rule	(* This rule finds record constructors, user defined or implicit *)	
	Lookup.lookup_type(env,fn,true) => (t as (Types.T_FUNCTION(fargs,outtype as (Types.T_COMPLEX(ClassInf.RECORD(_),_),_)),_),env') &
	make_empty_slots(fargs) => slots &
	elab_input_args(env, args,nargs,slots) => (args',newslots, const) &
	Lookup.lookup_record_constructor_class(env',fn) => (cl,env'') &	
	fill_default_slots(newslots,cl,env'') => newslots2 &
	exp_list_from_slots(newslots2) => args'' 
	------------------------------------
	elab_call_args(env,fn,args,nargs,st) 
	  => (Exp.CALL(fn,args'',false,false), Types.PROP(outtype,const))


	(* This rule finds the built-in functions *)
	(* FIXME: LS: How do we know that? Anyway, if true, I've changed false *)
	(* to true in Exp.CALL() where last flag stands for "builtin" *)
  rule	

	(* PR. A function can have several types. Taking an array with
	 different dimensions as parameter for example. Because of this we
	 cannot just lookup the function name and trust that it
	 returns the correct function. It returns just one
	 functiontype of several possibilites. The solution is to send
	 in the funktion type of the user function and check both the
	 funktion name and the function's type. 
	 *)
	Lookup.lookup_functions_in_env(env,fn) => typelist &
	(* The constness of a function depends on the inputs. If all inputs are
	 * constant the call itself is constant.
	 *)
	elab_types (env, args, typelist) => (args', const, restype, functype) &
	deoverload_funcname(fn,functype) => fn' &
	is_tuple restype => tuple 
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs,st) 
	  => (Exp.CALL(fn',args',tuple,false), Types.PROP(restype,const))

  rule	(* Rule above failed. Also consider koening lookup. *)
	get_koening_function_types(env,fn,args,nargs) => ktypelist &
	elab_types (env, args, ktypelist) => (args', c, restype, functype) &
	deoverload_funcname(fn,functype) => fn' &
	is_tuple restype => tuple &
	elab_consts(restype) => const &
	get_properties(restype,const) => prop 
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs,st) => (Exp.CALL(fn',args',tuple,false), prop)

  rule	not Lookup.lookup_type(env,fn,false) => (_,_) &
	
	Print.print_buf "# Couldn't find function " & Dump.print_path fn & Print.print_buf "\n" 
	-------------------------------------------------------------------
	elab_call_args(env,fn,_,_,_) => fail

  rule	(*elab_exp(env, e) => (e',Types.PROP(t,_)) &*)
	Debug.fprint("failtrace", "- elab_call_args failed\n")
	---------------------------------
	elab_call_args(_,_,_,_,_) => fail

end

(** relation: deoverload_funcname
 ** This relation is used to deoverload function calls. It investigates the type of the function
 ** to see if it has the optional functionname set. If so this is returned. 
 ** Otherwise return input.
**)
relation deoverload_funcname: (Absyn.Path, Types.Type) => Absyn.Path =

  axiom	deoverload_funcname(fn,(Types.T_FUNCTION(_,_),SOME(fn'))) => fn'

  axiom	deoverload_funcname(fn,(_,_)) => fn

end


relation is_tuple : Types.Type => bool =

  axiom is_tuple((Types.T_TUPLE(_),_)) => true
  axiom	is_tuple( (_,_) )  => false

end
(*PR.*)
relation  elab_types:  (Env.Env, Absyn.Exp list,  Types.Type list) 
	  => (Exp.Exp list, bool, Types.Type(*result type*), Types.Type(*function type*)) =

	(* 
	 We found nothing. This is an error. return to the calling
	 function that writes an error message that makes sense (the
	 name of the funtion etc). 
	 *)
	(* 
	 If trest gets empty then we will return with a missmatch.
	 and write an error message in the calling function. 
	 *)

	(* We found a match.*)
  rule	(*Debug.fprintln ("sei", "We try the elab_input") &
	Debug.fprintln ("sei", "testing type:") &
	Debug.fcall ("sei", Types.print_type,t) &*)
	make_empty_slots(params) => slots &
	elab_input_args(env, args, [], slots ) => (args',newslots, c) 
 (*       & Debug.fprintln ("sei", "We found a match." )*)
	------------------
        elab_types(env, args, (t as (Types.T_FUNCTION(params,restype),_))::trest)
	  => (args', c, restype, t)

	(* We did not found a match, try next. *)
  rule 	(*Debug.fprintln ("sei", "The elab_input_args failed, try next.") &*)
	elab_types(env, args, trest) => (args',c, restype,t) 
        ------------------
        elab_types(env, args, (Types.T_FUNCTION(params,restype),_)::trest) 
	  => (args', c, restype,t)

  rule	Debug.fprint("failtrace","- elab_types failed.") 
	--------------
	elab_types(env,_,_) => fail

end


(* PR get_prop 
*)
(* LS: Changed type list to type, since T_TUPLE already fixed before *)
relation get_properties : (Types.Type, Types.Const)  => Types.Properties =

	(* At least two elements in the type list, this is a tuple. *)
	(* LS: Tuples are fixed before here *)
  axiom	get_properties (tt as (Types.T_TUPLE(_),_), const) => Types.PROP_TUPLE(tt, const)

	(* One type, this is a tuple with one element. The resulting properties 
	 * is then identical to that of a single expression. *)
  axiom	get_properties(t, Types.TUPLE_CONST(Types.CONST(b)::[]))  => Types.PROP(t, b)

end


(** PR. assisting routines
 ** This just splits the properties list into a type list and a const list. 
 **)
(* LS: Changed to take a Type, which is the functions return type *)
relation elab_consts : Types.Type  => Types.Const =

  rule	check_consts tys => consts
	-------------------------------
	elab_consts((Types.T_TUPLE(tys),_)) => Types.TUPLE_CONST(consts)

  (* LS: If not a tuple then one normal type, T_INTEGER etc, but we make a list of types
     with one element and call the same check_consts, so that we always have Types.TUPLE_CONST as result
   *)
  rule	check_consts [ty] => consts
	-----------------------
	elab_consts ty => Types.TUPLE_CONST(consts)

end

(* LS: Changed to take a Type list, which is the functions return type. Only
   for functions returning a tuple *)
relation check_consts : Types.Type list => Types.Const list =	

  axiom	check_consts [] => []

  rule  check_const(a) => c &
	check_consts(rest) => rest'
	-------------------------------
	check_consts a::rest => c::rest'

end



(*PR. !! At the moment this make all outputs non cons.
* All ouputs sholud be checked in the function body for constness. 
*)
(* LS: but it says true? *)
(* LS: Adapted to check one type instead of funcarg, since it just checks return type *)
relation check_const : Types.Type => Types.Const  =	
	
  rule	print("\n Error. No support for tuples built by tuples. Yet.") 
	-------------------------------
	check_const ((Types.T_TUPLE(_),_)) => fail

  axiom	check_const((_,_)) => Types.CONST(true)
	
end

(* Splits the properties list into the separated types list and const list. *)
relation split_props : (Types.Properties list) => (Types.Type list, Types.Const list) =
  rule 	(*list_append(ts,t::[]) => t1 &
	list_append(cs,Types.CONST(c)::[]) => t2 &
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (Types.PROP(t,c)::props)=> (t::types,Types.CONST(c)::consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	(*list_append(cs, t_c::[]) => cs' & 
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (Types.PROP_TUPLE(t,t_c)::props)=> (t::types,t_c::consts)
  
  axiom	split_props([]) => ([], [])
end










(* obsolete LS: added space to inner comments, for emacs fontify to work
relation split_props: (Types.Properties list, Types.Type list, Types.Const list) => (Types.Type list, Types.Const list) =
  rule 	list_append(ts,t::[]) => t1 &
	list_append(cs,Types.CONST(c)::[]) => t2 &
	split_props(props, t1, t2) => (types, consts)
	-------------------------------------
	split_props (Types.PROP(t,c)::props, ts, cs)=> (types,consts)

  rule 	( *  list_append(ts,t::[]) => ts' &   * )
	list_append(cs, t_c::[]) => cs' & 
	split_props(props, [], cs') => (types, consts)
	-------------------------------------
	split_props (Types.PROP_TUPLE(t,t_c)::props, ts, cs)=> (types,consts)
  
  axiom	split_props([],ts,cs) => (ts, cs)
end
*)









(* LS: Changed to match FuncArg *)
relation get_types :(Types.FuncArg list) => Types.Type list =

  rule	(* print("\nDebug: Got a type for output of function. ") & *)
	get_types(rest) => types 
	-----------------
	get_types ((n,t)::rest) => t::types
	
  axiom	get_types ([]) => []
	
end


(** relation: functio_params
 **
 ** A function definition is just a clas definition where all publi
 ** components are declared as either inpu or outpu.  This
 ** relation_ find all those components and_ separates them into two
 ** separate lists.
 **)

(* LS: This can probably replaced by Types.get_input_vars and
   Types.get_output_vars *)

relation function_params : Types.Var list => (Types.FuncArg list,
					      Types.FuncArg list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	(*Debug.print("protected") &*)
	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	(*Debug.print("not protected. intput") &*)
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	(*Debug.print("not protected. output") &*)
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	Print.print_buf "# Components in functions must be INPUT or OUTPUT\n" &
	Print.print_buf "    component: " & Print.print_buf n & Print.print_buf "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,Types.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	Print.print_buf "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(* * relation_: elab_input_args
 **
 ** This relation_ elaborates on a number of expressions and_ matches
 ** them to a number of `Types.Var' objects, applying type_ conversions
 ** on the expressions when necessary to match the type_ of the
 ** `Types.Var'.
 * *)

(* PR. env, input args from the function call, in arguments in the
 function_ definition. *)
(* LS: inserted FuncArg *)
(* PA: Positional arguments and named arguments are filled in the argument slots as:
 1. Positional arguments fill the first slots according to their position.
 2. Named arguments fill slots with the same name as the named argument.
 3. Unfilled slots are checks so that they have default values, otherwise error.
*)
relation elab_input_args : (Env.Env, Absyn.Exp list, Absyn.NamedArg list, Slot list)
	=> (Exp.Exp list, Slot list, bool) =

  rule	(*Debug.fprint ("sei","elab_input_args, positional arguments\n") &*)
	funcarg_lst_from_slots(slots) => farg &
	elab_positional_input_args(env,exp,farg,slots) => (slots',c) &
	elab_input_args(env,[],narg,slots') => (_,newslots,c2) &
	bool_and(c,c2) => c3 &
	exp_list_from_slots(newslots) => explst
	----------------------------------------------------------------
	elab_input_args(env,exp as _::_,narg,slots) => (explst,newslots,c3)

  rule	(*Debug.fprint ("sei","elab_input_args, named arguments\n") &*)
	funcarg_lst_from_slots(slots) => farg &
	(*Debug.fprint ("sei","elab_input_args, got funcarg\n") &*)
	elab_named_input_args(env,narg,farg,slots) => (newslots,c) &
	exp_list_from_slots(newslots) => newexp 
	(*& Debug.fprint ("sei","elab_input_args, got expressions: ") &
 	Debug.fprint_list ("sei",newexp,Exp.print_exp,", ")*)
	------------------------------------------------------------
	elab_input_args(env,[],narg as _::_,slots) => (newexp,newslots,c)
	
  axiom	elab_input_args(env,[],[],slots) => ([],slots,true)
	
(*  rule	Print.print_buf "#Error, elab_input_args failed.\n"
	-----------------------------------------
	elab_input_args(_,_,_,_) => fail*)
end

relation make_empty_slots : (Types.FuncArg list) => Slot list =
	
  axiom	make_empty_slots([]) => []
	
  rule	make_empty_slots(fs) => ss
	--------------------------
	make_empty_slots(fa::fs) => SLOT(fa,false,NONE)::ss
end

relation funcarg_lst_from_slots : Slot list => Types.FuncArg list =
	
  axiom	 funcarg_lst_from_slots [] => [] 

  rule	funcarg_lst_from_slots(xs) => fs
	-------------------------------
	funcarg_lst_from_slots(SLOT(fa,_,_)::xs) => fa::fs
end 

relation exp_list_from_slots: (Slot list ) => Exp.Exp list =
	
  axiom	exp_list_from_slots [] => []
	
  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,SOME(e))::xs) => e::lst

  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,NONE)::xs) => lst
end

(** relation: fill_default_slots
 ** This function takes a slot list and a class definition of a function and fills default values into slots which 
 ** have not been filled.
   **)
	
relation fill_default_slots: (Slot list , SCode.Class, Env.Env) => Slot list =
	
  rule	fill_default_slots(xs,class,env) => res
	----------------------------
	fill_default_slots ( SLOT(fa,true,e)::xs,class,env) => SLOT(fa,true,e)::res

  rule	fill_default_slots(xs,class,env) => res &
	SCode.get_element_named(id,class) => SCode.COMPONENT(_,_,_,_,_,_,SCode.MOD(_,_,SOME(dexp)),_) &
	elab_exp (env,dexp,false,NONE) => (exp,Types.PROP(t,c1),_) &
	Types.match_type(exp,t,tp) => (exp',_) 
	---------------------------------------------------------------------------------
	fill_default_slots (SLOT((id,tp),false,e)::xs,class,env) => SLOT((id,tp),true,SOME(exp'))::res

  rule	fill_default_slots(xs,class,env) => res &
	Print.print_buf "#Error filling slot, id =" &
	Print.print_buf id &
	Print.print_buf "\n"
	----------
	fill_default_slots (SLOT((id,tp),false,e)::xs,class,env) => SLOT((id,tp),true,e)::xs

  axiom	fill_default_slots([],_,_) => []
end

relation print_slots: Slot list => () =
  rule	Print.print_buf "SLOT(" &
	Types.print_farg farg &
	Print.print_buf  ", " &
	Dump.print_select(filled,"filled","not filled") &
	Print.print_buf ", " &
	Dump.get_option_str(exp,Exp.print_exp_str) => str &
	Print.print_buf str &
	Print.print_buf ")\n" &
	print_slots(xs)
	---------------
	print_slots (SLOT(farg,filled,exp)::xs) => ()
  axiom	print_slots([] ) => ()
end 

(** relation: elab_positional_input_args
 ** This relation elaborates the positional input arguments of a function.
 ** A list of slots is filled from the beginning with types of each positional argument.
 **)
relation elab_positional_input_args : (Env.Env, Absyn.Exp list, Types.FuncArg list,  Slot list) 
	  => (Slot list, bool) =
	  
  axiom	elab_positional_input_args(_, [], _, slots) => (slots, true)
	
  rule	elab_exp(env, e,false,NONE) => (e',Types.PROP(t, c1),_) &
	Types.match_type(e', t, vt) => (e'',_) &
	elab_positional_input_args(env, es, vs,slots) => (slots',c2) &
	bool_and(c1, c2) => c &
	fill_slot(farg, e'',slots') => newslots
	-------------------------------------
	elab_positional_input_args(env, e::es, (farg as (_,vt))::vs, slots) 
	    => (newslots, c)
end

(** relation elab_named_input_args
 ** This relation takes an Env, a NamedArg list, a Types.FuncArg list and a Slot list.
 ** It builds up a new slot list and a list of elaborated expressions.
 ** If a slot is filled twice the relation fails. If a slot is not filled at all and the 
 ** value is not a parameter or a constant the relation also fails.
*)
relation elab_named_input_args : (Env.Env, Absyn.NamedArg list, Types.FuncArg list, Slot list) 
	=> (Slot list, bool) =

(*  rule	check_slots_filled(env,slots) 
	----------------------------
	elab_named_input_args(env,[],farg,slots) => ([],slots,true) *)

  rule	elab_exp(env, e,false,NONE) => (e',Types.PROP(t, c1),_) &
	(*Debug.fprint("sei", "elab_named_input_arg, elaborated exp\n  id =") &
	Debug.fprint("sei",id) &*)
	find_named_arg_type(id,farg) => vt &
	(*Debug.fprint ("sei", "elab_named_input_arg, found type\n") &
	Debug.fprint ("sei", "exp t = " ) &
	Debug.fcall ("sei", Types.print_type,t ) &
	Debug.fprint ("sei", "func t = " ) &
	Debug.fcall ("sei", Types.print_type,vt ) &*)
	Types.match_type(e', t, vt) => (e'',_) &
	(*Debug.fprint ("sei", "elab_named_input_arg, Types matched!\n") &*)
	fill_slot((id,vt), e'', slots) => slots' &
	(*Debug.fprint ("sei", "elab_named_input_arg, filled slot\n") &*)
	elab_named_input_args(env, nas, farg ,slots') => (newslots, c2) &
	bool_and(c1, c2) => c 
	---------------------
	elab_named_input_args (env, Absyn.NAMEDARG(id,e)::nas,farg,slots) 
	  => (newslots, c)

axiom elab_named_input_args (_,[],_,slots) => (slots,true)

  rule	(*Debug.fprint ("sei","elab_named_input_args failed, nargs = ") &
	Debug.fprint_list ("sei", narg, Dump.print_named_arg," ,")&
	Debug.fprint ("sei"," FuncArg=") &
	Debug.fcall  ("sei",Types.print_params,farg) &
	Debug.fprint ("sei", "\n")*)
	-----------------
	elab_named_input_args(env,narg,farg,_) => fail
end

(** relation find_named_arg_type
 ** This relation takes an Ident and a FuncArg list, and returns the FuncArg which has that identifier.
 ** Used for instance when looking up named arguments from the function type.
 **)
 relation find_named_arg_type : (Ident, Types.FuncArg list) => Types.Type =
	 
  rule	 id = id2
	 -----------------
	 find_named_arg_type (id, ((id2,farg))::ts) => farg
  rule	 not id = id2  &
	 find_named_arg_type (id,ts) => farg
	 ----------------------------------
	 find_named_arg_type(id,(farg as (id2,_))::ts) => farg
end

(** relation: fill_slot
 ** This relation takses a `FuncArg' and an Exp.Exp and a Slot list and fills the slot holding the FuncArg, by setting
 ** the boolean value of the slot and setting the expression. The relation fails if the slot is allready set.
 **)
relation fill_slot:(Types.FuncArg, Exp.Exp, Slot list) => Slot list =
	
  rule	fa1 = fa2
	---------
	fill_slot((fa1,_), exp,SLOT((fa2,b),false,_)::xs) => SLOT((fa2,b),true,SOME(exp))::xs

  rule	fa1 = fa2 &
	Print.print_buf "#Error, slot in functional argument allready filled.\b" 
	--------------------------------------------------------------
	fill_slot((fa1,_),exp, SLOT((fa2,b),true,_)::xs) => fail

  rule	not fa1 = fa2 &
	fill_slot(farg,exp,xs) => newslots
	------------------------------
	fill_slot((farg as (fa1,_)), exp,(s1 as SLOT((fa2,_),_,_))::xs) => s1::newslots

  rule  Print.print_buf "#Error, slot not found in function type.\n"
	---------------------------------------------------
	fill_slot(_,_,_) => fail
end

(* LS *)

relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	=> (Exp.Exp list, Types.Properties list, SCode.Accessibility list) =

  axiom	elab_cref_list (_, []) => ([], [], [])

  rule	elab_cref (env, cref) => (exp, prop, acc) &
	elab_cref_list (env, creflist) => (explist, proplist, acclist)
	----------------------------------------------------------
	elab_cref_list (env, cref::creflist) 
	  => (exp::explist, prop::proplist, acc::acclist)

end


(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Types.Properties, SCode.Accessibility) =

  rule elab_cref_subs (env,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,acc,variability,_),
				       t,
				       binding) &
	(*Debug.fprint("ecref","elab_cref, looked up type:\n") &
	Debug.fcall("ecref",Types.print_type,t) &*)

	elab_cref2 (env, c', acc, variability, t, binding)
	  => (exp,const,acc') 
	(* FIXME subscript_cref_type (exp,t) => t' &  *)
	---------------------------------
	elab_cref(env, c) => (exp, Types.PROP(t, const), acc')

  rule	elab_cref_subs (env,c) => (c', const) &
	Print.print_buf "# Unknown component: " & Dump.print_component_ref c &
	Print.print_buf "\n  ENV:   " & Env.print_env env 
	-----------------------------------------------------
	elab_cref(env, c) => fail

(*  rule	Debug.fprint("failtrace", "- elab_cref failed: ") & 
	Debug.fcall("failtrace",Dump.print_component_ref, c) & 
	Debug.fprint("failtrace", "\n")
	------------------------------
	elab_cref (env,c) => fail
*)

end

relation fill_cref_subscripts : (Exp.ComponentRef,Types.Type)
	  => Exp.ComponentRef =

  axiom	fill_cref_subscripts (e as Exp.CREF_IDENT(_,[]),t) => e

  rule	fill_subscripts (subs,t) => subs'
	------------------
	fill_cref_subscripts (Exp.CREF_IDENT(id,subs),t)
	  => Exp.CREF_IDENT(id,subs')

  rule	fill_cref_subscripts (cref,t) => cref'
	-----------------------------
	fill_cref_subscripts (Exp.CREF_QUAL(id,subs,cref),t)
			      => Exp.CREF_QUAL(id,subs,cref') 

end

relation fill_subscripts : (Exp.Subscript list, Types.Type) 
	  => Exp.Subscript list =

rule	fill_subscripts ([],t) => subs' &
	list_append([Exp.WHOLEDIM],subs') => subs''
	------------
	fill_subscripts ([],(Types.T_ARRAY(_,t),_)) => subs''

  rule	fill_subscripts (subs,t) => subs' 
	------------
	fill_subscripts (fs::subs,(Types.T_ARRAY(_,t),_)) => fs::subs'

  axiom	fill_subscripts (subs,_) => subs

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 ** Constant values are e.g.: 1+5, c1+c2, ps1*2   ,where c1 and c2 are modelica constants,
 **						    ps1 and ps2 are structural parameters.
 ** Non Constant values are e.g. : p1+p2, x1*x2  ,where p1,p2 are modelica parameters, 
 **						  x1,x2 modelica variables.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef,
		       SCode.Accessibility, SCode.Variability,
		       Types.Type, Types.Binding)
	  => (Exp.Exp,bool,SCode.Accessibility) =

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	-----------------------------------
	elab_cref2 (_,cr, acc, SCode.VAR, tt,_) => (Exp.CREF(cr',t),false, acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	-----------------------------------
	elab_cref2 (_,cr, acc, SCode.DISCRETE,tt,_)
	  =>(Exp.CREF(cr',t),false,acc)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,SCode.CONST,t, Types.VALBOUND(v)) => (e,true,SCode.RO)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e'
	---------------
  	elab_cref2 (env,cr,acc,SCode.PARAM,tt, Types.VALBOUND(v)) => (e',false,acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	value_exp v => e'
	----------------
  	elab_cref2 (env,cr,acc,SCode.STRUCTPARAM,tt, Types.VALBOUND(v)) => (e',true,acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e'
	-----------------------------------
	elab_cref2 (env,cr,acc,_,tt, Types.EQBOUND(exp,true))
	  => (e',true,acc)

	  (* Enum constants does not have a value expression *)
  rule	Types.elab_type tt => t
	-----------------
	elab_cref2(env,cr,acc,_,tt as (Types.T_ENUM,_),_) => (Exp.CREF(cr,t),true,acc)


  rule	(* If value not constant, but references another parameter, which has a value *)
	(* We need to perform value propagation. *)
	Lookup.lookup_var(env,cref) => (Types.ATTR(_,acc',variability',_),
				       t',
				       binding') &
	elab_cref2(env,cref,acc',variability',t',binding') => (e,const,acc)
	--------------------------------------------------
	elab_cref2 (env,cr,acc, variability,tp,Types.EQBOUND( Exp.CREF(cref,t),false)) 
	  => (e,const,acc)



  rule	print "# Constant or parameter with a non-constant initializer\n" &
	Print.print_buf "# Constant or parameter with a non-constant initializer\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr & Print.print_buf " = " &
	Exp.print_exp exp & Print.print_buf "\n"
	------------------------------
	elab_cref2 (_,cr,_, _,_,Types.EQBOUND(exp,false)) => fail

  rule	print "# Constant without a value :" &
	Print.print_buf "# Constant  without a value\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr &
	Exp.print_component_ref_str cr => str & print str & print "\n" &
	 Print.print_buf " env:\n" & Env.print_env env & Print.print_buf "\n"
	----------------------------------------------
	elab_cref2 (env,cr,_,SCode.CONST,_,Types.UNBOUND) => fail

  rule	print "# Parameter without a value :" &
	Print.print_buf "# Constant  without a value\n" &
	Print.print_buf "# component: " & Exp.print_component_ref cr &
	Exp.print_component_ref_str cr => str & print str & print "\n" &
	 Print.print_buf " env:\n" & Env.print_env env & Print.print_buf "\n"
	----------------------------------------------
	elab_cref2 (env,cr,_,SCode.PARAM,_,Types.UNBOUND) => fail


  rule	print "- elab_cref2 failed (component: " &
	Exp.print_component_ref_str cr => str & print str & print "\n" &
	Print.print_buf "- elab_cref2 failed (component: " &
	Exp.print_component_ref cr & Print.print_buf ")\n" &
	Types.unparse_type tp => ts & print "type = " & print ts & print ", " &
	Types.print_binding_str bind => binds & print "binding =" & print binds & print "\n" &
	SCode.variability_string var => vs & print "var = " & print vs & print "\n" 
	& Env.print_env env 
	----------------------------------------
	elab_cref2 (env,cr,acc,var,tp,bind) => fail

end	

(** relation: cref_vectorize
 ** This relation takes a 'Exp.Exp' and a 'Types.Type' and if the expression
 ** is a ComponentRef and the type is an array it returns an array of 
 ** component references with subscripts for each index.
 ** For instance, parameter Real x[3];   
 ** gives cref_vectorize('x', <arraytype>) => '{x[1],x[2],x[3]}'
 ** This is needed since the DAE does not know what the variable 'x' is, it only
 ** knows the variables 'x[1]', 'x[2]' and 'x[3]'.
**)
relation cref_vectorize: (Exp.Exp,Types.Type) => Exp.Exp =

  rule	create_cref_array(cr,1,ds,exptp,t) => e
	-----------------------------------
	cref_vectorize(Exp.CREF(cr,exptp),(Types.T_ARRAY(Types.DIM(SOME(ds)),t),_)) =>  e

  axiom	cref_vectorize(e,_) => e
end

(** relation: create_cref_array
 ** helper relation to cref_vectorize, creates each individual cref, e.g. {x[1],x[2], ...} from x.
**)

relation create_cref_array: (Exp.ComponentRef,int,int,Exp.Type, Types.Type) => Exp.Exp =

  rule	int_gt(indx,ds) => true
	------------------------
	create_cref_array(cr,indx,ds,et,t) => Exp.ARRAY(et,false,[])

  rule	int_add(indx,1) => indx' &
	create_cref_array(cr,indx',ds,et,t) => Exp.ARRAY(_,_,expl) &
	Exp.subscript_cref(cr,[Exp.INDEX(Exp.ICONST(indx))]) => cr' &
	cref_vectorize(Exp.CREF(cr',et),t) => e'
	------------------------
	create_cref_array(cr,indx,ds,et,t) => Exp.ARRAY(et,false,e'::expl)

  rule	Debug.fprint("failtrace","create_cref_array failed\n")
	------------------------
	create_cref_array(cr,indx,ds,et,t) => fail
end

(** relation: elab_cref_subs
 **
 ** This relation elaborates on all subscripts in a component reference.
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,t,_) &
	Types.get_dimension_sizes t => sl &
	elab_subscripts_dims(env,ss,sl) => (ss', const) 
 (*   elab_subscripts (env, ss) => (ss', const) *)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)


  rule	print "- elab_cref_subs failed\n" 
	---------------------
	elab_cref_subs(_,_) => fail
end

(** relation: elab_subscripts
 **
 ** This relation converts a list of `Absyn.Subscript' to a list of
 ** `Exp.Subscript', and checks if all subscripts are constant.
 ** HJ: not checking for constant, returning if constant or not
 **)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => true (* HL &
	Ceval.ceval_subscripts(env, sub'::subs') => ss *)
	-----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs', true)
(*	elab_subscripts (env,sub::subs) => (ss, true)*)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => false
	-----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs', false)

end

relation elab_subscripts_dims : (Env.Env, Absyn.Subscript list, int list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts_dims (_,[],_) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts_dims (env,subs,restdims) => (subs',const2) &
	bool_and (const1, const2) => true &
	Ceval.ceval_subscripts(env, sub'::subs',dim::restdims) => ss
	-----------------------------------
	elab_subscripts_dims (env,sub::subs,dim::restdims) => (ss, true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts_dims (env,subs,restdims) => (subs',const2) &
	bool_and (const1, const2) => false
	-----------------------------------
	elab_subscripts_dims (env,sub::subs,dim::restdims) => (sub'::subs', false)

end

(** relation: elab_subscript
 **
 ** This relation converts an `Absyn.Subscript' to an
 ** `Exp.Subscript'.
 **)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.WHOLEDIM, true)

  rule elab_exp (env,sub,false,NONE) => (sub', Types.PROP(ty, const),_) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub)) => (sub'', const)

end
(* HL bort
relation elab_subscript_dim : (Env.Env, Absyn.Subscript, int)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript_dim (_,Absyn.NOSUB,_) => (Exp.WHOLEDIM, true)

  rule elab_exp_dim (env,sub,false,NONE,dim) => (sub', Types.PROP(ty, const),_) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript_dim (env,Absyn.SUBSCRIPT(sub),dim) => (sub'', const)

end
*)
(** relation: elab_subscript_type
 **
 ** This relation is used to find the correct constructor for
 ** `Exp.Subscript' to use for an indexing expression.  If an integer
 ** is given as index, `Exp.INDEX()' is used, and if an integer array
 ** is given, `Exp.SLICE()' is used.
 **)

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type ((Types.T_INTEGER(_),_),_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type ((Types.T_ARRAY(_,(Types.T_INTEGER(_),_)),_),_,sub)
	  => Exp.SLICE(sub)

  rule	Print.print_buf "# Subscript is not an integer or integer array\n" &
	Print.print_buf "    expression: " & Dump.print_exp e &
 	Print.print_buf " :: " & Types.print_type t & Print.print_buf "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **
 ** This relation might actually not be needed.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c,_), t) => t'

  axiom	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (t,subs) => t'
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs), t) => t'

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **
 ** This does not handle slices or check that subscripts are not out
 ** of bounds.
 **)

relation subscript_type : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom	subscript_type (t,[]) => t

  rule	subscript_type (t, subs) => t'
	----------------------------------
	subscript_type ((Types.T_ARRAY(Types.DIM(_),t),_),
			Exp.INDEX(_)::subs) => t'

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type ((Types.T_ARRAY(dim,t),p),
			Exp.SLICE(_)::subs)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type ((Types.T_ARRAY(dim,t),p),
			Exp.WHOLEDIM::subs)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	Print.print_buf "- subscript_type failed (" & Types.print_type t &
	Print.print_buf " , [...])\n"
	-------------------
	subscript_type (t,_) => fail

end

(** relation: elab_ifexp
 ** 
 ** This relation elaborates on the parts of an if expression.
 **)

relation elab_ifexp : (Exp.Exp, Types.Properties,
		       Exp.Exp, Types.Properties,
		       Exp.Exp, Types.Properties)
	  => (Exp.Exp, Types.Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3), Types.PROP(t2, c))

  rule	Types.match_type(e2,t2,t3) => (e2',t2') & (* then-part type converted to match else-part *)
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3)) => (Exp.IFEXP(e1,e2',e3), Types.PROP(t2', c))

  rule	Types.match_type(e3,t3,t2) => (e3',t3') & (* else-part type converted to match then-part *)
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3'), Types.PROP(t2, c))

  rule	not t1 = ((Types.T_BOOL([]),NONE)) &
	Print.print_buf "# conditional in if expression has to be boolean\n" &
	Print.print_buf "    got type: " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    expression: " & Exp.print_exp e1 & Print.print_buf "\n"
	--------------------------------------------------------
	elab_ifexp(e1,Types.PROP(t1,c1),e2,Types.PROP(t2,c2),e3,Types.PROP(t3,c3)) => fail

  rule	Types.equivtypes(t2,t3) => false &
	Print.print_buf "# Type mismatch in if-expression\n" &
	Print.print_buf "    true branch : " & Exp.print_exp e2 &
 	Print.print_buf " :: " & Types.print_type t2 & Print.print_buf "\n" &
	Print.print_buf "    false branch: " & Exp.print_exp e3 &
 	Print.print_buf " :: " & Types.print_type t3 & Print.print_buf "\n"
	-----------------------------------------------
	elab_ifexp(e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),e3,Types.PROP(t3,c3)) => fail

  rule	Print.print_buf "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_) => fail

end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, bool, bool, bool) => bool =

  axiom	const_ifexp(_,true,true,true) => true
  axiom	const_ifexp(_,_,_,_) => false

end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)
  axiom	value_exp (Values.ARRAY([]))  => Exp.ARRAY(Exp.OTHER,false,[])

  rule	value_exp x => x' &
	value_type x => vt &
	Types.elab_type vt => t &
	Types.is_array vt => a &
  	value_exp Values.ARRAY(xs) => Exp.ARRAY(_,_,xs')
	--------------------------------------------
	value_exp (Values.ARRAY(x::xs)) => Exp.ARRAY(t,a,x'::xs')

  rule	Print.print_buf "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => ((Types.T_INTEGER([]),NONE))
  axiom	value_type Values.REAL(x)    => ((Types.T_REAL([]),NONE))
  axiom value_type Values.STRING(x)  => ((Types.T_STRING([]),NONE))
  axiom value_type Values.BOOL(x)    => ((Types.T_BOOL([]),NONE))

  rule	Print.print_buf "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref2  : (Env.Env, Exp.ComponentRef, int list) => Exp.ComponentRef =

  rule
    Ceval.ceval_subscripts (env,ss,sl) => ss'
	--------------------------------
	canon_cref2 (env, Exp.CREF_IDENT(n,ss),sl) => Exp.CREF_IDENT(n,ss')
end

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	
    Lookup.lookup_var (env,Exp.CREF_IDENT(n,[])) => (_,t,_) &
	Types.get_dimension_sizes t => sl & 
    Ceval.ceval_subscripts (env,ss,sl) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	
    Lookup.lookup_var (env,Exp.CREF_QUAL(n,[],c)) => (_,t,_) &
	Types.get_dimension_sizes t => sl &
    Ceval.ceval_subscripts (env,ss,sl) => ss' &
	canon_cref2 (env,c,sl) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.WHOLEDIM,Exp.WHOLEDIM)
 	
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> (Exp.Exp list,Types.Type list) =

  axiom	elab_arglist ([],[]) => ([],[])

  rule	(*Debug.fprint("earg","Match: ") & 
	Debug.fcall ("earg",Types.print_type, atype) & 
	Debug.fprint("earg"," == ") & 
	Debug.fcall ("earg",Types.print_type,pt) &
	Debug.fprint("earg","\n") &*)
	Types.match_type(arg, atype, pt) => (arg',atype') &
	(*Debug.fprint("earg","Types matched\n") &*)
	elab_arglist (pts, args) => (args',atypes')
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => (arg'::args',atype'::atypes')

(* This relation should fail sometimes. Thus it is not a good idea to print stuff here... *)
(*  rule	Debug.fprint("earg","- Static.elab_arglist failed lst1 len:") &
	list_length(lst1) => len1 &
	list_length(lst2) => len2 &
	int_string(len1) => str1 &
	int_string(len2) => str2 &
	Debug.fprintl("earg", [str1, " lst len2: ", str2, "\n"]) &
	Debug.fprint("failtrace","- Static.elab_arglist failed.") 
	--------------------------------------
	elab_arglist (lst1,lst2) => fail *)
end





(** relation: deoverlooad
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	Debug.fprint_list("dovl",params,Types.print_type,"\n") & 
	Debug.fprint("dovl","\n===\n") &
	elab_arglist (params, args) => (args',types') &
	compute_return_type(op, types', rtype) => rtype'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype')

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	Print.print_buf "# Can't resolve type of expression: " &
	Dump.print_exp exp & Print.print_buf "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

relation compute_return_type : (Exp.Operator, Types.Type list, Types.Type) => Types.Type =

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_buf "# +: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_buf "# -: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 &
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 & Print.print_buf ",rtype " & Types.print_type rtype & 
	Print.print_buf "\n"
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Types.subtype(typ1,typ2) => true &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 & Print.print_buf ",rtype " & Types.print_type rtype & 
	Print.print_buf "\n"
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Print.print_buf "# *-: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 & Print.print_buf ",rtype " & Types.print_type rtype & 
	Print.print_buf "\n"
	----------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),[typ1,typ2],rtype) => fail

  rule	n_dims typ1 => 1 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n1 &
	dim_size(typ2,1) => n2 &
	dim_size(typ2,2) => m &
	n1 = n2 &
	element_type typ1 => etype &
	let rtype = ((Types.T_ARRAY(Types.DIM(SOME(m)),etype),NONE))
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 1 &
	dim_size(typ1,1) => n & 
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	m1 = m2 &
	element_type typ2 => etype & 
	let rtype = ((Types.T_ARRAY(Types.DIM(SOME(n)),etype),NONE))
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	dim_size(typ2,2) => p &
	m1 = m2 &
	element_type typ1 => etype &
	let rtype = ((Types.T_ARRAY(Types.DIM(SOME(n)),
				  (Types.T_ARRAY(Types.DIM(SOME(p)),etype),NONE)),NONE))
	-----------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	Print.print_buf "# *-----: Incompatible argument types " &
	Types.print_type typ1 & Print.print_buf ", " & Types.print_type typ2 & Print.print_buf ",rtype " & Types.print_type rtype & 
	Print.print_buf "\n"
	-----------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],rtype) => fail

	
  axiom compute_return_type (Exp.MUL_SCALAR_ARRAY(_),[typ1,typ2],rtype) => typ2 (*rtype*)
 
 
 
  axiom	compute_return_type (Exp.MUL_ARRAY_SCALAR(_),[typ1,typ2],rtype) => typ1(* rtype*)

  axiom	compute_return_type (Exp.DIV_ARRAY_SCALAR(_),[typ1,typ2],rtype) => typ1(* rtype*)


  axiom	compute_return_type (Exp.ADD(_),_,typ) => typ
  axiom	compute_return_type (Exp.SUB(_),_,typ) => typ
  axiom	compute_return_type (Exp.MUL(_),_,typ) => typ
  axiom	compute_return_type (Exp.DIV(_),_,typ) => typ
  axiom	compute_return_type (Exp.POW(_),_,typ) => typ
  axiom	compute_return_type (Exp.UMINUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.UPLUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.AND,_,typ) => typ
  axiom	compute_return_type (Exp.OR,_,typ) => typ
  axiom	compute_return_type (Exp.NOT,_,typ) => typ
  axiom	compute_return_type (Exp.LESS(_),_,typ) => typ
  axiom	compute_return_type (Exp.LESSEQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATER(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATEREQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.EQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.NEQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.USERDEFINED(_),_,typ) => typ
end 

relation n_dims : Types.Type => int =
	
  axiom	n_dims((Types.T_INTEGER(_),_)) => 0
  axiom	n_dims((Types.T_REAL(_),_)) => 0
  axiom	n_dims((Types.T_STRING(_),_)) => 0
  axiom	n_dims((Types.T_BOOL(_),_)) => 0

  rule	n_dims t => ns &
	int_add(ns,1) => n
	-----------------------------
	n_dims((Types.T_ARRAY(_,t),_)) => n

end

relation dim_size : (Types.Type,int) => int =

  axiom	dim_size((Types.T_ARRAY(Types.DIM(SOME(n)),_),_),1) => n

  rule	int_gt(d,1) => true &
	int_sub(d,1) => d' &
	dim_size(t,d') => n
	----------------------
	dim_size((Types.T_ARRAY(_,t),_),d) => n
end

relation element_type : Types.Type => Types.Type =
	
  axiom	element_type(t as (Types.T_INTEGER(_),_)) => t
  axiom	element_type(t as (Types.T_REAL(_),_)) => t
  axiom	element_type(t as (Types.T_STRING(_),_)) => t
  axiom	element_type(t as (Types.T_BOOL(_),_)) => t

  rule	element_type(t) => t'
	---------------------------
	element_type((Types.T_ARRAY(_,t),_)) => t'

end


(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode.
 **)

(** LS: POW added
 **)
relation operators : (Absyn.Operator, Env.Env, Types.Type, Types.Type)
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  rule	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	array_type_list(9, (Types.T_STRING([]),NONE)) => stringarrtypes &
	
	operator_return(Exp.ADD_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.ADD_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &

	operator_return(Exp.ADD_ARR(Exp.STRING), 
			stringarrtypes, 
			stringarrtypes, 
			stringarrtypes) => stringarrs &
	
	let scalars = [(Exp.ADD(Exp.INT),
			[(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
			(Types.T_INTEGER([]),NONE)),
		       (Exp.ADD(Exp.REAL),
			[(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
			(Types.T_REAL([]),NONE)),
		       (Exp.ADD(Exp.STRING),
			[(Types.T_STRING([]),NONE), (Types.T_STRING([]),NONE)],
			(Types.T_STRING([]),NONE))
		       ] &
	get_koening_operator_types("plus",env,t1,t2) => userops &
	Util.list_flatten([intarrs,realarrs,stringarrs]) => arrays &
	Util.list_flatten([scalars,arrays,userops]) => types 
	------------------------
	operators (Absyn.ADD,env,t1,t2) => types


  rule	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	
	operator_return(Exp.SUB_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.SUB_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.SUB(Exp.INT),
			[(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
			(Types.T_INTEGER([]),NONE)),
		       (Exp.SUB(Exp.REAL),
			[(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
			(Types.T_REAL([]),NONE))		  
		       ] &
	get_koening_operator_types("minus",env,t1,t2) => userops &
	Util.list_flatten([scalars,intarrs,realarrs,userops]) => types
	---------------------------
	operators(Absyn.SUB,env,t1,t2) => types

  rule	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	n_types(9, (Types.T_INTEGER([]),NONE)) => inttypes &
	n_types(9, (Types.T_REAL([]),NONE)) => realtypes &
	
	let int_mul = Exp.MUL(Exp.INT) &
	let real_mul = Exp.MUL(Exp.REAL) &
	let int_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.INT) &
	let real_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.REAL) &
	let int_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.INT) &
	let real_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.REAL) &
	
	let int_scalar = (Types.T_INTEGER([]),NONE) &
	let int_vector = (Types.T_ARRAY(Types.DIM(NONE),int_scalar),NONE) &
	let int_matrix = (Types.T_ARRAY(Types.DIM(NONE), int_vector),NONE) &
	let real_scalar = (Types.T_REAL([]),NONE) &
	let real_vector = (Types.T_ARRAY(Types.DIM(NONE),real_scalar),NONE) &
	let real_matrix = (Types.T_ARRAY(Types.DIM(NONE), real_vector),NONE) &


	let scalars = [
		       (int_mul,[int_scalar, int_scalar], int_scalar),
		       (real_mul,[real_scalar, real_scalar], real_scalar)
		       ] &


	
	let scalarprod = [
			  (int_mul_sp,[int_vector, int_vector],int_scalar),
			  (real_mul_sp,[real_vector,real_vector],real_scalar)
			  ] &
			
	let matrixprod = [
			  (int_mul_mp, [int_vector, int_matrix], int_vector),
			  (int_mul_mp, [int_matrix, int_vector], int_vector),
			  (int_mul_mp, [int_matrix, int_matrix], int_matrix),
			  (real_mul_mp,[real_vector,real_matrix],real_vector),
			  (real_mul_mp,[real_matrix,real_vector],real_vector),
			  (real_mul_mp,[real_matrix, real_matrix],real_matrix)
			  ] &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.INT), 
			inttypes, 
			intarrtypes, 
			intarrtypes) => intscalararrs &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.REAL), 
			realtypes, 
			realarrtypes, 
			realarrtypes) => realscalararrs &
	
	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.INT), 
			intarrtypes, 
			inttypes, 
			intarrtypes) => intarrsscalar &

	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.REAL), 
			realarrtypes, 
			realtypes, 
			realarrtypes) => realarrsscalar &	

	get_koening_operator_types("times",env,t1,t2) => userops &
	
	Util.list_flatten([scalars, intscalararrs, realscalararrs, intarrsscalar,
			   realarrsscalar,scalarprod,matrixprod,userops]) => types
	--------------------------------------------------------------------------
	operators(Absyn.MUL,env,t1,t2) => types

  rule	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	n_types(9, (Types.T_REAL([]),NONE)) => realtypes &
	let real_div = Exp.DIV(Exp.REAL) &
	let real_scalar = (Types.T_REAL([]),NONE) &
	let scalars = [(real_div,[real_scalar, real_scalar], real_scalar)] &

	operator_return(Exp.DIV_ARRAY_SCALAR(Exp.REAL),
			realarrtypes,
			realtypes,
			realarrtypes) => realarrscalar &
	get_koening_operator_types("divide",env,t1,t2) => userops &
	Util.list_flatten([scalars,realarrscalar,userops]) => types
	-----------------------------------------------------------
	operators(Absyn.DIV,env,t1,t2) => types

  rule	let real_scalar = (Types.T_REAL([]),NONE) &
	let int_scalar = (Types.T_INTEGER([]),NONE) &
	let real_vector = (Types.T_ARRAY(Types.DIM(NONE),real_scalar),NONE) &
	let real_matrix = (Types.T_ARRAY(Types.DIM(NONE), real_vector),NONE) &
	let real_pow = Exp.POW(Exp.REAL) &

	let scalars = [(real_pow,[real_scalar, real_scalar], real_scalar)] &

	let arrscalar = [(Exp.POW_ARR(Exp.REAL),
			  [real_matrix,int_scalar],
			  real_matrix)] &
	get_koening_operator_types("power",env,t1,t2) => userops &
	Util.list_flatten([scalars,arrscalar,userops]) => types
	-------------------------------------------------------
	operators(Absyn.POW,env,t1,t2) => types

  rule	let scalars = [(Exp.UMINUS(Exp.INT),
	       [(Types.T_INTEGER([]),NONE)],
	       (Types.T_INTEGER([]),NONE)),
	      (Exp.UMINUS(Exp.REAL),
	       [(Types.T_REAL([]),NONE)],
	       (Types.T_REAL([]),NONE))] &
	get_koening_operator_types("unaryMinus",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators (Absyn.UMINUS,env,t1,t2) => types

  rule	let scalars = [(Exp.UPLUS(Exp.INT),
	       [(Types.T_INTEGER([]),NONE)],
	       (Types.T_INTEGER([]),NONE)),
	      (Exp.UPLUS(Exp.REAL),
	       [(Types.T_REAL([]),NONE)],
	       (Types.T_REAL([]),NONE))] &
	get_koening_operator_types("unaryPlus",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.UPLUS,env,t1,t2) => types

	(**  Logical operators *) (* Not considered for overloading yet. *)

  axiom	operators(Absyn.AND,env,t1,t2)
	  => [(Exp.AND,
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))]

  axiom	operators(Absyn.OR,env,t1,t2)
	  => [(Exp.OR,
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))]

  axiom	operators(Absyn.NOT,env,t1,t2)
	  => [(Exp.NOT,
	       [(Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))]

	(**  Relational operators *)

  rule let scalars = [(Exp.LESS(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.LESS(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("less",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.LESS,env,t1,t2) => types

  rule	let scalars = [(Exp.LESSEQ(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.LESSEQ(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("lessEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.LESSEQ,env,t1,t2) => types

  rule	let scalars = [(Exp.GREATER(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.GREATER(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("greater",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.GREATER,env,t1,t2) => types

  rule	let scalars = [(Exp.GREATEREQ(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.GREATEREQ(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("greaterEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.GREATEREQ,env,t1,t2) => types

  rule	let scalars = [(Exp.EQUAL(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.EQUAL(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.EQUAL(Exp.STRING),
	       [(Types.T_STRING([]),NONE), (Types.T_STRING([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.EQUAL(Exp.BOOL),
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("equal",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.EQUAL,env,t1,t2) => types

  rule	let scalars = [(Exp.NEQUAL(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.NEQUAL(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.NEQUAL(Exp.STRING),
	       [(Types.T_STRING([]),NONE), (Types.T_STRING([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.NEQUAL(Exp.BOOL),
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("notEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.NEQUAL,env,t1,t2) => types


  rule	Print.print_buf "- operators(" & Dump.op_symbol op => s &
 	Print.print_buf s & Print.print_buf ") failed\n"
	----------------------------
	operators(op,env,t1,t2) => fail

end

(** relation: get_koening_function_types
 ** Used for userdefined function overloads.
 ** This relation will search the types of the arguments for matching function definitions 
 ** corresponding to the koening C++ lookup rule.
 ** Question: What happens if we have A.foo(x,y)? Should we search for function A.foo in
 ** scope where type of x and y are defined? Or is it an error?
 ** See also: get_koening_operator_types
 ** Note: The reason for having two relations here is that operators and functions differs a lot.
 ** Operators have fixed no of arguments, functions can both have positional and named 
 ** arguments, etc. Perhaps these two could be unified. This would require major refactoring.
 **)
relation get_koening_function_types: (Env.Env, Absyn.Path, Absyn.Exp list, Absyn.NamedArg list)
	=> Types.Type list =

  rule	elab_exp(env,e1,false,NONE) => (_,Types.PROP(t,_),_) &
	Types.get_classname(t) => p1  &
	Lookup.lookup_class(env,p1,false) => (c,f::_) &
	
	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],fn,false) => (_,f'::_) &

	Lookup.lookup_functions_in_env([f'],fn) => typelist &
	get_koening_function_types(env,fn,exps,na) => typelist2 &
	list_append(typelist,typelist2) => res
	--------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),e1::exps,na) => res 

  rule	get_koening_function_types(env,fn,exps,na) => typelist
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),e1::exps,na) => typelist
	
  rule	elab_exp(env,exp,false,NONE) => (_,Types.PROP(t,_),_) &
	Types.get_classname(t) => (p1 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p1,false) => (c,f::_) &
	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],fn,false) => (_,f'::_) &

	Lookup.lookup_functions_in_env([f'],fn) => typelist &
	get_koening_function_types(env,fn,[],na) => typelist2 &
	list_append(typelist,typelist2) => res
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),[],Absyn.NAMEDARG(id,exp)::na) 
	  => res

  rule	get_koening_function_types(env,fn,[],na) => res
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),[],_::na) => res

  axiom	get_koening_function_types(env,fn as Absyn.IDENT(_),[],[]) => []
	
  rule	Print.print_buf "# Error, koening lookup of non-simple function name, " &
	Absyn.path_string fn => fnstr & Print.print_buf fnstr & 
	Print.print_buf "\n"
	-------------------
	get_koening_function_types(env,fn as Absyn.QUALIFIED(_,_),_,_) => fail

(*  rule	Debug.fprint("failtrace", "- get_koening_function_types failed\n") 
	------------------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.QUALIFIED(_,_),_,_) => fail
*)
end
(** relation: get_koening_operator_types
 ** Used for userdefined operator overloads.
 ** This relation will search the scopes of the classes of the two 
 ** corresponding types and look for user defined operator overloaded
 ** functions, such as 'plus', 'minus' and 'times'. This corresponds
 ** to the koening C++ lookup rule.
 **)
relation get_koening_operator_types: (string, Env.Env, Types.Type, Types.Type)
	=> (Exp.Operator * Types.Type list * Types.Type) list =

  rule	(* Both types user defined *)
	Types.get_classname(t1) => (p1 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p1,false) => (c,env1) &
	get_koening_operator_types_in_scope(op,env1) => res1 &
	Types.get_classname(t2) => (p2 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p2,false) => (c,env2) &
	get_koening_operator_types_in_scope(op,env2) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* User defined types only in t2*)
	not Types.get_classname(t1) => Absyn.QUALIFIED(_,_) &
	Types.get_classname(t2) => (p2 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p2,false) => (c,env2) &
	get_koening_operator_types_in_scope(op,env2) => res
	---------------------------------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* User defined types only in t1*)
	not Types.get_classname(t2) => Absyn.QUALIFIED(_,_) &
	Types.get_classname(t1) => (p1 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p1,false) => (c,env1) &
	get_koening_operator_types_in_scope(op,env1) => res
	---------------------------------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* No User defined types at all. *)
	not Types.get_classname(t1) => Absyn.QUALIFIED(_,_) &
	not Types.get_classname(t2) => Absyn.QUALIFIED(_,_) 
	--------------------------------
	get_koening_operator_types(op,env,t1,t2) => []

  axiom	get_koening_operator_types(op,env,t1,t2) => []

end

(** relation: get_koening_operator_types_in_scope
 ** This relation is a help relation to get_koening_operator_types
 ** and it will look for functions in the current scope of the passed
 ** environment, according to the koening rule. 
**)
relation get_koening_operator_types_in_scope: (string, Env.Env) 
	  => (Exp.Operator * Types.Type list * Types.Type) list =

  rule	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],Absyn.IDENT(funcname),false) => (_,f'::_) &

	(* TODO: Fix so lookup_functions_in_env also does instantiation to get type *)
	Lookup.lookup_functions_in_env([f'],Absyn.IDENT(funcname)) => tplst &
	list_length(tplst) => tplen &
	Inst.package_prefix(f'::fs,Absyn.IDENT(funcname)) => fullfuncname &
	build_operator_types(tplst,fullfuncname) => res
	--------------------------------------------------
	get_koening_operator_types_in_scope(funcname,f::fs) => res
end

(** relation: build_operator_types
 ** This relation takes the types operator overloaded user functions and
 ** builds  the type list structure suitable for the deoverload relation. 
**)
relation build_operator_types: (Types.Type list,Absyn.Path) 
	  => (Exp.Operator * Types.Type list * Types.Type) list =

  axiom	build_operator_types([],_) => []

  rule	Util.list_map(args,Util.tuple2_2) => argtypes &
	build_operator_types(tps,funcname) => rest
	------------------------------------
	build_operator_types((Types.T_FUNCTION(args,tp),_)::tps,funcname) 
	  => ((Exp.USERDEFINED(funcname),argtypes,tp)::rest) 
end

relation n_dim_array : (int, Types.Type) => Types.Type =

  axiom	n_dim_array (0, t) => t

  rule	int_sub(n,1) => n' &
	n_dim_array (n',t) => t'
	------------------------
	n_dim_array (n, t) => ((Types.T_ARRAY(Types.DIM(NONE),t'),NONE))

end
relation n_types : (int, Types.Type) => Types.Type list =

  axiom	n_types (0,_) => []

  rule	int_sub(n,1) => n' & 
	n_types(n',t) => l
	-----------------------
	n_types (n, t) => t::l

end

relation operator_return : (Exp.Operator, 
			    Types.Type list, 
			    Types.Type list, 
			    Types.Type list) 
	  =>  (Exp.Operator * Types.Type list * Types.Type) list =

  axiom operator_return (_,[],[],[]) => []

  rule	operator_return (op, lr, rr, rer) => rest & 
	let t = (op,[l,r],re)
	---------------------------------------
	operator_return (op, l::lr, r::rr, re::rer) => t::rest

end

relation array_type_list : (int, Types.Type) => Types.Type list =
  
  axiom array_type_list (0,_) => []

  rule	int_sub(n,1) => n' &
	n_dim_array(n,t) => f &
	array_type_list (n', t) => r
	-----------------------------
	array_type_list (n, t) => f::r


end
