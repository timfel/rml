(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 connect.rml
 ** module:      Connect
 ** description: Connection set management
 **
 ** RCS: $Id: connect.rml,v 1.29 2004/09/28 06:27:43 kajny Exp $
 **
 ** Connections generate connection sets (datatype SET is described below)
 ** which are constructed during instantiation.  When a connection 
 ** set is generated, it is used to create a number of equations. 
 ** The kind of equations created depends on the type of the set. 
 ** 
 ** Connect.rml is called from inst.rml and is responsible for 
 ** creation of all connect-equations later passed to the DAE module 
 ** in dae.rml.
 ** 
 **)

module Connect :

  with "exp.rml"
  with "staticexp.rml"
  with "dae.rml"
  with "env.rml"

  datatype Face = INNER | OUTER
  (** This type indicates whether a connector is an inner or an outer
   ** connector.  *)

  datatype Set = EQU of Exp.ComponentRef list
	       | FLOW of (Exp.ComponentRef * Face) list

  type Sets = Set list
  (** A connection set is represented using the `Set' type. *)

  relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets
  relation add_array_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef, int) => Sets
  relation add_flow : (Sets,
		       Exp.ComponentRef, Face,
		       Exp.ComponentRef, Face) => Sets
  relation print_sets : Sets => ()
  relation equations : Sets => DAE.Element list
  relation unconnected_flow_equations : (Sets, DAE.Element list, Env.Env,bool (* CallingScope*)) 
	  => DAE.Element list
end


(**
 ** - Adding
 **
 ** The two relations `add_eq' and `add_flow' addes a variable to a
 ** connection set.  The first relation is used to add a non-flow
 ** variable, and the second is used to add a flow variable.  When
 ** two component are to be added to a collection of connection sets,
 ** the connections sets containg the components have to be located.
 ** If no such set exists, a new set containing only the new component
 ** is created.
 **
 ** If the connection sets containing the two components are not the
 ** same, they are merged.
 **)

relation add_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef) => Sets =

  rule	find_equ_set(ss,r1) => s1 &
	find_equ_set(ss,r2) => s2 &
	merge(ss,s1,s2) => ss'
	----------------------
	add_equ(ss,r1,r2) => ss'
	
end

(**)

relation add_flow : (Sets, Exp.ComponentRef, Face, Exp.ComponentRef, Face)
	  => Sets =

  rule	find_flow_set(ss,r1,d1) => s1 &
	find_flow_set(ss,r2,d2) => s2 &
	merge(ss,s1,s2) => ss'
	----------------------
	add_flow(ss,r1,d1,r2,d2) => ss'
	
end


(* For connecting two arrays, an equal equation for each index should be generated.*)

relation add_array_equ : (Sets, Exp.ComponentRef, Exp.ComponentRef, int) => Sets =

  axiom	add_array_equ(s,_,_,0) => s

  rule	Exp.subscript_cref(r1,[Exp.INDEX(Exp.ICONST(i))]) => r1' &
	Exp.subscript_cref(r2,[Exp.INDEX(Exp.ICONST(i))]) => r2' &
	int_sub(i,1) => i' &
	find_equ_set(ss,r1') => s1 &
	find_equ_set(ss,r2') => s2 &
	merge(ss,s1,s2) => ss' &
	add_array_equ(ss',r1,r2,i') => ss''	
	----------------------
	add_array_equ(ss,r1,r2,i) => ss''
end


(**
 ** - Equation generation
 **)

(** relation: equations
 **
 ** From a number of connection sets, this relation generates a list
 ** of equations.
 **)

relation equations : Sets => DAE.Element list =

  axiom	equations [] => []

  rule	equ_equations cs => dae1 &
	equations ss => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations EQU(cs)::ss => dae

  rule	flow_equations cs => dae1 &
	equations ss => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	equations FLOW(cs)::ss => dae

end

(** relation: equ_equations
 ** 
 ** A non-flow connection set contains a number of components.
 ** Generating the equation from this set means equating all the
 ** components.  For n components, this will give n-1 equations.
 **
 ** For example, if the set contains the components `x', `y.a' and
 ** `z.b', the equations generated will me `x = y.a' and `y.a = z.b'.
 **)

relation equ_equations : Exp.ComponentRef list => DAE.Element list =

  axiom	equ_equations [_] => []

  rule	equ_equations (y::cs) => eq
	------------------------
	equ_equations x::y::cs
	  => DAE.EQUATION(Exp.CREF(x,Exp.OTHER), Exp.CREF(y,Exp.OTHER))::eq
end

(** relation: flow_equations
 ** 
 ** Generating equations from a flow connection set is a little
 ** trickier that from a non-flow set.  Only one equation is
 ** generated, but it has to consider whether the comoponents were
 ** inner or outer connectors.
 **
 ** This relation uses `flow_sum' to create the sum of all components
 ** (some of which will be negated), and the returns the equation
 ** where this sum is equal to 0.0.
 **)

relation flow_equations : (Exp.ComponentRef * Face) list => DAE.Element list =

  rule	flow_sum cs => sum
	------------------
	flow_equations cs => [DAE.EQUATION(sum, Exp.RCONST(0.0))]

end

(** relation: flow_sum
 ** 
 ** This relation creates an exression expressing the sum of all
 ** components in the given list.  Before adding the component to the
 ** sum, it is passed to `sign_flow' which will negate all outer
 ** connectors.
 **)

relation flow_sum : (Exp.ComponentRef * Face) list => Exp.Exp =

  rule	sign_flow(c,f) => exp
	-------------------
	flow_sum [(c,f)] => exp

  rule	sign_flow(c,f) => exp1 &
	flow_sum cs => exp2
	------------------
	flow_sum ((c,f)::cs) => Exp.BINARY(exp1, Exp.ADD(Exp.REAL), exp2)

end

(** relation: sign_flow
 **
 ** This relation takes a name of a component and a `Face', returns an
 ** expression.  If the face is `INNER' the expression simply contains
 ** the component reference, but if it is `OUTER', the expression is
 ** negated.
 **)

relation sign_flow : (Exp.ComponentRef, Face) => Exp.Exp =

  axiom	sign_flow (c,INNER) => Exp.CREF(c,Exp.OTHER)
  axiom	sign_flow (c,OUTER) => Exp.UNARY(Exp.UMINUS(Exp.REAL),Exp.CREF(c,Exp.OTHER))

end

(**
 ** - Lookup
 ** 
 ** These relations are used to find and create connection sets.
 **)

(** relation: find_equ_set
 **
 ** This relation finds a non-flow connection set that contains the
 ** component named by the second argument.  If no such set is found,
 ** a new set is created.
 **)

relation find_equ_set : (Sets, Exp.ComponentRef) => Set =

  rule	new_equ_set c => s
	------------------
	find_equ_set([],c) => s

  rule	find_in_set(s,c)
	----------------
	find_equ_set(s::_,c) => s

  rule	find_equ_set(ss,c) => s
	-------------------
	find_equ_set(_::ss,c) => s

end	

(** relation: find_flow_set
 **
 ** This relation finds a flow connection set that contains the
 ** component named by the second argument.  If no such set is found,
 ** a new set is created.
 **)

relation find_flow_set : (Sets, Exp.ComponentRef, Face) => Set =

  rule	new_flow_set(c,d) => s
	------------------
	find_flow_set([],c,d) => s

  rule	find_in_set(s,c)
	----------------
	find_flow_set(s::_,c,d) => s

  rule	find_flow_set(ss,c,d) => s
	-------------------
	find_flow_set(_::ss,c,d) => s

end	

(** relation: find_in_set
 ** 
 ** This relation checks if a componet already appears in a given
 ** connection set.
 **)

relation find_in_set : (Set, Exp.ComponentRef) => () =

  rule	find_in_set_equ(cs,c)
	---------------------
	find_in_set(EQU(cs), c)

  rule	find_in_set_flow(cs, c)
	-----------------------
	find_in_set(FLOW(cs), c)

end

(** relation: find_in_set_equ
 ** 
 ** This is a version of `find_in_set' which is specialized on
 ** non-flow connection sets
 **)

relation find_in_set_equ : (Exp.ComponentRef list, Exp.ComponentRef) => () =

  rule	Static.eq_cref(c1,c2)
	------------------
	find_in_set_equ(c1::_,c2)

  rule	find_in_set_equ(cs,c2)
	----------------------
	find_in_set_equ(_::cs,c2)

end

(** relation: find_in_set_flow
 ** 
 ** This is a version of `find_in_set' which is specialized on
 ** flow connection sets
 **)

relation find_in_set_flow : ((Exp.ComponentRef * Face) list, Exp.ComponentRef)
	  => () =

  rule	Static.eq_cref(c1,c2)
	------------------
	find_in_set_flow((c1,_)::_,c2)

  rule	find_in_set_flow(cs,c2)
	----------------------
	find_in_set_flow(_::cs,c2)

end

(** relation: new_equ_set
 **
 ** This relation creates a new non-flow connection set containing
 ** only the given component.
 **)

relation new_equ_set : Exp.ComponentRef => Set =

  axiom	new_equ_set c => EQU([c])

end

(** relation: new_flow_set
 **
 ** This relation creates a new-flow connection set containing only
 ** the given component.
 **)

relation new_flow_set : (Exp.ComponentRef, Face) => Set =

  axiom	new_flow_set(c,d) => FLOW([(c,d)])

end

(**
 ** - Merging
 ** 
 ** The result of merging two connection sets is the intersection of
 ** the two sets.
 **)

relation merge : (Sets, Set, Set) => Sets =

  rule	s1 = s2
	-------
	merge(ss,s1,s2) => ss

  rule	list_append(cs1,cs2) => cs &
	remove_set2(ss,s1,s2) => ss'
	----------------------------
	merge(ss, s1 as EQU(cs1), s2 as EQU(cs2)) => EQU(cs)::ss'

  rule	list_append(cs1,cs2) => cs &
	remove_set2(ss,s1,s2) => ss'
	----------------------------
	merge(ss, s1 as FLOW(cs1), s2 as FLOW(cs2)) => FLOW(cs)::ss'

end

(** relation: remove_set2
 ** 
 ** This relation removes the two sets given in the second and third
 ** argument from the collection of sets given in the first argument.
 **)

relation remove_set2 : (Sets, Set, Set) => Sets =

  axiom	remove_set2([],_,_) => []

  rule	s = s1 &
	remove_set(ss,s2) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => ss'
	
  rule	s = s2 &
	remove_set(ss,s1) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => ss'
	
  rule	remove_set2(ss,s1,s2) => ss'
	------------------------
	remove_set2(s::ss, s1, s2) => s::ss'

end

(** relation: remove_set
 **
 ** This relation removes one set from a list of sets.
 **)

relation remove_set : (Sets, Set) => Sets =

  axiom	remove_set([],_) => []

  rule	s = s1
      	------
      	remove_set(s::ss, s1) => ss
      
  rule	remove_set(ss,s1) => ss'
      	------------------------
      	remove_set(s::ss, s1) => s::ss'
	
end

(* Unconnected flow variables. *)

(** relation: unconnected_flow_equations 
 **
 ** This relation will generate set-to-zero equations for INNER flow variables.
 ** It can not generate for outer flow varaibles, since we do not yet know if 
 ** these are connected or not. This is only known in the preceding recursive 
 ** call. However, the top call must generate for both inner and outer 
 ** connectors, hence the last argument, true for top call*)

relation unconnected_flow_equations : (Sets, DAE.Element list, Env.Env,bool) => DAE.Element list =

  rule	(* if outermost call look at both inner and outer unconnected connectors *)
	Env.local_outside_connector_flowvars(env) => v1 &
	Env.local_inside_connector_flowvars(env) => v2 &
	list_append(v1,v2) => vars &
	get_all_flow_variables(csets) => vars2 &
	remove_variables(vars,vars2) => unconnectedvars &
	generate_zeroflow_equations(unconnectedvars) => dae'
	----------------------------------
	unconnected_flow_equations(csets,dae,env,true) => dae'

	(* If not outermost call, only look at unconnected inner connectors *)
  rule	Env.local_inside_connector_flowvars(env) => vars &
 	get_all_flow_variables(csets) => vars2 &
 	Print.print_buf "vars : " &
	Util.list_map(vars,Exp.print_component_ref_str) => str &
	Util.string_delimit_list(str, ",") => str'  &
 	Print.print_buf "\nvars2 (to remove) : " &
	Util.list_map(vars2,Exp.print_component_ref_str) => str &
	Util.string_delimit_list(str, ",") => str'  &
	Print.print_buf str' &
	Print.print_buf "\n" &
	remove_variables(vars,vars2) => unconnectedvars &
 	generate_zeroflow_equations(unconnectedvars) => dae'
	----------------------------------
	 unconnected_flow_equations(csets,dae,env,true) => dae'

  rule	(*Debug.fprint("failtrace","-unconnected_flow_equations failed\n") *)
	----------------------------------
	unconnected_flow_equations(csets,dae,env,_) => []
end

relation remove_variables: (Exp.ComponentRef list, Exp.ComponentRef list) 
	  => Exp.ComponentRef list =
  axiom	remove_variables(vars,[]) => vars 

  rule	remove_variable(r1,vars) => vars' &
	remove_variables(vars',removelist) => res
	-----------------------------------------
	remove_variables(vars,r1::removelist) => res
end
relation remove_variable: (Exp.ComponentRef, Exp.ComponentRef list) 
	  => Exp.ComponentRef list =

  axiom	remove_variable(cr,[]) => [] 

  rule	Exp.cref_equal(cr,cr2) => true
	------------------------------
	remove_variable(cr,cr2::xs) => xs

  rule	remove_variable(cr,xs) => res
	------------------------------
	remove_variable(cr,cr2::xs) => cr2::res
end

relation generate_zeroflow_equations: Exp.ComponentRef list 
	  => DAE.Element list =
  axiom	generate_zeroflow_equations ([]) => []

  rule	generate_zeroflow_equations(xs) => res 
	--------------------------------------
	generate_zeroflow_equations(cr::xs) 
	  => DAE.EQUATION(Exp.CREF(cr,Exp.REAL),Exp.RCONST(0.0))::res
end


relation get_all_flow_variables: Sets => Exp.ComponentRef list =

  axiom	get_all_flow_variables [] => []

  rule	Util.list_map(varlst,Util.tuple2_1) => res1 &
	get_all_flow_variables(xs) => res2 &
	list_append(res1,res2) => res
	---------------------------------- 
	get_all_flow_variables(FLOW(varlst)::xs) => res 

  rule	get_all_flow_variables(xs) => res 
	---------------------------------- 
	get_all_flow_variables(EQU(res1)::xs) => res 
end

relation get_inner_flow_variables: Sets => Exp.ComponentRef list =

  axiom	get_inner_flow_variables([]) => []

  rule	get_inner_flow_variables_2(vars) => res1 &
	get_inner_flow_variables(xs) => res2 &
	list_append(res1,res2) => res
	---------------------------------- 
	get_inner_flow_variables(FLOW(vars)::xs) => res 

  rule	get_inner_flow_variables(xs) => res
	---------------------------------- 
	get_inner_flow_variables(EQU(_)::xs) => res 

  rule	(*Debug.fprint("failtrace","-get_inner_flow_variables failed\n")*)
	----------------------------------
	get_inner_flow_variables(_) => fail 
end

relation get_inner_flow_variables_2: (Exp.ComponentRef * Face) list 
	  => Exp.ComponentRef list =

  axiom	get_inner_flow_variables_2 ([]) => []

  rule	get_inner_flow_variables_2(xs) => res
	-------------------------------------
	get_inner_flow_variables_2( (cr,INNER)::xs) => cr::res

  rule	get_inner_flow_variables_2(xs) => res
	-------------------------------------
	get_inner_flow_variables_2( _::xs) => res

  rule	(*Debug.fprint("failtrace","-get_inner_flow_variables_2 failed\n")*)
	----------------------------------
	get_inner_flow_variables_2(_) => fail 
end


(**
 ** - Printing
 **
 ** These are a few relations used for printing a description of the
 ** connection sets.  The implementation is excluded from the report
 ** for brevity.
 **)

(*!ignorecode*)

with "dump.rml"
with "print.rml"
with "util.rml"
with "debug.rml"

(** relation: print_sets
 **
 ** Prints a description of a number of connection sets to the
 ** standard output.
 **)

relation print_sets : Sets => () =

  axiom	print_sets []

  rule	print_set x &
	print_sets xs
	------------
	print_sets x::xs

end
(**)
relation print_set : Set => () =

  rule	Print.print_buf " non-flow set: { " &
	Exp.print_list(cs, Exp.print_component_ref, ", ") &
	Print.print_buf " }\n"
	----------------------------------------------------
	print_set EQU(cs)

  rule	Print.print_buf " flow set: { " &
	Exp.print_list(cs, print_flow_ref, ", ") &
	Print.print_buf " }\n"
	----------------------------------------------------
	print_set FLOW(cs)

end
(**)
relation print_flow_ref : (Exp.ComponentRef * Face) => () =

  rule	Exp.print_component_ref c &
	Print.print_buf " INNER"
	-----------
	print_flow_ref((c,INNER))

  rule	Exp.print_component_ref c &
	Print.print_buf " OUTER"
	-----------
	print_flow_ref((c,OUTER))

end

(*!includecode*)
