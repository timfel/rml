(*
    Copyright PELAB, Linkoping University
 
    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 graphviz.rml
 ** module:      Graphviz
 ** description: Graphviz is a tool for drawing graphs from a textual
 ** representation. This module generates the textual input to graphviz from a
 ** tree defined using the data structures defined here, e.g. Node for tree
 ** nodes. See http://www.research.att.com/sw/tools/graphviz/ .
 **
 ** Input: The tree constructed from data structures in Graphviz
 ** Output: Textual input to graphviz, written to stdout.
 **
 ** RCS: $Id: graphviz.rml,v 1.8 2004/09/28 08:48:30 kajny Exp $
 **
 **)


module Graphviz:

  type Type = string
  type Ident = string
  type Label = string

  datatype Node = NODE of Type
                        * Attributes 
                        * Children
                | LNODE of Type
			* Label list
			* Attributes
			* Children


  type Children = Node list

  type Attributes = Attribute list

  datatype Attribute = ATTR of string (* name *) 
                             * string (* value *)

  relation dump : Node => ()

  val box : Attribute

end


val box = ATTR("shape","box")



(* Relations *)

relation dump : Node => () =
	
  rule	print "graph AST {\n" &
	dump_node node => nm &
	print "}\n"
	----------------
	dump node => ()

end


relation dump_node : Node => Ident =
	
  rule	nodename typ => nm &
	make_label [typ] => typlbl &
	list_append([ATTR("label", typlbl)], attr) => newattr &
	make_node(nm, newattr) => out &
	print out &
	dump_children(nm, children)
	---------------------------
	dump_node (NODE(typ, attr, children)) => nm


  rule	nodename typ => nm &
	list_append ([typ], lbl) => lbl' &
	make_label lbl' => lblstr &
	list_append([ATTR("label", lblstr)], attr) => newattr &
	make_node(nm, newattr) => out &
	print out &
	dump_children(nm, children)
	---------------------------
	dump_node (LNODE(typ, lbl, attr, children)) => nm

end


relation make_label: string list => string =

  rule	make_label_req(sl) => s0 &
	string_append("\"",s0) => s1 &
	string_append(s1, "\"") => s2
	------------------------------
	make_label sl => s2

end

relation make_label_req: string list => string =

  axiom	make_label_req [s] => s

  rule	string_append(s1,"\\n") => s &
	string_append(s,s2) => res
	-------------------
	make_label_req [s1,s2] => res

  rule	make_label_req rest => old &
	string_append(s1,"\\n") => s &
	string_append(s,old) => res
	-------------------
	make_label_req s1::rest => res

end



relation dump_children : (Ident, Children) => () =

  axiom dump_children (_, []) => ()

  rule	dump_node node => nm &
	print_edge(nm, parent) &
	dump_children(parent, rest)
	---------------------------
	dump_children(parent, node::rest)
end


(* changed use of str as part of nodename, since it may contain spaces
*)
relation nodename : string => string =

  rule	tick => i & int_string i => is & string_append("GVNOD",is) => s
	-----------------------------------------------------------------
	nodename str => s
end


relation print_edge : (Ident, Ident) => () =

  rule	make_edge(n1,n2) => str &
	print str & print ";\n"
	-----------------------
	print_edge(n1,n2)
end


relation make_edge : (Ident, Ident) => string =

  rule	string_append(n1, " -- ") => s &
	string_append(s, n2) => str
	---------------------------
	make_edge (n1, n2) => str

end


relation make_node : (Ident, Attributes) => string =

  rule	make_attr attr => s &
	string_append(nm, s) => s' &
	string_append(s', ";") => str
	-----------------------------
	make_node (nm, attr) => str

end


relation make_attr : Attribute list => string = 

  rule	make_attr_req l => res &
	string_append ("[", res) => s &
	string_append (s, "]") => str
	----------------------------
	make_attr l => str

end


relation make_attr_req : Attribute list => string =

  rule	string_append(name,"=") => s &
	string_append(s, v) => str
	---------------------------
	make_attr_req [ATTR(name,v)] => str


  rule  make_attr_req(rest) => old &
	string_append(name,"=") => s &
	string_append(s,v) => s' &
	string_append(s',",") => s'' &
	string_append(s'', old) => str
	---------------------------
	make_attr_req(ATTR(name,v)::rest) => str

end