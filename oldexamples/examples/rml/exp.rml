(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 exp.rml
 ** module:      Exp
 ** description: Expressions
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing expressions, after they have been examined by the
 ** static analyzer in the module `StaticExp'.  There are of course
 ** great similarities with the expression types in the `Absyn'
 ** module, but there are also several important differences.
 **
 ** No overloading of operators occur, and subscripts have been
 ** checked to see if they are slices.  All expressions are also type
 ** consistent, and all implicit type conversions in the AST are made
 ** explicit here.
 **
 ** Some expression simplification and solving is also done here. This is used
 ** for symbolic transformations before simulation, in order to rearrange
 ** equations into a form needed by simulation tools. simplify, solve,
 ** exp_contains, exp_equal are part of this code.
 **
 ** This module also contains relations for printing expressions, to io or to
 ** strings. Also graphviz output is supported.
 **)

module Exp:

  with "absyn.rml"
  with "graphviz.rml"


  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  (** - Basic types *)
  datatype Type = INT | REAL | BOOL | STRING | ENUM | OTHER 
  (** These types are not used as expression types (see the `Types'
   ** module for expression types).  They are used to parameterize
   ** operators which may work on several simple types. *)

  (** - Expressions *)
  datatype Exp = ICONST of int					(* Integer constants *)
	       | RCONST of real					(* Real constants *)
	       | SCONST of string				(* String constants *)
	       | BCONST of bool					(* Bool constants *)
	       | CREF of ComponentRef * Type			(* component references, e.g. a.b[2].c[1] *)
	       | BINARY of Exp * Operator * Exp			(* Binary operations, e.g. a+4 *)
	       | UNARY of Operator * Exp			(* Unary operations, -(4*x) *)
	       | LBINARY of Exp * Operator * Exp		(* Logical binary operations: and, or *)
	       | LUNARY of Operator * Exp			(* Logical unary operations: not *)
	       | RELATION of Exp * Operator * Exp		(* Relation, e.g. a <= 0 *)
	       | IFEXP of Exp * Exp * Exp			(* If expressions *)
	       | CALL of Absyn.Path * Exp list * bool (* tuple *) * bool (* builtin *) (* Function call *)
	       | ARRAY of Type * bool * Exp list		(* Array constructor, e.g. {1,3,4} *)
	       | MATRIX of Type * int * (Exp*bool) list	list	(* Matrix constructor. e.g. [1,0;0,1] *)
	       | RANGE of Type * Exp * Exp option * Exp		(* Range constructor, e.g. 1:0.5:10 *)
	       | TUPLE of Exp list (*PR.*)			(* Tuples, used in func calls returning several 
								  arguments *)
                 (* New constructors *)
	       | CAST of Type * Exp				(* Cast operator *)
	       | ASUB of Exp * int				(* Array subscripts *)
               | SIZE of Exp * Exp option			(* The size operator *)
	       | CODE of Absyn.Code * Type			(* Modelica AST constructor *)
	       | REDUCTION of Absyn.Path * Exp (*expr*) * Ident * Exp (*range*)  (* Reduction expression *)
	       | END						(* array index to last element, e.g. a[end]:=1; *)
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp'
   ** datatype, but is used for statically analyzed expressions.  It
   ** includes explicit type promotions and typed (non-overloaded)
   ** operators. It also contains expression indexing with the `ASUB'
   ** constructor.  Indexing arbitrary array expressions is currently
   ** not supported in Modelica, but it is needed here. *)
  (** LS: Added size for external function interface **)

  datatype Operator = ADD    	  of Type
		    | SUB    	  of Type
		    | MUL    	  of Type
		    | DIV    	  of Type
		    | POW    	  of Type
		    | UMINUS 	  of Type
		    | UPLUS  	  of Type
		    | UMINUS_ARR  of Type
		    | UPLUS_ARR   of Type
		    | ADD_ARR     of Type
		    | SUB_ARR     of Type
		    | MUL_SCALAR_ARRAY of Type   (* a * { b, c }            *)
		    | MUL_ARRAY_SCALAR of Type   (* {a, b} * c              *)
		    | MUL_SCALAR_PRODUCT of Type (* {a, b} * {c, d}         *)
		    | MUL_MATRIX_PRODUCT of Type (* {{..},..} * {{..},{..}} *)
		    | DIV_ARRAY_SCALAR of Type   (* {a, b} / c              *)
		    | POW_ARR     of Type
		    | AND | OR
		    | NOT
		    | LESS        of Type
		    | LESSEQ      of Type
		    | GREATER     of Type
		    | GREATEREQ   of Type
		    | EQUAL       of Type
		    | NEQUAL      of Type
		    | USERDEFINED of Absyn.Path (* The FQ name of the overloaded operator function *)
  (** Operators which are overloaded in the abstract syntax are here
   ** made type-specific.  The integer addition operator (`ADD(INT)')
   ** and the real addition operator (`ADD(REAL)') are two distinct
   ** operators. *)

  (** - Componebnt references *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Subscript = WHOLEDIM     (* a[:,1] *)
		     | SLICE of Exp (* a[1:3,1], a[1:2:10,2] *)
		     | INDEX of Exp
  (** The `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Absyn' module. *)

  (** - Exported relations *)

  relation is_range : Exp => bool
  relation is_zero: Exp => bool 

  relation prepend_string_cref : (string, ComponentRef) => ComponentRef
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation subscript_cref: (ComponentRef, Subscript list) => ComponentRef	  
  relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef
  relation int_subscripts : int list => Subscript list
  relation simplify : Exp => Exp
  relation unelab_exp : Exp => Absyn.Exp 	   
  relation contain_functioncall : Exp => bool
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_component_ref_str : ComponentRef => string
  relation print_subscript: Subscript => ()
  relation print_subscript_str: Subscript => string

  relation print_leftpar_str : (int,int) => (string, int) 
  relation print_rightpar_str : (int,int) => string 
  relation binop_symbol : Operator => string
  relation binop_priority : Operator => int 
  relation lbinop_symbol : Operator => string
  relation lbinop_priority : Operator => int
  relation unaryop_priority : Operator => int 
  relation lunaryop_priority : Operator => int 
  relation relop_priority : Operator => int 
  relation print_row_str : (Exp*bool) list => string 



  relation print_list : ('a list, 'a => (), string) => ()
  relation cref_equal : (ComponentRef, ComponentRef) => bool
  relation cref_str : ComponentRef => string
  relation cref_to_path : ComponentRef => Absyn.Path
  relation cref_modelica_str : ComponentRef => string
  relation print_list_str : ('a list, 'a => string, string) => string
  relation print_exp_str : Exp => string
  relation to_exp_cref : Absyn.ComponentRef => ComponentRef
  relation exp_equal: (Exp,Exp) => bool
  relation replace_exp: (Exp (*expr*), Exp(* source expr*),Exp(*target expr*)) 
	  => (Exp,int)
  relation replace_exp_list: (Exp (*expr*), Exp list (* source list*), Exp list (* target list*))
	  => (Exp,int)
  relation stringify_crefs: (Exp) => Exp
  relation stringify_component_ref: ComponentRef => ComponentRef 
  relation binop_symbol_1 : Operator => string 
  relation unaryop_symbol : Operator => string 
  relation lunaryop_symbol : Operator => string 
  relation relop_symbol : Operator => string 
  relation dump_exp_graphviz : Exp => Graphviz.Node
  relation exp_contains : (Exp, Exp) => bool
  relation solve : (Exp, Exp, Exp) => Exp
  relation get_cref_from_exp: (Exp) => ComponentRef list	  
end


with "rtopts.rml"
with "util.rml"
with "print.rml"
with "modutil.rml"
with "derive.rml"
with "system.rml" 
with "dump.rml"

val rconstone = RCONST(1.0)


(** relation: cref_to_path
 **
 ** This relation converts a `ComponentRef' to a `Path', if possible.
 ** If the component reference contains subscripts, it will silently
 ** fail.
 **)

relation cref_to_path : ComponentRef => Absyn.Path =

  axiom	cref_to_path CREF_IDENT(i,[]) => Absyn.IDENT(i)

  rule	cref_to_path c => p
	-------------------
	cref_to_path CREF_QUAL(i,[],c) => Absyn.QUALIFIED(i,p)

end

(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)

relation cref_str: ComponentRef => string =

  axiom	cref_str(CREF_IDENT(s,_)) => s
  
  rule	cref_str(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	cref_str(CREF_QUAL(s,_,n)) => ss
end

(* As above but uses '_' instead of '.' *)
relation cref_modelica_str : ComponentRef => string =
  axiom	cref_modelica_str(CREF_IDENT(s,_)) => s
  
  rule	cref_modelica_str(n) => ns &
	string_append(s,"_") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	cref_modelica_str(CREF_QUAL(s,_,n)) => ss
end

relation is_range : Exp => bool =

  axiom	is_range RANGE(_,_,_,_) => true
  axiom	is_range _ => false

end

(** relation: is_zero
 **
 ** Returns true íf an expression is constant and has the value zero, 
 ** otherwise false
 **)
relation is_zero: Exp => bool =

  rule	int_eq(ival,0) => true
	----------------------
	is_zero(ICONST(ival)) => true

  rule	(* Due to bug in rml, go trough a cast from int *)
	int_real(0) => rzero &
	real_eq(rzero,rval) => true 
	---------------------------
	is_zero(RCONST(rval)) => true

  rule	(* Casting to zero is still zero *)
	is_zero(e) => res 
	------------------
	is_zero(CAST(t,e)) => res

  axiom	is_zero(_) => false

end

(** LS:
 ** Replace this with a call to print_component_ref_str
 ** and comparison of the resulting strings, after the _str relations are 
 ** working
 **)

relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef =

  axiom	join_crefs ( CREF_IDENT(id,sub),cr2) => CREF_QUAL(id,sub,cr2)
	
  rule	join_crefs(cr,cr2) => cr'
	------------------------
	join_crefs (CREF_QUAL(id,sub,cr),cr2) => CREF_QUAL(id,sub,cr')
end 
relation cref_equal : (ComponentRef, ComponentRef) => bool =

	(** IGNORES subscript list (indexes) for now. Too complex **)
	(** Another option is to call print_component_ref_str for both refs and *)
	(** compare the resulting strings *)

  rule	n1 = n2 &
	subscript_equal(idx1,idx2) => true
	-------
	cref_equal (CREF_IDENT(n1, idx1), CREF_IDENT(n2, idx2)) => true

  rule	n1 = n2 &
	cref_equal (cr1, cr2) => true &
	subscript_equal(idx1,idx2) => true 
	-----------------------------
	cref_equal (CREF_QUAL(n1, idx1, cr1), CREF_QUAL(n2, idx2, cr2))
	  => true

  rule	(* There is a bug here somewhere or in RML.
	 * Therefore as a last resort, print the strings and compare.
	 **)
 	print_component_ref_str cr1 => s1 &
	print_component_ref_str cr2 => s2 &
	s1 = s2
	------------------------
	cref_equal(cr1,cr2) => true

  axiom	cref_equal (_, _) => false

end

relation subscript_equal: ( Subscript list, Subscript list) => bool =
	(* P.A: Just compare constant integer values for now. Might need to lookup variables
	   in environment for evaluating arbitrary expressions in future impl. *)
  rule	int_eq(i1,i2) => true &
	subscript_equal(xs1,xs2) => res 
	-------------------------------
	subscript_equal(INDEX(ICONST(i1))::xs1,INDEX(ICONST(i2))::xs2) => res

  axiom	subscript_equal([],[]) => true

  axiom	subscript_equal( _,_) => false
end

relation prepend_string_cref : (string, ComponentRef) => ComponentRef =

  rule	string_append (p, i) => i'
	------------------------------
	prepend_string_cref (p, CREF_QUAL(i, s, c)) => CREF_QUAL(i',s,c)

  rule	string_append (p, i) => i'
	--------------------------
	prepend_string_cref (p,CREF_IDENT(i, s)) => CREF_IDENT(i',s)

end	

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end
(** relation: subscript_cref
 **
 ** The 'subscript_cref' relation adds a subscript to the 'ComponentRef'
 ** For instance 'a.b' with subscript 10 becomes 'a.b[10] and 'c.d[1,2] with subscript 
 ** 3,4 becomes 'c.d[1,2,3,4]' 
 **)
relation subscript_cref: (ComponentRef, Subscript list) => ComponentRef	=

  rule	list_append(sub,newsub) => newsub'
	-----------------------------------
	subscript_cref (CREF_IDENT(id,sub),newsub) => CREF_IDENT(id,newsub')

  rule	subscript_cref(cref,newsub) => cref'
	-----------------------------------
	subscript_cref (CREF_QUAL(id,sub,cref),newsub) => CREF_QUAL(id,sub,cref')
end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

(** relation: int_subscripts
 **
 ** This relation describes the relation between a list of integers
 ** and a list of `Exp.Subscript' where each integer is converted to
 ** an integer indexing expression.
 **)

relation int_subscripts : int list => Subscript list =

  axiom	int_subscripts [] => []

  rule	int_subscripts xs => xs'
	------------------------
	int_subscripts x::xs => INDEX(ICONST(x))::xs'

end

(** relation: simplify
 **
 ** This relation does some very basic simplification on expressions.
 ** It is not intended to be used to simplify expressions provided by
 ** the model, but to simplify unnecessarily complex expressions
 ** constructed during instantiation. 
 ** PA. Added rules for binary, unary operations
 ** and multiplication with zero, addition with zero, etc. Useful when deriving 
 ** equations and then want to simplify
 **)

relation simplify : Exp => Exp =

	(* a+(-b) and (-b)+a *)
  rule	simplify(BINARY(e1,SUB(tp),e2)) => e
	-------------------
	simplify (BINARY(e1,ADD(tp),UNARY(UMINUS(tp2),e2))) => e

  rule	simplify(BINARY(e1,SUB(tp),e2)) => e
	-------------------
	simplify (BINARY(UNARY(UMINUS(tp2),e2),ADD(tp),e1)) => e

  rule	(* a/b/c => (a*c)/b) *)
	simplify(BINARY(BINARY(e1,MUL(tp),e3),DIV(tp2),e2)) => e
	-------------------
	simplify (BINARY(e1,DIV(tp),BINARY(e2,DIV(tp2),e3))) => e

  rule	(* (a/b)/c => a/(b*c)) *)
	simplify(BINARY(e1,DIV(tp2),BINARY(e2,MUL(tp),e3))) => e
	-------------------
	simplify (BINARY(BINARY(e1,DIV(tp2),e2),DIV(tp),e3)) => e

  rule	(* e1 / e2 where e1 and e2 can be factorized with common factor
	 e.g  a*b/c*a => b/c *)
	simplify(e1) => e1' &
	simplify(e2) => e2' &
	gcd(e1',e2') => factor &
 	remove_factor(factor,e1') => e1'' &
	simplify(e1'') => e1''' &
	remove_factor(factor,e2') => e2'' &
	simplify(e2'') => e2''' 
	---------------------------------------
	simplify (BINARY(e1,DIV(tp),e2)) => BINARY(e1''',DIV(tp),e2''')


  axiom	simplify (CAST(REAL,RCONST(v))) => RCONST(v)

  rule	int_real(v) => rv 
	-----------------
	simplify (CAST(REAL,ICONST(v))) => RCONST(rv)

	(* Array and Matrix stuff *)

  rule	simplify e => ARRAY(t,b,exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify ASUB(e, i) => exp

  rule	simplify e => MATRIX(t,n,exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => (expl) &
	Util.split_tuple2_list(expl) => (expl',bls) &
	Util.bool_and_list(bls) => b
	-----------------------
	simplify ASUB(e, i) => ARRAY(t,b,expl')

  rule	simplify e => IFEXP(c,t,f) &
	simplify ASUB(t,i) => t' &
	simplify ASUB(f,i) => f'
	------------------------
	simplify ASUB(e, i) => IFEXP(c,t',f')

  rule	simplify e => CREF(CREF_IDENT(n,s),t) &
	subscripts_append(s,i) => s'
	------------------------
	simplify ASUB(e, i) => CREF(CREF_IDENT(n,s'),t)

  rule	simplify e => CREF(CREF_QUAL(n,s,c),t) &
	simplify ASUB(CREF(c,t), i) => CREF(c',t)
	-------------------------------------
	simplify ASUB(e, i) => CREF(CREF_QUAL(n,s,c'),t)



	(* Operations *)

  rule	simplify e1 => e1' &
	let exp' = UNARY(op, e1') &
	simplify_unary (exp', op, e1') => e
	----------------------------------
	simplify (exp as UNARY(op, e1)) => e

  rule	simplify e1 => e1' &
	simplify e2 => e2' &
	let exp' = BINARY(e1', op, e2') &
	simplify_binary (exp', op, e1', e2') => e
	----------------------------------------
	simplify (exp as BINARY(e1, op, e2)) => e

  rule	simplify e1 => e1' &
	simplify e2 => e2' &
	let exp' = RELATION(e1', op, e2') &
	simplify_binary (exp', op, e1', e2') => e
	----------------------------------------
	simplify (exp as RELATION(e1, op, e2)) => e

  rule	simplify e1 => e1' &
	let exp' = LUNARY(op, e1') &
	simplify_unary (exp', op, e1') => e
	----------------------------------
	simplify (exp as LUNARY(op, e1)) => e

  rule	simplify e1 => e1' &
	simplify e2 => e2' &
	let exp' = LBINARY(e1', op, e2') &
	simplify_binary (exp', op, e1', e2') => e
	----------------------------------------
	simplify (exp as LBINARY(e1, op, e2)) => e

  axiom	simplify e => e

end

(** relation: remove_factor
 ** Remove the factor from the expression (factorize it out)
**)
relation remove_factor: (Exp, (* factor *)
			 Exp) (* expr *)
	=> (Exp) =	(* updated expr *)

  rule  factors(factor) => e1s &
	factors(expr) => e2s &
	Util.list_setdifference_p(e2s,e1s,exp_equal) => factors' &
	make_product(factors') => exp
	----------------------
	remove_factor(factor,expr) => exp

  (*rule	print_exp_str factor => fs & 
	print_exp_str expr => es & print "remove_factor failed, factor:" &
	print fs & print " expr:" & print es & print "\n" 
	--------------------
	remove_factor(factor,expr) => fail*)
end

(** relation: gcd
 ** Return the greatest common divisor expression from two expressions.
 ** If no common divisor besides a numerical expression can be found, the relation fails.
 **)
relation gcd: (Exp, Exp) => Exp =


  rule	factors(e1) => e1s &
	factors(e2) => e2s &
	Util.list_intersection_p(e1s,e2s,exp_equal) => (factor as _::_) &
	make_product(factor) => product
	------------------------------
	gcd(e1,e2) => product
end

(** relation: factors
 ** Returns the factors of the expression if any as a list of expressions
 **)
relation factors: Exp => Exp list =

  rule	factors(e1) => f1 &
	factors(e2) => f2 &
	list_append(f1,f2) => res
	-------------------------
	factors (BINARY(e1,MUL(_),e2)) => res

  rule	factors e1 => f1 &
	factors e2 => f2 &
	inverse_factors f2 => f2' &
	list_append(f1,f2) => res
	-------------------------
	factors(BINARY(e1,DIV(REAL),e2)) => res
	
  axiom	factors (e as CREF(cr,_)) => [e]
	
  axiom	factors (e as ICONST(_)) => [e]
  axiom	factors (e as RCONST(_)) => [e]
  axiom	factors (e as SCONST(_)) => [e]
  axiom	factors (e as UNARY(_,_)) => [e]
  axiom	factors (e as IFEXP(_,_,_)) => [e]
  axiom	factors (e as CALL(_,_,_,_)) => [e]
  axiom	factors (e as ARRAY(_,_,_)) => [e]
  axiom	factors (e as MATRIX(_,_,_)) => [e]
  axiom	factors (e as RANGE(_,_,_,_)) => [e]
  axiom	factors (e as CAST(_,_)) => [e]
  axiom	factors (e as ASUB(_,_)) => [e]
  axiom	factors (e as SIZE(_,_)) => [e]
  axiom	factors (e as REDUCTION(_,_,_,_)) => [e]


  axiom	factors (_) => []
end

(** relation inverse_factors
 ** Takes a list of expressions and returns each expression in the list inversed.
 ** For example inverse_factors [a,3+b] => [1/a, 1/3+b]
 **)
relation inverse_factors: Exp list => Exp list =
  axiom	inverse_factors ([]) => []

  rule	typeof(e) => REAL &
	inverse_factors(es) => es'
	--------------------
	inverse_factors (e::es) => BINARY(RCONST(1.0),DIV(REAL),e)::es'

  rule	typeof(e) => INT &
	inverse_factors(es) => es'
	--------------------
	inverse_factors (e::es) => BINARY(ICONST(1),DIV(INT),e)::es'
end

(** relation: make_product
 ** Takes a list of expressions an makes a product expression multiplying all 
 ** elements in the list.
 **)
relation make_product: (Exp list) => Exp =

  axiom	make_product([e1]) => e1

  rule	(* Take type info from e1, ok since type checking already performed. *)
	typeof(e1) => tp
	----------------
	make_product([e1,e2]) => BINARY(e1,MUL(tp),e2)

  rule	make_product(rest) => e2 &
	typeof(e2) => tp
	------------------
	make_product(e1::rest) => BINARY(e1,MUL(tp),e2)

  rule	print "-make_product failed\n" 
	------------------------------
	make_product(lst) => fail
end

(** relation typeof
 ** Retrieves the Type of the Expression
 **)
relation typeof: (Exp) => Type =
  axiom	typeof (ICONST(_)) =>  INT
  axiom	typeof (RCONST(_)) =>  REAL
  axiom	typeof (SCONST(_)) =>  STRING
  axiom	typeof (BCONST(_)) =>  BOOL
  axiom	typeof (CREF(_,tp)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (BINARY(_,op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (UNARY(op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (LBINARY(_,op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (LUNARY(op,_)) => tp

  rule	typeof_op(op) => tp
	-----------------------
	typeof (RELATION(_,op,_)) => tp

  rule	typeof(e2) => tp
	----------------
	typeof(IFEXP(e1,e2,e3)) => tp

  axiom	typeof(CALL(_,_,_,_)) => OTHER (* Not always true *)

  axiom	typeof(ARRAY(tp,_,_)) => tp
  axiom	typeof(MATRIX(tp,_,_)) => tp
  axiom	typeof(RANGE(tp,_,_,_)) => tp
  axiom	typeof(CAST(tp,_)) => tp

  rule	typeof(e) => tp
	-------------------
	typeof(ASUB(e,_)) => tp

  axiom	typeof(CODE(_,tp)) => tp

  rule	typeof (e) => tp
	----------------
	typeof(REDUCTION(_,e,_,_)) => tp

  axiom	typeof(END) => OTHER (* Can be any type. *)
end

relation typeof_op: Operator => Type =

  axiom	typeof_op(ADD(t)) => t
  axiom	typeof_op(SUB(t)) => t
  axiom	typeof_op(MUL(t)) => t
  axiom	typeof_op(DIV(t)) => t
  axiom	typeof_op(POW(t)) => t
  axiom	typeof_op(UMINUS(t)) => t
  axiom	typeof_op(UPLUS(t)) => t
  axiom	typeof_op(UMINUS_ARR(t)) => t
  axiom	typeof_op(UPLUS_ARR(t)) => t
  axiom	typeof_op(ADD_ARR(t)) => t
  axiom	typeof_op(SUB_ARR(t)) => t
  axiom	typeof_op(MUL_SCALAR_ARRAY(t)) => t
  axiom	typeof_op(MUL_SCALAR_PRODUCT(t)) => t
  axiom	typeof_op(MUL_MATRIX_PRODUCT(t)) => t
  axiom	typeof_op(DIV_ARRAY_SCALAR(t)) => t
  axiom	typeof_op(POW_ARR(t)) => t
  axiom	typeof_op(AND) => BOOL
  axiom	typeof_op(OR) => BOOL
  axiom	typeof_op(NOT) => BOOL
  axiom	typeof_op(LESS(t)) => t
  axiom	typeof_op(LESSEQ(t)) => t
  axiom	typeof_op(GREATER(t)) => t
  axiom	typeof_op(GREATEREQ(t)) => t
  axiom	typeof_op(EQUAL(t)) => t
  axiom	typeof_op(NEQUAL(t)) => t
  axiom	typeof_op(USERDEFINED(t)) => OTHER
end

relation is_const_one : Exp => bool =

  rule	int_real(1) => rval &
	e = RCONST(rval)
	--------------
	is_const_one e => true

  axiom	is_const_one ICONST(1) => true
  axiom is_const_one (_) => false

end

relation is_const_minus_one : Exp => bool =

  rule	int_real(-1) => rval &
	real_eq(v,rval) => true
	-----------------------
	is_const_minus_one RCONST(v) => true

  axiom	is_const_minus_one ICONST(-1) => true
  axiom is_const_minus_one (_) => false

end


relation is_const_zero : Exp => bool =

  rule	int_real(0) => rval &
	e = RCONST(rval)
	--------------
	is_const_zero e => true

  axiom	is_const_zero ICONST(0) => true
  axiom is_const_zero (_) => false

end

relation simplify_binary : (Exp, Operator, Exp, Exp) => Exp =

  rule	is_const_zero (e1) => true &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, ADD(ty), e1, e2) => e2'

  rule	is_const_zero (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, ADD(ty), e1, e2) => e1'

  rule	is_const_zero (e1) => true &	
	let e = UNARY(UMINUS(ty), e2) &
	simplify e => e'
	---------------------------
	simplify_binary (_, SUB(ty), e1, e2) => e'

  rule	is_const_zero (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, SUB(ty), e1, e2) => e1'

  rule	is_const_zero (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, SUB(ty), e1, e2) => e1'

  rule  (* a-(-b) = a+b *)
	simplify BINARY(e1, ADD(ty), e2) => e
	--------------------
	simplify_binary (_, SUB(ty), e1, UNARY(UMINUS(ty2),e2)) => e

  rule	is_const_zero (e1) => true 
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e1

  rule	is_const_zero (e2) => true 
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e2

  rule	is_const_one (e1) => true &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e2'

  rule	is_const_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e1'

  rule	is_const_minus_one (e1) => true &
	simplify UNARY(UMINUS(ty),e2) => e
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => e

  rule	is_const_minus_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, MUL(ty), e1, e2) => UNARY(UMINUS(ty),e1')

  rule	simplify BINARY(e1,MUL(ty),e2) => e
	---------------------------
	simplify_binary (_, MUL(ty), UNARY(UMINUS(ty1),e1), UNARY(UMINUS(ty2),e2)) 
	  => e

  rule	(* e1 * -e2 => -e1 * e2 *)
	simplify UNARY(UMINUS(ty),e1) => e1' &
	simplify e2  => e2' 
	---------------------------
	simplify_binary (_, MUL(ty), e1, UNARY(UMINUS(ty2),e2)) 
	  => BINARY(e1',MUL(ty),e2')

  rule	is_const_zero (e1) => true 
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) =>  RCONST(0.0)

  rule	is_const_zero (e2) => true &
        Print.print_buf "# Error, division by zero.\n" 
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) =>  fail

  rule	is_const_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) => e1'

  rule	is_const_minus_one (e2) => true &
	simplify e1 => e1'
	---------------------------
	simplify_binary (_, DIV(ty), e1, e2) => UNARY(UMINUS(ty),e1')

  rule	simplify e1 => e1' &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, DIV(ty), UNARY(UMINUS(ty1),e1), UNARY(UMINUS(ty2),e2)) 
	  => BINARY(e1',DIV(ty),e2')

  rule	(* e1 / -e2  => -e1 / e2 *)
	simplify UNARY(UMINUS(ty),e1) => e1' &
	simplify e2 => e2'
	---------------------------
	simplify_binary (_, DIV(ty), e1, UNARY(UMINUS(ty2),e2)) 
	  => BINARY(e1',DIV(ty),e2')

  axiom	simplify_binary (e, _, _, _) => e

end

relation simplify_unary : (Exp, Operator, Exp) => Exp =

  axiom	simplify_unary (_, UPLUS(ty), e1) => e1

  rule	simplify e1 => e1' &
	is_const_zero e1' => true
	-----------------------
	simplify_unary (_, UMINUS(ty), e1) => e1'

  rule	(* -(a-b) => b-a *)
	simplify BINARY(e2,SUB(ty1),e1) => e' 
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,SUB(ty1),e2)) => e'

  rule	(* -(a+b) => b-a *)
	simplify BINARY(UNARY(UMINUS(ty),e1),ADD(ty1),UNARY(UMINUS(ty),e2)) => e'
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,ADD(ty1),e2)) => e'

  rule	(* -(a/b) => -a/b *)
	simplify BINARY(UNARY(UMINUS(ty),e1),DIV(ty1),e2) => e'
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,DIV(ty1),e2)) => e'

  rule	(* -(a*b) => -a*b *)
	simplify BINARY(UNARY(UMINUS(ty),e1),MUL(ty1),e2) => e'
	-----------------------
	simplify_unary (_, UMINUS(ty), BINARY(e1,MUL(ty1),e2)) => e'

	(* Should we check ty1 == ty2? *)
  rule	simplify e1 => e1'
	-------------------
	simplify_unary (_, UMINUS(ty1), UNARY(UMINUS(ty2),e1)) => e1'

  axiom	simplify_unary (e, _, _) => e

end




(** relation: contain_functioncall
 ** Returns true if expression or subexpression is a functioncall.
 ** otherwise false 
**)
relation contain_functioncall : Exp => bool =

  axiom	contain_functioncall(CALL(_,_,_,_)) => true

	(* Binary *)
  rule	contain_functioncall(e1) => true
	---------------------
	contain_functioncall(BINARY(e1,_,e2)) => true

  rule	contain_functioncall(e2) => true 
	---------------------
	contain_functioncall(BINARY(e1,_,e2)) => true

	(* Unary *)
  rule	contain_functioncall(e) => res
	---------------------
	contain_functioncall(UNARY(_,e)) => res

	(* LBinary *)
  rule	contain_functioncall(e1) => true
	---------------------
	contain_functioncall(LBINARY(e1,_,e2)) => true

  rule	contain_functioncall(e2) => true 
	---------------------
	contain_functioncall(LBINARY(e1,_,e2)) => true

	(* LUnary *)
  rule	contain_functioncall(e) => res
	---------------------
	contain_functioncall(LUNARY(_,e)) => res

	(* Relation *)
  rule	contain_functioncall(e1) => true
	---------------------
	contain_functioncall(RELATION(e1,_,e2)) => true

  rule	contain_functioncall(e2) => true
	---------------------
	contain_functioncall(RELATION(e1,_,e2)) => true

	(* If exp*)
  rule	contain_functioncall(e1) => true
	--------------------------------
	contain_functioncall(IFEXP(e1,e2,e3)) => true

  rule	contain_functioncall(e2) => true
	--------------------------------
	contain_functioncall(IFEXP(e1,e2,e3)) => true

  rule	contain_functioncall(e3) => true
	--------------------------------
	contain_functioncall(IFEXP(e1,e2,e3)) => true

	(* Array *)
  rule	Util.list_map(elst,contain_functioncall) => blst &
	Util.bool_or_list(blst) => res
	------------------------------
	contain_functioncall(ARRAY(_,_,elst)) => res

	(* Matrix *)
  rule	Util.list_flatten(explst) => flatexplst &
	Util.list_map(flatexplst,Util.tuple2_1) => elst &
	Util.list_map(elst,contain_functioncall) => blst &
	Util.bool_or_list(blst) => res
	------------------------------
	contain_functioncall(MATRIX(_,_,explst)) => res

	(* Range *)
  rule	contain_functioncall(e1) => true
	------------------------------
	contain_functioncall(RANGE(_,e1,optexp,e2)) => true

  rule	contain_functioncall(e2) => true
	------------------------------
	contain_functioncall(RANGE(_,e1,optexp,e2)) => true

  rule	contain_functioncall(e) => true
	------------------------------
	contain_functioncall(RANGE(_,e1,SOME(e),e2)) => true

	(* Tuple *)
  axiom	contain_functioncall(TUPLE(_)) => true

  rule	contain_functioncall(e) => res
	------------------------------
	contain_functioncall(CAST(_,e)) => res
	
	(* Size *)
  rule	contain_functioncall(e1) => true
	--------------------------------
	contain_functioncall(SIZE(e1,e2)) => true

  rule	contain_functioncall(e2) => true
	--------------------------------
	contain_functioncall(SIZE(e1,SOME(e2))) => true

  axiom	contain_functioncall(_) => false
end

relation unelab_exp : Exp => Absyn.Exp =

  axiom	unelab_exp(ICONST(i)) => Absyn.INTEGER(i)
  axiom	unelab_exp(RCONST(r)) => Absyn.REAL(r)
  axiom	unelab_exp(SCONST(s)) => Absyn.STRING(s)
  axiom	unelab_exp(BCONST(b)) => Absyn.BOOL(b)

  rule	unelab_cref(cr) => cr'
	----------------
	unelab_exp(CREF(cr,t))=> Absyn.CREF(cr')
end

relation unelab_cref: ComponentRef => Absyn.ComponentRef =

  rule	unelab_subscripts(subs) => subs'
	-------------------------------
	unelab_cref(CREF_IDENT(id,subs)) => Absyn.CREF_IDENT(id,subs')
	
  rule	unelab_cref(cr) => cr' &
	unelab_subscripts(subs)=> subs'
	----------------------
	unelab_cref(CREF_QUAL(id,subs,cr)) => Absyn.CREF_QUAL(id,subs',cr')
end

relation unelab_subscripts: Subscript list => Absyn.Subscript list =
	
  axiom	unelab_subscripts([]) => []

  rule	unelab_subscripts(xs) => xs'
	---------------------------
	unelab_subscripts(WHOLEDIM::xs) => Absyn.NOSUB::xs'
	
  rule	unelab_subscripts(xs) => xs' &
	unelab_exp(e) => e'
	---------------------------
	unelab_subscripts(SLICE(e)::xs) => Absyn.SUBSCRIPT(e')::xs'

  rule	unelab_subscripts(xs) => xs' &
	unelab_exp(e) => e'
	---------------------------
	unelab_subscripts(INDEX(e)::xs) => Absyn.SUBSCRIPT(e')::xs'
end


(* Only support for indexed subscripts of integers*)
relation to_exp_cref: Absyn.ComponentRef => ComponentRef =

  rule	to_exp_cref_subs(subs) => subs'
	-------------------------------
	to_exp_cref(Absyn.CREF_IDENT(id,subs)) => CREF_IDENT(id,subs')
	
  rule	to_exp_cref(cr) => cr' &
	to_exp_cref_subs(subs) => subs'
	-------------------------------
	to_exp_cref(Absyn.CREF_QUAL(id,subs,cr)) => CREF_QUAL(id,subs',cr')
end

relation to_exp_cref_subs: Absyn.Subscript list => Subscript list =
	
  axiom	to_exp_cref_subs([]) => []

  rule	to_exp_cref_subs(xs) => xs' 
	---------------------------
	to_exp_cref_subs(Absyn.SUBSCRIPT(Absyn.INTEGER(i))::xs) 
	  => INDEX(ICONST(i))::xs'

  rule	Print.print_buf "#Error elaborating TypeName." &
	to_exp_cref_subs(xs) => xs' 
	---------------------------
	to_exp_cref_subs(_::xs)  => xs'
end


(** relation: subscripts_append
 **
 ** This relation takes a subscript list and adds a new subscript.
 ** But there are a few special cases.  When the last existing
 ** subscript is a slice, it is replaced by the slice indexed by the
 ** new subscript.
 **)

relation subscripts_append : (Subscript list, int) => Subscript list =

  axiom	subscripts_append([], i) => [INDEX(ICONST(i))]

  axiom	subscripts_append([WHOLEDIM], i) => [INDEX(ICONST(i))]

  rule	simplify ASUB(e, i) => e'
	-------------------------
	subscripts_append([SLICE(e)], i) => [INDEX(e')]

  axiom	subscripts_append([s as INDEX(_)], i) => [s, INDEX(ICONST(i))]

  rule	subscripts_append(ss, i) => ss'
	-------------------------------
	subscripts_append(s::ss, i) => s::ss'

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **)

(*!ignorecode*)

relation type_string : Type => string =

  axiom	type_string INT => "INT"
  axiom	type_string REAL => "REAL"
  axiom	type_string BOOL => "BOOL"
  axiom	type_string STRING => "STRING"

end

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref CREF_IDENT(s,subs)

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2 (s,subs) &
	Print.print_buf "__" &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

  rule	RTOpts.modelica_output => false &
	print_component_ref2 (s,subs) &
	Print.print_buf "." &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

end

relation print_component_ref2 =

  rule	Print.print_buf s
	-------
	print_component_ref2 (s,[])

  rule	RTOpts.modelica_output => true &
	Print.print_buf s &
	Print.print_buf "_L" & print_list(l,print_subscript,",") & Print.print_buf "_R"
	-------------------------------------------------------
	print_component_ref2 (s,l)

  rule	RTOpts.modelica_output => false &
	Print.print_buf s &
	Print.print_buf "[" & print_list(l,print_subscript,",") & Print.print_buf "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** relation: print_subscript
 **
 ** Print a `Subscript'.
 **)

relation print_subscript: Subscript => () =
	
  rule	Print.print_buf ":"
	---------
	print_subscript(WHOLEDIM)
	
  rule	print_exp(e1)
	-------------
	print_subscript(INDEX(e1))
	
  rule	print_exp(e1)
	-------------
	print_subscript(SLICE(e1))
	
end

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp : Exp => () =

  rule	print_exp2 (e,0)
	----------------
	print_exp e

end

relation print_exp2 : (Exp,int) => () =
	
  rule	int_string(x) => s & Print.print_buf s
	----------------------------
	print_exp2(ICONST(x),_)

  rule	real_string(x) => s & Print.print_buf s
	-----------------------------
	print_exp2(RCONST(x),_)

  rule	Print.print_buf "\"" & Print.print_buf s & Print.print_buf "\""
	---------------------------------
	print_exp2(SCONST(s),_)

  rule	Print.print_buf "false"
	-------------
	print_exp2(BCONST(false),_)

  rule	Print.print_buf "true"
	-------------
	print_exp2(BCONST(true),_)

  rule	print_component_ref(c)
	---------------------
	print_exp2(CREF(c,_),_)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2' &
	int_add (pri2', 1) => pri2 & (* binary minus have higher priority than itself *)
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri2) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op as SUB(ty), e2 as BINARY(e21, SUB(ty2), e22)),pri1)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri2) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op, e2),pri1)

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	Print.print_buf sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------
	print_exp2(UNARY(op, e),pri1)

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri2) &
	print_rightpar(pri1,pri2)
	----------------------------------------------------------------
	print_exp2(LBINARY(e1, op, e2),pri1)

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	Print.print_buf sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	---------------------------------------------------
	print_exp2(LUNARY(op, e),pri1)

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print_exp2(e1,pri3) & Print.print_buf sym & print_exp2(e2,pri2) &
	print_rightpar(pri1,pri2)
	-----------------------------------------------------------------
	print_exp2(RELATION(e1, op, e2),pri1)

  rule	Print.print_buf "if " & print_exp2(c,0) &
	Print.print_buf " then " & print_exp2(t,0) &
	Print.print_buf " else " & print_exp2(f,0)
	----------------------------
	print_exp2(IFEXP(c,t,f),_)

  rule	Absyn.path_string(fcn) => fs &
	Print.print_buf fs & Print.print_buf "(" & print_list(args,print_exp,",") & Print.print_buf ")"
	---------------------------------------------
	print_exp2(CALL(fcn, args,_,_),_)

  rule	(* Print.print_buf "This an array: " & *)
	Print.print_buf "{" &
	print_list(es, print_exp, ",") &
	Print.print_buf "}"
	---------
	print_exp2 (ARRAY(_,_,es),_)

	(*PR.*)
  rule	Print.print_buf "(" &
	print_list(es, print_exp, ",") &
	Print.print_buf ")"
	---------
	print_exp2 (TUPLE(es),_)
	
  rule	Print.print_buf "<matrix>[" &
	print_list(es, print_row, ";") &
	Print.print_buf "]"
	---------
	print_exp2 (MATRIX(_,_,es),_)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & Print.print_buf ":" & print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------------------------------------------
	print_exp2 (RANGE(_,start,NONE,stop),pri1)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & Print.print_buf ":" &
	print_exp2 (step,pri3) & Print.print_buf ":" &
 	print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------
	print_exp2 (RANGE(_,start,SOME(step),stop),pri1)

  rule	RTOpts.modelica_output => false &
	int_real(i) => r &
	real_string(r) => rstr &
	Print.print_buf rstr
	---------------------------------------
	print_exp2 (CAST(REAL,ICONST(i)),_)

  rule	RTOpts.modelica_output => false &
	Print.print_buf "Real(" & print_exp e & Print.print_buf ")"
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	RTOpts.modelica_output => true &
	print_exp e
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	let pri2 = 51 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e,pri3) &
 	print_rightpar(pri1,pri2) &
 	Print.print_buf "<asub>[" &
 	int_string i => s & Print.print_buf s & Print.print_buf "]"
	---------------------------------------
	print_exp2 (ASUB(e,i),pri1)

  rule	print_exp_str e => str &
	Print.print_buf str
	-------------
	print_exp2 (e as SIZE(cr,SOME(dim)),_)

  rule	print_exp_str e => str &
	Print.print_buf str
	-------------
	print_exp2 (e as SIZE(cr,NONE),_)

  rule	print_exp_str e => str &
	Print.print_buf str
	-----------------------------
	print_exp2 (e as REDUCTION(fcn,exp,i,iterexp),_)

  rule	Print.print_buf "#UNKNOWN EXPRESSION# ----eee "
        ----------------------------------
	print_exp2 (_,_)

end


relation print_leftpar : (int,int) => int =

  rule	int_gt(x,y) => true & Print.print_buf "("
	-----------------------
	print_leftpar(x,y) => 0

  axiom	print_leftpar(pri1,pri2) => pri2

end

relation print_rightpar : (int,int) => () =

  rule	int_gt(x,y) => true & Print.print_buf ")"
	-----------------------
	print_rightpar(x,y)

  axiom	print_rightpar(_,_)

end


(* LS: Changed precedence for unary +-
   which must be higher than binary operators but lower than power
   according to e.g. matlab *)

(* LS: Changed precedence for binary - , should be higher than + and also
   itself, but this is specially handled in print_exp2 and print_exp2_str *)

(* priorities:
 *
 *   and, or		10
 *   not		11
 *   <, >, =, != etc.	21
 *   bin +		32
 *   bin -		33
 *   *			35
 *   /			36
 *   unary +, unary -	37
 *   ^			38
 *   :			41
 *   []			51
 *
 *)

relation binop_priority : Operator => int =
  axiom	binop_priority(ADD(_))    	      	 => 32
  axiom	binop_priority(SUB(_))    	      	 => 33
  axiom	binop_priority(ADD_ARR(_))    	      	 => 32
  axiom	binop_priority(SUB_ARR(_))    	      	 => 33
  axiom	binop_priority(MUL(_))    	      	 => 35
  axiom	binop_priority(MUL_SCALAR_ARRAY(_))   	 => 35
  axiom	binop_priority(MUL_ARRAY_SCALAR(_))    	 => 35
  axiom	binop_priority(MUL_SCALAR_PRODUCT(_))  	 => 35
  axiom	binop_priority(MUL_MATRIX_PRODUCT(_))  	 => 35
  axiom	binop_priority(DIV(_))   	      	 => 36
  axiom	binop_priority(DIV_ARRAY_SCALAR(_))    	 => 36
  axiom	binop_priority(POW(_))   	      	 => 38
end

relation unaryop_priority : Operator => int =
  axiom	unaryop_priority(UMINUS(_))   => 37
  axiom	unaryop_priority(UPLUS(_))    => 37
end

relation lbinop_priority : Operator => int =
  axiom	lbinop_priority(AND) => 10
  axiom	lbinop_priority(OR) => 10
end

relation lunaryop_priority : Operator => int =
  axiom	lunaryop_priority(NOT) => 11
end

relation relop_priority : Operator => int =
  axiom	relop_priority(LESS(_))       => 21
  axiom	relop_priority(LESSEQ(_))     => 21
  axiom	relop_priority(GREATER(_))    => 21
  axiom	relop_priority(GREATEREQ(_))  => 21
  axiom	relop_priority(EQUAL(_))      => 21
  axiom	relop_priority(NEQUAL(_))     => 21
end

(**)

relation binop_symbol : Operator => string =

  rule	RTOpts.typeinfo => false &
	binop_symbol_1 op => s
	----------------------
	binop_symbol op => s

  rule	RTOpts.typeinfo => true &
	binop_symbol_2 op => s
	----------------------
	binop_symbol op => s

end

(**)

relation binop_symbol_1 : Operator => string =
  axiom	binop_symbol_1(ADD(_)) => " + "
  axiom	binop_symbol_1(SUB(_)) => " - "
  axiom	binop_symbol_1(MUL(_)) => " * "
  axiom	binop_symbol_1(DIV(_)) => " / "
  axiom	binop_symbol_1(POW(_)) => " ^ "
  axiom	binop_symbol_1(ADD_ARR(_)) => " + "
  axiom	binop_symbol_1(SUB_ARR(_)) => " - "
  axiom	binop_symbol_1(MUL_SCALAR_ARRAY(_)) => " * "
  axiom	binop_symbol_1(MUL_ARRAY_SCALAR(_)) => " * "
  axiom	binop_symbol_1(MUL_SCALAR_PRODUCT(_)) => " * "
  axiom	binop_symbol_1(MUL_MATRIX_PRODUCT(_)) => " * "
  axiom	binop_symbol_1(DIV_ARRAY_SCALAR(_)) => " / "

(*
  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "
*)

end

relation binop_symbol_2 : Operator => string =
  rule	type_string t => ts &
	string_append(" +<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(ADD(t)) => s'

  axiom	binop_symbol_2(SUB(t)) => " - "
  axiom	binop_symbol_2(MUL(t)) => " * "

  rule	type_string t => ts &
	string_append(" /<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(DIV(t)) => s'

  axiom	binop_symbol_2(POW(t)) => " ^ "

  axiom	binop_symbol_2(ADD_ARR(_)) => " + "
  axiom	binop_symbol_2(SUB_ARR(_)) => " - "
  axiom	binop_symbol_2(MUL_SCALAR_ARRAY(_)) => " * "
  axiom	binop_symbol_2(MUL_ARRAY_SCALAR(_)) => " * "
  axiom	binop_symbol_2(MUL_SCALAR_PRODUCT(_)) => " * "
  axiom	binop_symbol_2(MUL_MATRIX_PRODUCT(_)) => " * "
  axiom	binop_symbol_2(DIV_ARRAY_SCALAR(_)) => " / "

(*
  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "
*)

end

relation unaryop_symbol : Operator => string =
  axiom	unaryop_symbol(UMINUS(_)) => "-"
  axiom	unaryop_symbol(UPLUS(_)) => "+"
end

relation lbinop_symbol : Operator => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol : Operator => string =
  axiom	lunaryop_symbol(NOT) => " NOT "
end

relation relop_symbol : Operator => string =
  axiom	relop_symbol(LESS(_))       => " < "
  axiom	relop_symbol(LESSEQ(_))     => " <= "
  axiom	relop_symbol(GREATER(_))    => " > "
  axiom	relop_symbol(GREATEREQ(_))  => " >= "
  axiom	relop_symbol(EQUAL(_))      => " = "
  axiom	relop_symbol(NEQUAL(_))     => " <> "
end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & Print.print_buf sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(**)

relation print_row : (Exp*bool) list =>() =

  rule	Util.list_map(es,Util.tuple2_1) => es' &
	print_list(es',print_exp,",")
	----------------------------
	print_row es

end

(*!includecode*)



(******************************************************************)
(** LS: print relations that return a string instead of printing **)
(** Had to duplicate the huge print_exp2 and modify              **)
(** An alternative would be to implement "sprint" somehow        **)
(** which would need internal state, with reset and              **)
(** get_string methods                                           **)
(**                                                              **)
(** Once these are tested and ok, the print_exp* above can be    **)
(** replaced by a call to these _str relations and printing      **)
(** the result.                                                  **)
(******************************************************************)

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref_str : ComponentRef => string =

  axiom	print_component_ref_str(CREF_IDENT(s,[])) => s (* optimize *)

  rule	print_component_ref2_str (s,subs) => str
	----------------------------
	print_component_ref_str CREF_IDENT(s,subs) => str

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2_str (s,subs) => str &
	print_component_ref_str cr => strrest &
	string_append (str, "__") => str' &
	string_append (str', strrest) => str''
	---------------------
	print_component_ref_str CREF_QUAL(s,subs,cr) => str''

  rule	RTOpts.modelica_output => false &
	print_component_ref2_str (s,subs) => str &
	print_component_ref_str cr => strrest &
	string_append (str, ".") => str' &
	string_append (str', strrest) => str''
	---------------------
	print_component_ref_str CREF_QUAL(s,subs,cr) => str''

end

relation print_component_ref2_str : (Ident, Subscript list) => string =

  axiom	print_component_ref2_str (s,[]) => s

  rule	RTOpts.modelica_output => true &
	print_list_str (l, print_subscript_str, ",") => str &
	string_append (s, "_L") => str' &
	string_append (str', str) => str'' &
	string_append (str'', "_R") => str'''
	-------------------------------------------------------
	print_component_ref2_str (s,l) => str'''

  rule	RTOpts.modelica_output => false &
	print_list_str (l, print_subscript_str, ",") => str &
	string_append (s, "[") => str' &
	string_append (str', str) => str'' &
	string_append (str'', "]") => str'''
	-------------------------------------------------------
	print_component_ref2_str (s,l) => str'''

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end



(** relation: print_subscript_str
 **
 ** Print a `Subscript'.
 **)

relation print_subscript_str: Subscript => string =
	
  axiom	print_subscript_str (WHOLEDIM) => ":"
	
  rule	print_exp_str (e1) => s
	-------------
	print_subscript_str (INDEX(e1)) => s
	
  rule	print_exp_str (e1) => s
	-------------
	print_subscript_str (SLICE(e1)) => s
	
end


(** relation: print_exp_str
 **
 ** This relation prints a complete expression.
 **)

relation print_exp_str : Exp => string =

  rule	print_exp2_str (e,0) => s
	--------------------
	print_exp_str e => s

end


relation print_exp2_str : (Exp,int) => string =
	
  axiom print_exp2_str(END,_) => "end"
  
  rule	int_string(x) => s
	----------------------------
	print_exp2_str(ICONST(x),_) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp2_str(RCONST(x),_) => s

  rule	string_append ("\"", s) => s' &
	string_append (s', "\"") => s''
	---------------------------------
	print_exp2_str(SCONST(s),_) => s''

  axiom	print_exp2_str(BCONST(false),_) => "false"

  axiom	print_exp2_str(BCONST(true),_) => "true"

  rule	print_component_ref_str (c) => s
	--------------------------------
	print_exp2_str(CREF(c,_),_) => s

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2' &
	int_add (pri2',1) => pri2 & (* binary minus have higher priority than itself *)
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (BINARY(e1, op as SUB(ty), e2 as BINARY(e21, SUB(ty2), e22)),pri1) => s'''

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (BINARY(e1, op, e2),pri1) => s'''

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
	print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	----------------------------
	print_exp2_str(UNARY(op, e),pri1) => s''

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	----------------------------------------------------------------
	print_exp2_str(LBINARY(e1, op, e2),pri1) => s'''

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str (e,pri3) => s2 &
	print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	---------------------------------------------------
	print_exp2_str(LUNARY(op, e),pri1) => s''

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str(e1,pri3) => s2 & 
	print_exp2_str(e2,pri2) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-----------------------------------------------------------------
	print_exp2_str(RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	print_exp2_str(t,0) => thenstr &
	print_exp2_str(f,0) => elsestr &
	string_append ("if ", ifstr) => s &
	string_append (s, " then ") => s' &
	string_append (s', thenstr) => s'' &
	string_append (s'', " else ") => s''' &
	string_append (s''', elsestr) => s''''
	----------------------------
	print_exp2_str(IFEXP(c,t,f),_) => s''''

  rule	Absyn.path_string(fcn) => fs &
	print_list_str(args,print_exp_str,",") => argstr &
	string_append(fs, "(") => s &
	string_append(s, argstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp2_str(CALL(fcn, args,_,_),_) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp2_str (ARRAY(_,_,es),_) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp2_str (TUPLE(es),_) => s''
	
  rule	print_list_str(es, print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s''
	-----------------------------
	print_exp2_str (MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (stop,pri3) => s3 &
 	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-------------------------------------------------------------
	print_exp2_str (RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	print_leftpar_str (pri1,pri2) => (s1,pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (step,pri3) => s3 &
 	print_exp2_str (stop,pri3) => s4 &
 	print_rightpar_str (pri1,pri2) => s5 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s4) => s'''' &
	string_append (s'''', s5) => s'''''
	-------------------------------------
	print_exp2_str (RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res
	---------------------------------------
	print_exp2_str (CAST(REAL,ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res &
	string_append("-",res) => res2
	---------------------------------------
	print_exp2_str (CAST(REAL,UNARY(UMINUS(_),ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	print_exp_str e => s & 
	string_append ("Real(", s) => s' &
	string_append (s', ")") => s''
	---------------------------------------
	print_exp2_str (CAST(REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	print_exp_str e => s
	---------------------------------------
	print_exp2_str (CAST(REAL,e),_) => s

  rule	let pri2 = 51 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
 	print_rightpar_str (pri1,pri2) => s3 &
 	int_string i => s4 &
	string_append (s1, s2) => s &
	string_append (s, s3) => s' &
	string_append (s', "[") => s'' &
	string_append (s'', s4) => s''' &
	string_append (s''', "]") => s''''
	---------------------------------------
	print_exp2_str (ASUB(e,i),pri1) => s''''

  rule	print_exp_str cr => crstr &
	print_exp_str dim => dimstr &
	Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	------------------------
	print_exp2_str (SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_str cr => crstr &
	Util.string_append_list(["size(",crstr,")"]) => str
	------------------------
	print_exp2_str (SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	print_exp_str exp => expstr &
	print_exp_str iterexp => iterstr &
	Util.string_append_list(["<reduction>",
				 fs,"(",expstr," for ",
				 id," in ",iterstr,")"]) => str
	-------------------------------------------------------
	print_exp2_str (REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

end

relation print_row_str : (Exp*bool) list => string =

  rule	Util.list_map (es,Util.tuple2_1) => es' &
	print_list_str (es', print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end


relation print_leftpar_str : (int,int) => (string, int) =

  rule	int_gt(x,y) => true
	-----------------------
	print_leftpar_str (x,y) => ("(", 0)

  axiom	print_leftpar_str (pri1,pri2) => ("", pri2)

end

relation print_rightpar_str : (int,int) => string =

  rule	int_gt(x,y) => true
	-----------------------
	print_rightpar_str (x,y) => ")"

  axiom	print_rightpar_str (_,_) => ""

end

relation exp_equal: (Exp,Exp) => bool =

  rule  int_eq(c1,c2) => res
	-------------------
	exp_equal(ICONST(c1),ICONST(c2)) => res

  rule  real_eq(c1,c2) => res
	-------------------
	exp_equal(RCONST(c1),RCONST(c2)) => res

  rule  c1 = c2
	-------------------
	exp_equal(SCONST(c1),SCONST(c2)) => true

  rule  bool_and(c1,c2) => b1 &
	bool_not(c1) => c1' &
	bool_not(c2) => c2' &
	bool_and(c1',c2') => b2 &
	bool_or(b1,b2) => res
	-------------------
	exp_equal(BCONST(c1),BCONST(c2)) => res

  rule  cref_equal(c1,c2) => res
	------------------------
	exp_equal(CREF(c1,_),CREF(c2,_)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(BINARY(e11,op1,e12),BINARY(e21,op2,e22)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(LBINARY(e11,op1,e12),LBINARY(e21,op2,e22)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e1,e2) => b2 &
	bool_and(b1,b2) => res
	------------------------
	exp_equal(UNARY(op1,e1),UNARY(op2,e2)) => res

  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e1,e2) => b2 &
	bool_and(b1,b2) => res
	------------------------
	exp_equal(LUNARY(op1,e1),LUNARY(op2,e2)) => res
	
  rule  operator_equal(op1, op2) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(RELATION(e11,op1,e12),RELATION(e21,op2,e22)) => res

  rule  exp_equal(e13,e23) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(IFEXP(e11,e12,e13),IFEXP(e21,e22,e23)) => res

  rule  ModUtil.path_equal(path1,path2) => b1 &
	Util.list_thread_map(expl1,expl2,exp_equal) => bs &
	Util.bool_and_list(b1::bs) => res 
	--------------------------------------------------
	exp_equal(CALL(path1,expl1,_,_),CALL(path2,expl2,_,_)) => res

  rule	tp1 = tp2 &
	Util.list_thread_map(expl1,expl2,exp_equal) => bs &
	Util.bool_and_list(bs) => res 
	--------------------------------------------------
	exp_equal(ARRAY(tp1,_,expl1),ARRAY(tp2,_,expl2)) => res

  rule	print "exp_equal for MATRIX not impl. yet.\n"
	--------------------------------------------------
	exp_equal(MATRIX(_,_,_),MATRIX(_,_,_)) => false

  rule  exp_equal(e13,e23) => b1 &
	exp_equal(e11,e21) => b2 &
	Util.bool_and_list([b1,b2]) => res
	------------------------
	exp_equal(RANGE(tp1,e11,NONE,e13),RANGE(tp2,e21,NONE,e23)) => res

  rule  exp_equal(e13,e23) => b1 &
	exp_equal(e11,e21) => b2 &
	exp_equal(e12,e22) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	------------------------
	exp_equal(RANGE(tp1,e11,SOME(e12),e13),RANGE(tp2,e21,SOME(e22),e23)) 
	  => res

  rule	Util.list_thread_map(expl1,expl2,exp_equal) => bs &
	Util.bool_and_list(bs) => res 
	--------------------------------------------------
	exp_equal(TUPLE(expl1),TUPLE(expl2)) => res

  rule	tp1 = tp2 &
	exp_equal(e1,e2) => res
	---------------------
	exp_equal(CAST(tp1,e1),CAST(tp2,e2)) => res

  rule	int_eq(i1,i2) => b1 &
	exp_equal(e1,e2) => b2 &
	bool_and(b1,b2) => res
	-----------------------
	exp_equal(ASUB(e1,i1),ASUB(e2,i2)) => res

  rule	exp_equal(e1,e2) => res
	-----------------------
	exp_equal(SIZE(e1,NONE),SIZE(e2,NONE)) => res

  rule	exp_equal(e1,e2) => b1 &
	exp_equal(e11,e22) => b2 &
	bool_and(b1,b2) => res
	-----------------------
	exp_equal(SIZE(e1,SOME(e11)),SIZE(e2,SOME(e22))) => res

  rule	print "exp_equal on CODE not impl.\n" 
	--------------------------------------
	exp_equal(CODE(_,_),CODE(_,_)) => false

  rule	id1=id2 &
	ModUtil.path_equal(path1,path2) => b1 &
	exp_equal(e1,e2) => b2 &
	exp_equal(r1,r2) => b3 &
	Util.bool_and_list([b1,b2,b3]) => res
	--------------------------
	exp_equal(REDUCTION(path1,e1,id1,r1),REDUCTION(path2,e2,id2,r2)) =>  res

  axiom	exp_equal(END, END) => true

  axiom	exp_equal(_,_) => false
end

relation operator_equal: (Operator,Operator) => bool =

  axiom	operator_equal(ADD(_),ADD(_)) => true
  axiom	operator_equal(SUB(_),SUB(_)) => true
  axiom	operator_equal(MUL(_),MUL(_)) => true
  axiom	operator_equal(DIV(_),DIV(_)) => true
  axiom	operator_equal(POW(_),POW(_)) => true
  axiom	operator_equal(UMINUS(_),UMINUS(_)) => true
  axiom	operator_equal(UMINUS_ARR(_),UMINUS_ARR(_)) => true
  axiom	operator_equal(UPLUS_ARR(_),UPLUS_ARR(_)) => true
  axiom	operator_equal(ADD_ARR(_),ADD_ARR(_)) => true
  axiom	operator_equal(SUB_ARR(_),SUB_ARR(_)) => true
  axiom	operator_equal(MUL_SCALAR_ARRAY(_),MUL_SCALAR_ARRAY(_)) => true
  axiom	operator_equal(MUL_ARRAY_SCALAR(_),MUL_ARRAY_SCALAR(_)) => true
  axiom	operator_equal(MUL_SCALAR_PRODUCT(_),MUL_SCALAR_PRODUCT(_)) => true
  axiom	operator_equal(MUL_MATRIX_PRODUCT(_),MUL_MATRIX_PRODUCT(_)) => true
  axiom	operator_equal(DIV_ARRAY_SCALAR(_),DIV_ARRAY_SCALAR(_)) => true
  axiom	operator_equal(POW_ARR(_),POW_ARR(_)) => true
  axiom	operator_equal(AND,AND) => true
  axiom	operator_equal(OR,OR) => true
  axiom	operator_equal(NOT,NOT) => true
  axiom	operator_equal(LESS(_),LESS(_)) => true
  axiom	operator_equal(LESSEQ(_),LESSEQ(_)) => true
  axiom	operator_equal(GREATER(_),GREATER(_)) => true
  axiom	operator_equal(GREATEREQ(_),GREATEREQ(_)) => true
  axiom	operator_equal(EQUAL(_),EQUAL(_)) => true
  axiom	operator_equal(NEQUAL(_),NEQUAL(_)) => true
  rule	ModUtil.path_equal(p1,p2) => res
	--------------------------------
  	operator_equal(USERDEFINED(p1),USERDEFINED(p2)) => res
  axiom	operator_equal(_,_) => false
end

(* Replaces an expression with a list of several expressions. 
 NOTE: Not repreteadly applied, so the source and target lists must be disjunct
 Useful for instance when replacing several variables at once in an expression. 
 *)
 relation replace_exp_list: (Exp (*expr*), Exp list (* source list*), Exp list (* target list*))
	  => (Exp,int) =

  axiom	replace_exp_list(e,[],[]) => (e,0)

  rule	replace_exp(e,s1,t1) => (e',c1) &
	replace_exp_list(e',sr,tr) => (e'',c2) &
	int_add(c1,c2) => c 
	----------------------------------------
	replace_exp_list(e,s1::sr,t1::tr) => (e'',c)
end

relation replace_exp: (Exp (*expr*), Exp(* source expr*),Exp(*target expr*)) 
	  => (Exp,int) =

  rule	exp_equal(expr,source) => true
	------------------------------
	replace_exp(expr,source,target) => (target,1)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	------------------------------------
	replace_exp(BINARY(e1,op,e2),source,target) 
	  => (BINARY(e1',op,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	------------------------------------
	replace_exp(LBINARY(e1,op,e2),source,target) 
	  => (LBINARY(e1',op,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c)
	------------------------------------
	replace_exp(UNARY(op,e1),source,target) 
	  => (UNARY(op,e1'),c)

  rule	replace_exp(e1,source,target) => (e1',c)
	------------------------------------
	replace_exp(LUNARY(op,e1),source,target) 
	  => (LUNARY(op,e1'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	------------------------------------
	replace_exp(RELATION(e1,op,e2),source,target) 
	  => (RELATION(e1',op,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	replace_exp(e3,source,target) => (e3',c3) &
	Util.list_reduce([c1,c2,c3],int_add) => c
	------------------------------------
	replace_exp(IFEXP(e1,e2,e3),source,target) 
	  => (IFEXP(e1',e2',e3'),c)

  rule  Util.list_map_2_2(expl,replace_exp,source,target) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Util.list_reduce(cnt,int_add) => cnt'
	-----------------------------------------------
	replace_exp(CALL(path,expl,t,c),source,target) 
	  => (CALL(path,expl',t,c),cnt')

  rule	Util.list_map_2_2(expl,replace_exp,source,target) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Util.list_reduce(cnt,int_add) => cnt'
	-----------------------------------------------
	replace_exp(ARRAY(tp,c,expl),source,target) 
	  => (ARRAY(tp,c,expl'),cnt')

  rule	print "replace_exp for matrix not impl." 
	-----------------------------------------------
	replace_exp(MATRIX(a,b,c),source,target) 
	  => (MATRIX(a,b,c),0)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	-----------------------------------------------
	replace_exp(RANGE(tp,e1,NONE,e2),source,target) 
	  => (RANGE(tp,e1',NONE,e2'),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	replace_exp(e3,source,target) => (e3',c3) &
	Util.list_reduce([c1,c2,c3],int_add) => c
	-----------------------------------------------
	replace_exp(RANGE(tp,e1,SOME(e3),e2),source,target) 
	  => (RANGE(tp,e1',SOME(e3'),e2'),c)

  rule	Util.list_map_2_2(expl,replace_exp,source,target) => expl' &
	Util.split_tuple2_list(expl') => (expl',cnt) &
	Util.list_reduce(cnt,int_add) => cnt'
	-----------------------------------------------
	replace_exp(TUPLE(expl),source,target) 
	  => (TUPLE(expl'),cnt')

  rule	replace_exp(e1,source,target) => (e1',c)
	-----------------------------------------------
	replace_exp(CAST(tp,e1),source,target) 
	  => (CAST(tp,e1'),c)

  rule	replace_exp(e1,source,target) => (e1' ,c)
	-----------------------------------------------
	replace_exp(ASUB(e1,i),source,target) 
	  => (ASUB(e1',i),c)

  rule	replace_exp(e1,source,target) => (e1',c)
	-----------------------------------------------
	replace_exp(SIZE(e1,NONE),source,target) 
	  => (SIZE(e1',NONE),c)

  rule	replace_exp(e1,source,target) => (e1',c1) &
	replace_exp(e2,source,target) => (e2',c2) &
	int_add(c1,c2) => c
	-----------------------------------------------
	replace_exp(SIZE(e1,SOME(e2)),source,target) 
	  => (SIZE(e1',SOME(e2')),c)

  rule	print "replace_exp on CODE not impl.\n" 
	-----------------------------------------------
	replace_exp(CODE(a,b),source,target) 
	  => (CODE(a,b),0)

  rule	replace_exp(e,source,target) => (e',c1) &
	replace_exp(r,source,target) => (r' ,c2) &
	int_add(c1,c2) => c
	-----------------------------------------------
	replace_exp(REDUCTION(p,e,id,r),source,target) 
	  => (REDUCTION(p,e',id,r'),c)

(*  rule	print "WARNING WARNING replace_exp failed for Exp:" & 
	print_exp_str e => es & print es & print " source: " &
	print_exp_str s => ss & print ss & print "\n" 
	------------------------------
	replace_exp(e,s,_) => (e,0)*)
 axiom	replace_exp(e,s,_) => (e,0)
end


relation stringify_component_ref: ComponentRef => ComponentRef =
	
  rule	print_component_ref_str(cr) => crs 
	----------------------------------
	stringify_component_ref(cr) => CREF_IDENT(crs,[])
end

(** relation: stringify_crefs
 ** This relation takes an expression and transforms all component reference names
 ** contained in the expression to a simpler form.
 ** For instance CREF_QUAL("a",[], CREF_IDENT("b",[])) becomes
 ** CREF_IDENT("a.b",[])
 **)
relation stringify_crefs: Exp => Exp =

  axiom	stringify_crefs(e as ICONST(_)) => e
  axiom	stringify_crefs(e as RCONST(_)) => e
  axiom	stringify_crefs(e as SCONST(_)) => e
  axiom	stringify_crefs(e as BCONST(_)) => e
	
  rule	stringify_component_ref(cr) => cr'
	----------------------------------
	stringify_crefs(CREF(cr,t)) => CREF(cr',t)

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	-------------------
	stringify_crefs(BINARY(e1,op,e2)) => BINARY(e1',op,e2')

  rule	stringify_crefs(e) => e'
	-------------------
	stringify_crefs(UNARY(op,e)) => UNARY(op,e')

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	-------------------
	stringify_crefs(LBINARY(e1,op,e2)) => BINARY(e1',op,e2')
	
  rule	stringify_crefs(e) => e'
	-------------------
	stringify_crefs(LUNARY(op,e)) => UNARY(op,e')
	
  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	--------------------------
	stringify_crefs(RELATION(e1,op,e2)) => RELATION(e1',op,e2')
	
  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' &
	stringify_crefs(e3) => e3' 
	--------------------------
	stringify_crefs(IFEXP(e1,e2,e3)) => IFEXP(e1',e2',e3')
	
  rule	Util.list_map(expl,stringify_crefs) =>  expl'
	-----------------------
	stringify_crefs(CALL(p,expl,t,b)) => CALL(p,expl',t,b)

  rule	Util.list_map(expl,stringify_crefs) =>  expl'
	-----------------------
	stringify_crefs(ARRAY(t,b,expl)) => ARRAY(t,b,expl')
	
  rule	print "stringify_crefs on MATRIX not impl. yet\n"
	-----------------------
	stringify_crefs(e as MATRIX(t,b,expl)) => e

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' &
	stringify_crefs(e3) => e3' 
	-----------------------
	stringify_crefs(RANGE(t,e1,SOME(e2),e3)) => RANGE(t,e1',SOME(e2'),e3')

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e3) => e3' 
	-----------------------
	stringify_crefs(RANGE(t,e1,NONE,e3)) => RANGE(t,e1',NONE,e3')


  rule	Util.list_map(expl,stringify_crefs) =>  expl'
	-------------------
	stringify_crefs(TUPLE(expl)) => TUPLE(expl')

  rule	stringify_crefs(e1) => e1'
	--------------------------
	stringify_crefs(CAST(t,e1)) => CAST(t,e1')

  rule	stringify_crefs(e1) => e1' 
	--------------------------
	stringify_crefs(ASUB(e1,i)) => ASUB(e1',i)

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	--------------------------
	stringify_crefs(SIZE(e1,SOME(e2))) => SIZE(e1',SOME(e2'))

  rule	stringify_crefs(e1) => e1'
	--------------------------
	stringify_crefs(SIZE(e1,NONE)) => SIZE(e1',NONE)

  axiom	stringify_crefs(e as CODE(_,_)) => e

  rule	stringify_crefs(e1) => e1' &
	stringify_crefs(e2) => e2' 
	--------------------------
	stringify_crefs( REDUCTION(p,e1,id,e2)) => REDUCTION(p,e1',id,e2')

  axiom	stringify_crefs END => END
  axiom	stringify_crefs (e) => e
end


relation dump_exp_graphviz : Exp => Graphviz.Node =
	
  axiom dump_exp_graphviz(END) => Graphviz.NODE("END",[],[])
  
  rule	int_string(x) => s
	----------------------------
	dump_exp_graphviz(ICONST(x)) => Graphviz.LNODE("ICONST",[s],[],[])

  rule	real_string(x) => s
	-----------------------------
	dump_exp_graphviz(RCONST(x)) => Graphviz.LNODE("RCONST",[s],[],[])

  rule	string_append ("\"", s) => s' &
	string_append (s', "\"") => s''
	---------------------------------
	dump_exp_graphviz(SCONST(s)) => Graphviz.LNODE("SCONST",[s''],[],[])

  axiom	dump_exp_graphviz(BCONST(false)) => Graphviz.LNODE("BCONST",["false"],[],[])

  axiom	dump_exp_graphviz(BCONST(true)) => Graphviz.LNODE("BCONST",["true"],[],[])

  rule	print_component_ref_str (c) => s
	--------------------------------
	dump_exp_graphviz(CREF(c,_)) => Graphviz.LNODE("CREF",[s],[],[])

  rule	binop_symbol(op) => sym &
	dump_exp_graphviz (e1) => lt & 
	dump_exp_graphviz (e2) => rt
	----------------------------
	dump_exp_graphviz (BINARY(e1, op, e2)) => Graphviz.LNODE("BINARY",[sym],[],[lt,rt])

  rule	unaryop_symbol(op) => sym &
	dump_exp_graphviz (e) => ct
	----------------------------
	dump_exp_graphviz(UNARY(op, e)) => Graphviz.LNODE("UNARY",[sym],[],[ct])

  rule	lbinop_symbol(op) => sym &
	dump_exp_graphviz (e1) => lt & 
	dump_exp_graphviz (e2) => rt
	----------------------------------------------------------------
	dump_exp_graphviz(LBINARY(e1, op, e2)) => Graphviz.LNODE("LBINARY",[sym],[],[lt,rt])

  rule	lunaryop_symbol(op) => sym &
 	dump_exp_graphviz (e) => ct
	---------------------------------------------------
	dump_exp_graphviz(LUNARY(op, e)) =>  Graphviz.LNODE("LUNARY",[sym],[],[ct])

  rule	relop_symbol(op) => sym &
 	dump_exp_graphviz(e1) => lt & 
	dump_exp_graphviz(e2) => rt
	-----------------------------------------------------------------
	dump_exp_graphviz(RELATION(e1, op, e2)) =>  Graphviz.LNODE("RELATION",[sym],[],[lt,rt])

  rule	dump_exp_graphviz(c) => ct &
	dump_exp_graphviz(t) => tt &
	dump_exp_graphviz(f) => ft
	----------------------------
	dump_exp_graphviz(IFEXP(c,t,f)) =>  Graphviz.NODE("IFEXP",[],[ct,tt,ft])

  rule	Absyn.path_string(fcn) => fs &
	Util.list_map(args, dump_exp_graphviz) => argnodes
	---------------------------------------------
	dump_exp_graphviz(CALL(fcn, args,_,_)) => Graphviz.LNODE("CALL",[fs],[],argnodes)

  rule	Util.list_map(es, dump_exp_graphviz) => nodes
	-----------------------------
	dump_exp_graphviz (ARRAY(_,_,es)) => Graphviz.NODE("ARRAY",[],nodes)

  rule	Util.list_map(es, dump_exp_graphviz) => nodes
	-----------------------------
	dump_exp_graphviz (TUPLE(es)) => Graphviz.NODE("TUPLE",[],nodes)

	
  rule	print_list_str(es, print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s''
	-----------------------------
	dump_exp_graphviz (MATRIX(_,_,es)) => Graphviz.LNODE("MATRIX",[s''],[],[])

  rule	dump_exp_graphviz (start) => t1 &
	let t2 = Graphviz.NODE(":",[],[]) &
	dump_exp_graphviz (stop) => t3
	-------------------------------------------------------------
	dump_exp_graphviz (RANGE(_,start,NONE,stop)) => Graphviz.NODE("RANGE",[],[t1,t2,t3])

  rule	dump_exp_graphviz (start) => t1 &
	dump_exp_graphviz (step) => t2 &
 	dump_exp_graphviz (stop) => t3
	-------------------------------------
	dump_exp_graphviz (RANGE(_,start,SOME(step),stop)) => Graphviz.NODE("RANGE",[],[t1,t2,t3])

  rule	type_string ty => tystr &
	dump_exp_graphviz e => ct
	---------------------------------------
	dump_exp_graphviz (CAST(ty,e)) => Graphviz.LNODE("CAST",[tystr],[],[ct])

  rule	dump_exp_graphviz (e) => ct &
 	int_string i => istr &
	Util.string_append_list(["[",istr,"]"]) => s
	---------------------------------------
	dump_exp_graphviz (ASUB(e,i)) => Graphviz.LNODE("ASUB",[s],[],[ct])

  rule	dump_exp_graphviz (cr) => crt &
 	dump_exp_graphviz (dim) => dimt
	------------------------
	dump_exp_graphviz (SIZE(cr,SOME(dim))) => Graphviz.NODE("SIZE",[],[crt,dimt])

  rule	dump_exp_graphviz (cr) => crt
	------------------------
	dump_exp_graphviz (SIZE(cr,NONE)) => Graphviz.NODE("SIZE",[],[crt])

  rule	Absyn.path_string fcn => fs &
	dump_exp_graphviz exp => expt &
	dump_exp_graphviz iterexp => itert
	-------------------------------------------------------
	dump_exp_graphviz (REDUCTION(fcn,exp,id,iterexp)) =>  Graphviz.LNODE("REDUCTION",[fs],[],[expt,itert])

  axiom	dump_exp_graphviz (_) => Graphviz.NODE("#UNKNOWN EXPRESSION# ----eeestr ",[],[])

end

(* Solves an equation consisting of a right hand side (rhs) and a left hand side (lhs),
 with respect to the expression given as third argument, usually a variable. *)
relation solve : (Exp, (* lhs *)
		  Exp, (* rhs *)
		  Exp) (* solve for *)
	  => Exp =

  rule	(* Special case when already solved, otherwise division by zero 
	 when dividing with derivative *)
	cref_equal(cr1,cr2) => true &
	exp_contains (rhs,crexp) => false 
	---------------------------------
	solve (crexp as CREF(cr1,_), rhs, CREF(cr2,_)) => rhs

  rule	(* Special case when already solved, otherwise division by zero 
	 when dividing with derivative *)
	cref_equal(cr1,cr2) => true &
	exp_contains (lhs,crexp) => false 
	---------------------------------
	solve (lhs, crexp as CREF(cr1,_), CREF(cr2,_)) => lhs

  rule	solve2 (lhs, rhs, cr) => res &
	simplify res => res'
	-------------------------------------
	solve (lhs,rhs, cr as CREF(_,_)) => res'
	
  rule	Print.print_buf "solve failed: Not an equation or trying to solve for\n" &
	Print.print_buf "a non-component-reference, or a non-linear equation:\n" &
	print_exp e1 &
	Print.print_buf "\n" &
	print_exp e2 &
	Print.print_buf "\n"
        ----------------------------------
	solve (e1, e2, e3) => fail
end

(** relation: solve2
 ** This relation solves an equation e1 = e2 with respect to the variable
 ** given as an expression e3 *)
relation solve2 : ( Exp (*e1*), Exp (*e2*), Exp(*e3*)) => Exp =

  rule	let lhs = BINARY(e1, SUB(REAL), e2) &
	Derive.differentiate_exp (lhs, cr) => lhsder &
	simplify (lhsder) => lhsder' &
	exp_contains (lhsder', crexp) => false &
	replace_exp (lhs, crexp, RCONST(0.0)) => (lhszero,_) &
	simplify (lhszero) => lhszero' &
	let rhs = UNARY(UMINUS(REAL), BINARY(lhszero', DIV(REAL), lhsder')) &
	simplify (rhs) => rhs' 
	(*
	& dump_exp_graphviz lhs => lhsnode 
	& Print.print_buf "------------------ LHS -----------------\n"
	& Graphviz.dump lhsnode
	& Print.print_buf "------------------ /LHS -----------------\n"
	 *)
	---------------------------------------
	solve2 (e1, e2, crexp as CREF(cr,_)) => rhs'


  rule	let lhs = BINARY(e1, SUB(REAL), e2) &
	Derive.differentiate_exp (lhs, cr) => lhsder &
	simplify lhsder => lhsder' &
	exp_contains (lhsder', crexp) => true &
	Print.print_buf "solve2 failed: Not linear: " &
	print_exp e1 &
	Print.print_buf " = " &
	print_exp e2 &
	Print.print_buf "\nsolving for: " &
	print_exp crexp &
	Print.print_buf "\n"
	---------------------------------------
	solve2 (e1, e2, crexp as CREF(cr,_)) => fail



  rule	Print.print_buf "solve2 failed: " &
	print_exp e1 &
	Print.print_buf " = " &
	print_exp e2 &
	Print.print_buf "\nsolving for: " &
	print_exp cr &
	Print.print_buf "\n"
        ----------------------------------
	solve2 (e1, e2, cr) => fail

end

relation get_terms_containing_x : (Exp, Exp) => (Exp, Exp) =

  rule	get_terms_containing_x (e1, cr) => (xt1, nonxt1) &
	get_terms_containing_x (e2, cr) => (xt2, nonxt2) &
	let xt = BINARY(xt1, ADD(ty), xt2) &
	let nonxt = BINARY(nonxt1, ADD(ty), nonxt2)
	---------------------------------------
	get_terms_containing_x (BINARY(e1, ADD(ty), e2), cr as CREF(_,_)) => (xt,nonxt)

  rule	get_terms_containing_x (e1, cr) => (xt1, nonxt1) &
	get_terms_containing_x (e2, cr) => (xt2, nonxt2) &
	let xt = BINARY(xt1, SUB(ty), xt2) &
	let nonxt = BINARY(nonxt1, SUB(ty), nonxt2)
	---------------------------------------
	get_terms_containing_x (BINARY(e1, SUB(ty), e2), cr as CREF(_,_)) => (xt,nonxt)

  rule	get_terms_containing_x (e, cr) => (xt1, nonxt1) &
	let xt = UNARY(UPLUS(ty), xt1) &
	let nonxt = UNARY(UPLUS(ty), nonxt1)
	---------------------------------------
	get_terms_containing_x (UNARY(UPLUS(ty), e), cr as CREF(_,_)) => (xt,nonxt)

  rule	get_terms_containing_x (e, cr) => (xt1, nonxt1) &
	let xt = UNARY(UMINUS(ty), xt1) &
	let nonxt = UNARY(UMINUS(ty), nonxt1)
	---------------------------------------
	get_terms_containing_x (UNARY(UMINUS(ty), e), cr as CREF(_,_)) => (xt,nonxt)

  rule	exp_contains (e, cr) => res &
	Util.if(res, e, RCONST(0.0)) => xt &
	Util.if(res, RCONST(0.0), e) => nonxt
	-----------------------------------
	get_terms_containing_x (e, cr as CREF(_,_)) => (xt, nonxt)

  rule	Print.print_buf "get_terms_containing_x failed: " &
	print_exp e &
	Print.print_buf "\nsolving for: " &
	print_exp cr &
	Print.print_buf "\n"
        ----------------------------------
	get_terms_containing_x (e, cr) => fail

end

relation print_bool : bool => () =

  rule	Util.if (b, "true", "false") => str &
	Print.print_buf str
	-----------------------------------
	print_bool b

end	

(* Only component references can be checked so far,
   i.e. check whether an expression contains a given component reference *)

relation exp_contains : (Exp, Exp) => bool =

  axiom	exp_contains (ICONST(i), cr as CREF(_,_)) => false
  axiom	exp_contains (RCONST(i), cr as CREF(_,_)) => false
  axiom	exp_contains (SCONST(i), cr as CREF(_,_)) => false
  axiom	exp_contains (BCONST(i), cr as CREF(_,_)) => false

  rule	cref_equal (cr1, cr2) => res
	---------------------------
	exp_contains (c1 as CREF(cr1,_), c2 as CREF(cr2,_)) => res
	
  rule	exp_contains (e1, cr) => res1 &
	exp_contains (e2, cr) => res2 &
	bool_or (res1, res2) => res
	------------------------
	exp_contains (BINARY(e1, op, e2), cr as CREF(_,_)) => res

  rule	exp_contains (e, cr) => res
	----------------------------
	exp_contains (UNARY(op, e), cr as CREF(_,_)) => res

  rule	exp_contains (e1, cr) => res1 &
	exp_contains (e2, cr) => res2 &
	bool_or (res1, res2) => res
	----------------------------------------------------------------
	exp_contains (LBINARY(e1, op, e2), cr as CREF(_,_)) => res

  rule	exp_contains (e, cr) => res
	---------------------------------------------------
	exp_contains (LUNARY(op, e), cr as CREF(_,_)) => res

  rule	exp_contains (e1, cr) => res1 &
	exp_contains (e2, cr) => res2 &
	bool_or (res1, res2) => res
	-----------------------------------------------------------------
	exp_contains (RELATION(e1, op, e2), cr as CREF(_,_)) => res

  rule	exp_contains (c, cr) => res1 &
	exp_contains (t, cr) => res2 &
	exp_contains (f, cr) => res3 &
	Util.bool_or_list ([res1, res2, res3]) => res
	---------------------------------------------
	exp_contains (IFEXP(c,t,f), cr as CREF(_,_)) => res

  rule	Util.list_map_1 (args, exp_contains, cr) => reslist &
	Util.bool_or_list reslist => res
	--------------------------------
	exp_contains (CALL(fcn, args,_,_), cr as CREF(_,_)) => res


  axiom	exp_contains (CAST(REAL,ICONST(i)), cr as CREF(_,_)) => false


  rule	exp_contains (e, cr) => res
	---------------------------------------
	exp_contains (CAST(REAL,e), cr as CREF(_,_)) => res


  rule	exp_contains (e, cr) => res
	---------------------------------------
	exp_contains (ASUB(e,i), cr as CREF(_,_)) => res


  rule	Print.print_buf "exp_contains failed: When looking for \"" &
	print_exp  cr &
	Print.print_buf "\" in \"" &
	print_exp  e &
	Print.print_buf "\n"
        ----------------------------------
	exp_contains (e, cr) => fail


end


relation get_cref_from_exp: ( Exp ) => ComponentRef list =

  axiom	get_cref_from_exp(ICONST(_)) => []
  axiom	get_cref_from_exp(RCONST(_)) => []
  axiom	get_cref_from_exp(SCONST(_)) => []
  axiom	get_cref_from_exp(BCONST(_)) => []
  axiom	get_cref_from_exp(CREF(cr,_)) => [cr]

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(BINARY(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => res
	----------------------------
	get_cref_from_exp(UNARY(op,e1)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(LBINARY(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => res
	----------------------------
	get_cref_from_exp(LUNARY(op,e1)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_exp(RELATION(e1,op,e2)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res1 &
	get_cref_from_exp(e3) => l3 &
	list_append(res1,l3) => res
	---------------------------
	get_cref_from_exp(IFEXP(e1,e2,e3)) => res
	
  rule	Util.list_map(farg,get_cref_from_exp) => res &
	Util.list_flatten(res) => res2
	--------------------------------------------
	get_cref_from_exp(CALL(_,farg,_,_)) => res2


  rule	Util.list_map(expl,get_cref_from_exp) => res1 &
	Util.list_flatten(res1) => res
	--------------------------------------------
	get_cref_from_exp(ARRAY(_,_,expl)) => res

  rule	print "get_cref_from_exp MATRIX not impl. yet\n" 
	----------------
	get_cref_from_exp(MATRIX(_,_,_)) => []

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res1 &
	get_cref_from_exp(e3) => l3 &
	list_append(res1,l3) => res
	---------------------------
	get_cref_from_exp(RANGE(_,e1,SOME(e3),e2)) => res

  rule	get_cref_from_exp(e1) => l1 &
	get_cref_from_exp(e2) => l2 &
	list_append(l1,l2) => res 
	---------------------------
	get_cref_from_exp(RANGE(_,e1,NONE,e2)) => res
	    
  rule	(*Util.list_map(expl,get_cref_from_exp) => res*)
	Print.print_buf "Not implemented yet\n" 
	------------------
	get_cref_from_exp(TUPLE(expl)) => []

  rule	get_cref_from_exp(e) => res
	---------------------------
	get_cref_from_exp(CAST(_,e)) => res

  rule	get_cref_from_exp(e) => res
	---------------------------
	get_cref_from_exp(ASUB(e,_)) => res

  axiom	get_cref_from_exp(_) => []
end