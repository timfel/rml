---------------------------------------------------
	Exp1:
---------------------------------------------------

package exp1

  uniontype Exp
      record RCONST
          Real x1;
    end RCONST;
    record ADDop
          Exp x1;
      Exp x2;
    end ADDop;
    record SUBop
          Exp x1;
      Exp x2;
    end SUBop;
    record MULop
          Exp x1;
      Exp x2;
    end MULop;
    record DIVop
          Exp x1;
      Exp x2;
    end DIVop;
    record NEGop
          Exp x1;
    end NEGop;
  end Exp;

  function eval
      input Exp in_value1;
    output Real out_value1;
  algorithm 
    out_value1:=
    match in_value1
        Real ival;
        Real v1;
        Exp e1;
        Exp e2;
        Exp e;
        case RCONST(ival) then ival;
        case ADDop(e1,e2)
          equation 
            eval(e1) = v1;
            eval(e2) = v2;
            real_add(v1, v2) = v3;
            then v3;
        case SUBop(e1,e2)
          equation 
            eval(e1) = v1;
            eval(e2) = v2;
            real_sub(v1, v2) = v3;
            then v3;
        case MULop(e1,e2)
          equation 
            eval(e1) = v1;
            eval(e2) = v2;
            real_mul(v1, v2) = v3;
            then v3;
        case DIVop(e1,e2)
          equation 
            eval(e1) = v1;
            eval(e2) = v2;
            real_div(v1, v2) = v3;
            then v3;
        case NEGop(e)
          equation 
            eval(e) = v1;
            real_neg(v1) = v2;
            then v2;
    end match;
  end eval;
end exp1;

---------------------------------------------------
	Exp2:
---------------------------------------------------

package exp2
  uniontype Exp
      record INT
          Integer x1;
    end INT;
    record BINARY
          Exp x1;
      BinOp x2;
      Exp x3;
    end BINARY;
    record UNARY
          UnOp x1;
      Exp x2;
    end UNARY;
  end Exp;
  uniontype BinOp
      record ADD
    end ADD;
    record SUB
    end SUB;
    record MUL
    end MUL;
    record DIV
    end DIV;
  end BinOp;
  uniontype UnOp
      record NEG
    end NEG;
  end UnOp;
  function eval
      input Exp in_value1;
    output Integer out_value1;
  algorithm 
    out_value1:=
    match in_value1
        Integer ival;
        Integer v1;
        Integer v2;
        Integer v3;
        Exp e1;
        BinOp binop;
        Exp e2;
        UnOp unop;
        Exp e;
        case INT(ival) then ival;
        case BINARY(e1,(binop,e2))
          equation 
            eval(e1) = v1;
            eval(e2) = v2;
            apply_binop(binop, v1, v2) = v3;
            then v3;
        case UNARY(unop,e)
          equation 
            eval(e) = v1;
            apply_unop(unop, v1) = v2;
            then v2;
    end match;
  end eval;
  function apply_binop
      input BinOp in_value1;
    input Integer in_value2;
    input Integer in_value3;
    output Integer out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2,in_value3)
        Integer v3;
        Integer v1;
        Integer v2;
        case (ADD,(v1,v2))
          equation 
            int_add(v1, v2) = v3;
            then v3;
        case (SUB,(v1,v2))
          equation 
            int_sub(v1, v2) = v3;
            then v3;
        case (MUL,(v1,v2))
          equation 
            int_mul(v1, v2) = v3;
            then v3;
        case (DIV,(v1,v2))
          equation 
            int_div(v1, v2) = v3;
            then v3;
    end match;
  end apply_binop;
  function apply_unop
      input UnOp in_value1;
    input Integer in_value2;
    output Integer out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2)
        Integer v2;
        Integer v;
        case (NEG,v)
          equation 
            int_neg(v) = v2;
            then v2;
    end match;
  end apply_unop;
end exp2;

---------------------------------------------------
	ASSIGNMENT:(errors!)
---------------------------------------------------
package assignment
  uniontype Program
      type ExpList = list<Exp>;
    record PROGRAM
          ExpList x1;
      Exp x2;
    end PROGRAM;
  end Program;
  uniontype Exp
      record INT
          Integer x1;
    end INT;
    record BINARY
          Exp x1;
      BinOp x2;
      Exp x3;
    end BINARY;
    record UNARY
          UnOp x1;
      Exp x2;
    end UNARY;
    record ASSIGN
          Ident x1;
      Exp x2;
    end ASSIGN;
    record IDENT
          Ident x1;
    end IDENT;
  end Exp;
  uniontype BinOp
      record ADD
    end ADD;
    record SUB
    end SUB;
    record MUL
    end MUL;
    record DIV
    end DIV;
  end BinOp;
  uniontype UnOp
      record NEG
    end NEG;
  end UnOp;
  type Ident = String;
  type Value = Integer;
  function lookup
      input Env in_value1;
    input Ident in_value2;
    output Value out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2)
        String id2;
        Integer value;
        String id;
        StringIntegerRecordList rest;
        case (cons((id2,value),_),id)
          equation 
id = id2;
            then value;
        case (cons((id2,_),rest),id)
          equation 
not id = id2;
            lookup(rest, id) = value;
            then value;
    end match;
  end lookup;
  function lookupextend
      input Env in_value1;
    input Ident in_value2;
    output Env out_value1;
    output Value out_value2;
  algorithm 
    out_value1:=
    match (in_value1,in_value2)
        StringIntegerRecordList env;
        String id;
        Integer value;
        case (env,id)
          equation 
not             lookup(env, id) = v;
            then (#UNKNOWN EXPRESSION#,0);
        case (env,id)
          equation 
            lookup(env, id) = value;
            then (env,value);
    end match;
  end lookupextend;
  function update
      input Env in_value1;
    input Ident in_value2;
    input Value in_value3;
    output Env out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2,in_value3)
        StringIntegerRecordList env;
        String id;
        Integer value;
        case (env,(id,value))            then #UNKNOWN EXPRESSION#;
    end match;
  end update;
  function evalprogram
      input Program in_value1;
    output Integer out_value1;
  algorithm 
    out_value1:=
    match in_value1
        ExpList assignments';
        StringIntegerRecordList env2;
        Integer value;
        ExpList assignments;
        Exp exp;
        case PROGRAM(assignments,exp)
          equation 
print("evp1
");
            list_reverse(assignments) = assignments';
print("evp2
");
            evals(#UNKNOWN EXPRESSION#, assignments') = env2;
print("evp3
");
            eval(env2, exp) = (_,value);
print("evp4
");
            then value;
    end match;
  end evalprogram;
  function evals
      input Env in_value1;
    input ExpList in_value2;
    output Env out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2)
        StringIntegerRecordList e;
        StringIntegerRecordList env2;
        Integer v;
        String s;
        StringIntegerRecordList env3;
        StringIntegerRecordList env;
        Exp exp;
        ExpList expl;
        case (e,)            then e;
        case (env,cons(exp,expl))
          equation 
            eval(env, exp) = (env2,v);
            int_string(v) = s;
print("v: ");
print(s);
print("
");
            evals(env2, expl) = env3;
            then env3;
    end match;
  end evals;
  function eval
      input Env in_value1;
    input Exp in_value2;
    output Env out_value1;
    output Integer out_value2;
  algorithm 
    out_value1:=
    match (in_value1,in_value2)
        StringIntegerRecordList env;
        Integer ival;
        StringIntegerRecordList env2;
        Integer value;
        String s;
        String id;
        StringIntegerRecordList env3;
        Exp exp;
        Integer v1;
        Integer v2;
        Integer v3;
        StringIntegerRecordList env1;
        Exp e1;
        BinOp binop;
        Exp e2;
        UnOp unop;
        Exp e;
        case (env,INT(ival))            then (env,ival);
        case (env,IDENT(id))
          equation 
            lookupextend(env, id) = (env2,value);
            int_string(value) = s;
print("lookup: ");
print(s);
print("
");
            then (env2,value);
        case (env,ASSIGN(id,exp))
          equation 
            eval(env, exp) = (env2,value);
            update(env2, id, value) = env3;
            then (env3,value);
        case (env1,BINARY(e1,(binop,e2)))
          equation 
            eval(env1, e1) = (env2,v1);
            eval(env2, e2) = (env3,v2);
            apply_binop(binop, v1, v2) = v3;
            then (env3,v3);
        case (env1,UNARY(unop,e))
          equation 
            eval(env1, e) = (env2,v1);
            apply_unop(unop, v1) = v2;
            then (env2,v2);
    end match;
  end eval;
  function apply_binop
      input BinOp in_value1;
    input Integer in_value2;
    input Integer in_value3;
    output Integer out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2,in_value3)
        Integer v3;
        Integer v1;
        Integer v2;
        case (ADD,(v1,v2))
          equation 
            int_add(v1, v2) = v3;
            then v3;
        case (SUB,(v1,v2))
          equation 
            int_sub(v1, v2) = v3;
            then v3;
        case (MUL,(v1,v2))
          equation 
            int_mul(v1, v2) = v3;
            then v3;
        case (DIV,(v1,v2))
          equation 
            int_div(v1, v2) = v3;
            then v3;
    end match;
  end apply_binop;
  function apply_unop
      input UnOp in_value1;
    input Integer in_value2;
    output Integer out_value1;
  algorithm 
    out_value1:=
    match (in_value1,in_value2)
        Integer v2;
        Integer v;
        case (NEG,v)
          equation 
            int_neg(v) = v2;
            then v2;
    end match;
  end apply_unop;
end assignment;
