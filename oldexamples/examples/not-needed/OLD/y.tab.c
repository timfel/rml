# define ENUMERATION 257
# define PUBLIC 258
# define EXTERNAL 259
# define OVERLOAD 260
# define IMPORT 261
# define PROTECTED 262
# define INNER 263
# define OUTER 264
# define IF 265
# define THEN 266
# define ELSE 267
# define ELSEIF 268
# define END 269
# define FOR 270
# define LOOP 271
# define IN 272
# define REPLACEABLE 273
# define WHEN 274
# define WHILE 275
# define ELSEWHEN 276
# define CONNECT 277
# define INITIAL 278
# define ANNOTATION 279
# define TRUE 280
# define FALSE 281
# define ASSIGN 282
# define REDECLARE 283
# define EQUATION 284
# define ALGORITHM 285
# define EXTENDS 286
# define CODE 287
# define T_class 288
# define T_model 289
# define T_record 290
# define T_block 291
# define T_connector 292
# define T_package 293
# define T_function 294
# define T_flow 295
# define T_discrete 296
# define T_parameter 297
# define T_const 298
# define T_input 299
# define T_output 300
# define T_encapsulated 301
# define T_partial 302
# define T_within 303
# define T_final 304
# define T_each 305
# define T_and 306
# define T_as 307
# define T_abstype 308
# define T_axiom 309
# define T_datatype 310
# define T_default 311
# define T_end 312
# define T_eqtype 313
# define T_fail 314
# define T_interface 315
# define T_let 316
# define T_module 317
# define T_not 318
# define T_of 319
# define T_or 320
# define T_relation 321
# define T_rule 322
# define T_type 323
# define T_val 324
# define T_with 325
# define T_withtype 326
# define LBRACK 327
# define RBRACK 328
# define LBRACE 329
# define RBRACE 330
# define LPAR 331
# define RPAR 332
# define DOT 333
# define COLON 334
# define COLONCOLON 335
# define COMMA 336
# define DASHES 337
# define PIPEBAR 338
# define AMPERSAND 339
# define SEMICOLON 340
# define YIELDS 341
# define STAR 342
# define WILD 343
# define EQUALS 344
# define PLUS 345
# define MINUS 346
# define DIV 347
# define LESS 348
# define LESSEQ 349
# define GREATER 350
# define GREATEREQ 351
# define EQEQ 352
# define LESSGT 353
# define SLASH 354
# define POWER 355
# define UNSIGNED_INTEGER 356
# define UNSIGNED_REAL 357
# define STRING 358
# define IDENT 359
# define TYVARIDENT 360
# define CCON 361
# define ICON 362
# define RCON 363
# define SCON 364

# line 26 "parser.y"
#include <stdio.h>
#include "yacclib.h"
#include "rml.h"
#include "absyn-decl.h"
#include "../interactive.h"
#define MAXCOMMENT 2000
extern int yylineno;
extern char yaccCommentBuffer[];

#include <inttypes.h>

#ifdef __STDC__
#include <stdlib.h>
#include <string.h>
#define	YYCONST	const
#else
#include <malloc.h>
#include <memory.h>
#define	YYCONST
#endif

#include <values.h>

#if defined(__cplusplus) || defined(__STDC__)

#if defined(__cplusplus) && defined(__EXTERN_C__)
extern "C" {
#endif
#ifndef yyerror
#if defined(__cplusplus)
	void yyerror(YYCONST char *);
#endif
#endif
#ifndef yylex
	int yylex(void);
#endif
	int yyparse(void);
#if defined(__cplusplus) && defined(__EXTERN_C__)
}
#endif

#endif

#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
#ifndef YYSTYPE
#define YYSTYPE int
#endif
YYSTYPE yylval;
YYSTYPE yyval;
typedef int yytabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH > 0
int yy_yys[YYMAXDEPTH], *yys = yy_yys;
YYSTYPE yy_yyv[YYMAXDEPTH], *yyv = yy_yyv;
#else	/* user does initial allocation */
int *yys;
YYSTYPE *yyv;
#endif
static int yymaxdepth = YYMAXDEPTH;
# define YYERRCODE 256

# line 1661 "parser.y"


#define PCOMMENTBUF 2000

static char parserCommentBuffer[PCOMMENTBUF+10];

#define MAXPOSINDEX   50
static int posIndex  = 0;
static int posLineNo[MAXPOSINDEX+1];

void positionPush()
{
    if (++posIndex > 50)
	yyerror("Internal error: positionPush(): overflow.\n");
    posLineNo[posIndex] = yylineno;
}

void positionPop()
{
    if (--posIndex < 0)
	yyerror("Internal error: positionPop(): underflow.\n");
}

int positionLineNo()
{
    return posLineNo[posIndex];
}

char *positionFileName()
{
    return "NoFile";
}

void *parser_make_element(int   is_final,
			  void *innerouter,
			  int   is_replaceable,
			  void *classdef,
			  void *componentclause,
			  void *constraint,
			  void *comment)
{
    void *final       = is_final ? RML_TRUE : RML_FALSE;
    void *replaceable = is_replaceable ? RML_TRUE : RML_FALSE;

    if (componentclause)
    {
	/* Declaration. */
	return Absyn__ELEMENT(final,
			      replaceable,
			      is_replaceable ? Absyn__UNSPECIFIED : innerouter,
			      mk_scon(is_replaceable ? "replaceable component"
                                                     : "component"),
			      componentclause,
			      mk_scon(positionFileName()),
			      mk_scon(positionLineNo()),
			      constraint ? mk_some(constraint) : mk_none());
    }
    else if (classdef)
    {
	/* Definition. */
	return Absyn__ELEMENT(final,
			      replaceable,
			      is_replaceable ? Absyn__UNSPECIFIED : innerouter,
			      mk_scon(is_replaceable ? "?replaceable classdef?"
                                                     : "?classdef?"),
			      Absyn__CLASSDEF(replaceable, classdef),
			      mk_scon(positionFileName()),
			      mk_scon(positionLineNo()),
			      constraint ? mk_some(constraint) : mk_none());

    }
    else
	yyerror("Internal error in parser_make_element().\n");
}

void **tempQuadMake(void *v1, void *v2, void *v3, void *v4)
{
    void **quad = malloc(sizeof(void *)*4);
    if (!quad)
	yyerror("Out of memory.");
    quad[0] = v1;
    quad[1] = v2;
    quad[2] = v3;
    quad[3] = v4;
    return quad;
}

void *tempQuadGet(void **quad, int element)
{
    if (!quad || element < 0 || element > 3)
	yyerror("Internal error: tempQuadGet(): bad arguments.");
    return quad[element];
}

void tempQuadFree(void **quad)
{
    if (quad)
	free(quad);
}
static YYCONST yytabelem yyexca[] ={
-1, 0,
	0, 18,
	296, 42,
	297, 42,
	298, 42,
	299, 42,
	300, 42,
	304, 18,
	359, 42,
	-2, 8,
-1, 1,
	0, -1,
	-2, 0,
-1, 6,
	0, 59,
	-2, 12,
-1, 29,
	358, 254,
	-2, 253,
-1, 30,
	358, 254,
	-2, 253,
-1, 47,
	0, 59,
	-2, 12,
-1, 179,
	258, 82,
	259, 82,
	262, 82,
	278, 82,
	284, 82,
	285, 82,
	296, 42,
	297, 42,
	298, 42,
	299, 42,
	300, 42,
	312, 82,
	359, 42,
	-2, 83,
-1, 235,
	341, 390,
	-2, 380,
-1, 298,
	296, 42,
	297, 42,
	298, 42,
	299, 42,
	300, 42,
	359, 42,
	-2, 8,
-1, 331,
	258, 82,
	259, 82,
	262, 82,
	278, 82,
	284, 82,
	285, 82,
	312, 82,
	-2, 83,
-1, 332,
	258, 82,
	259, 82,
	262, 82,
	278, 82,
	284, 82,
	285, 82,
	312, 82,
	-2, 83,
-1, 339,
	258, 82,
	259, 82,
	262, 82,
	278, 82,
	284, 82,
	285, 82,
	312, 82,
	-2, 83,
-1, 340,
	258, 82,
	259, 82,
	262, 82,
	278, 82,
	284, 82,
	285, 82,
	312, 82,
	-2, 83,
-1, 374,
	358, 254,
	-2, 253,
-1, 398,
	296, 42,
	297, 42,
	298, 42,
	299, 42,
	300, 42,
	359, 42,
	-2, 8,
-1, 445,
	296, 42,
	297, 42,
	298, 42,
	299, 42,
	300, 42,
	359, 42,
	-2, 8,
-1, 453,
	358, 254,
	-2, 253,
-1, 487,
	342, 338,
	345, 338,
	346, 338,
	347, 338,
	-2, 320,
-1, 521,
	296, 42,
	297, 42,
	298, 42,
	299, 42,
	300, 42,
	359, 42,
	-2, 8,
-1, 585,
	327, 398,
	331, 398,
	343, 398,
	358, 398,
	359, 398,
	361, 398,
	362, 398,
	363, 398,
	-2, 362,
-1, 586,
	327, 399,
	331, 399,
	343, 399,
	358, 399,
	359, 399,
	361, 399,
	362, 399,
	363, 399,
	-2, 363,
-1, 633,
	328, 363,
	332, 363,
	335, 363,
	336, 363,
	-2, 399,
-1, 648,
	358, 254,
	-2, 253,
-1, 649,
	358, 254,
	-2, 253,
	};
# define YYNPROD 403
# define YYLAST 1206
static YYCONST yytabelem yyact[]={

   151,   149,   657,   650,    18,   609,   631,   634,   475,   213,
   632,    31,   646,   627,   240,   570,    36,   116,   539,   601,
   579,   555,   524,   216,   309,   630,   637,   206,    66,   569,
   578,    64,     4,   501,   454,   502,   259,   417,    61,   416,
   354,   451,   233,   405,   584,   610,   418,   325,   319,    47,
    36,   305,   602,   330,    49,   532,   400,    36,    36,   371,
     9,    52,   393,   125,   128,   127,   107,   304,   235,    53,
   303,   580,    19,   395,   432,   103,   431,   390,   150,   167,
   144,   143,   112,   113,   442,   114,   118,   126,    85,   160,
    71,   302,    55,   100,   236,   324,   236,   163,   165,    34,
   505,    25,   506,   381,   107,    88,   171,    33,   382,   205,
    65,   175,   384,   383,    90,   507,   203,   589,   131,   127,
   625,    32,   242,   107,   242,   107,    35,   147,   204,   148,
   592,   146,   272,   587,   144,   143,   261,   574,   271,   273,
   480,   126,   183,   242,   326,   135,   136,   459,   314,   242,
   410,   311,   312,   313,   261,   411,   140,   141,   142,    19,
   589,   430,   408,   409,   636,   681,   350,    72,    73,   376,
   199,   200,   131,   248,    74,   210,   587,   241,   241,   182,
   315,   147,   118,   148,   179,   274,   232,   229,   222,   242,
   107,   314,   242,   127,   311,   312,   313,    19,   260,   135,
   136,   180,   628,    89,   621,   322,   150,    57,   144,   143,
   140,   141,   142,    19,   568,   126,   260,   662,    56,   652,
   243,   297,   355,   241,   467,   241,   333,    67,   466,   458,
   241,   457,   340,   321,   589,   339,   288,   241,   636,    46,
   245,   253,    21,    20,   422,   713,   131,   239,   239,   714,
   587,    36,   563,   276,   277,   147,   496,   148,   567,   146,
   299,   678,   122,   486,   680,   314,   242,   316,   311,   312,
   313,   605,   318,   135,   136,   375,   487,   291,   426,   323,
   486,   675,   427,   427,   140,   141,   142,    19,   193,   194,
   195,   196,   197,   198,   310,   239,   531,   396,   573,   528,
   239,   496,   241,   656,   286,   227,   589,   239,   241,   218,
   582,   241,   185,   307,   387,   629,   210,   181,   389,   372,
   622,   402,   587,   241,   357,   314,   242,   241,   311,   312,
   313,   386,   224,   188,   177,   359,   176,   314,   242,   404,
   311,   312,   313,   290,    60,    59,    36,   329,   399,   453,
    36,   156,   327,   295,    57,   347,    58,   739,   730,   401,
   694,   346,   685,   677,   626,    87,   426,   462,   563,   593,
   449,   562,   375,   157,   460,   545,   530,   527,   413,   271,
   370,   488,   428,   472,   433,   391,   353,   436,   437,   438,
   439,   425,   294,   239,   285,   429,   226,   239,   217,   289,
   153,   214,   450,   241,   470,   684,    89,   463,   241,   241,
   241,   241,   241,   267,   407,   241,   372,   349,   348,   215,
   186,   504,   508,   321,   241,   683,   215,   495,   241,   287,
   465,   241,   184,    87,    36,   173,   468,   421,   189,   234,
   485,   520,   519,   423,   565,   358,   328,   373,   482,   166,
   420,   477,   494,   498,   679,   483,   448,   479,   190,   401,
   455,   489,   492,   493,   540,   514,   499,   481,   375,   375,
   512,   509,   526,   513,   156,   511,   490,   491,   523,   413,
   413,   413,   413,   174,   170,   525,   525,   241,   515,   516,
   157,   503,   510,    24,   239,   522,   157,   241,   239,   369,
   306,   239,   571,   484,   241,   558,   575,   504,   504,   586,
   357,   357,   372,   372,   534,   529,    17,     8,   521,    14,
   209,   359,   359,   585,   561,     8,   542,   543,   246,   453,
   560,   608,    36,   588,   345,   581,   564,   207,   590,   559,
    14,   577,   576,   469,   373,   566,     8,   254,   375,   375,
   255,   375,   375,   611,   595,   613,   614,   603,   591,   398,
    36,   607,    50,    51,   606,   369,   600,   257,   618,   504,
   598,   594,   271,   370,   241,   241,    68,   503,   503,   583,
    68,    14,   658,   633,   641,    14,   667,     8,   596,   597,
   633,   617,   599,   645,   705,   572,    14,   585,   640,   727,
   359,   359,   619,   721,   585,   359,   540,   588,   588,   478,
   659,   623,   624,   643,   588,   642,   648,   649,   118,   586,
   644,   647,   586,   241,   655,   121,   241,   525,   639,   241,
   586,   358,   358,   585,   664,   669,   585,   633,   672,   503,
   373,   373,   455,   588,   585,   581,   588,   682,   581,   670,
   676,   585,   671,   583,   588,   638,   581,   695,   674,   654,
   583,   588,   533,   673,   375,   187,   375,   549,   702,   698,
   704,   737,   691,   733,   693,   547,   548,   708,   703,   633,
   633,   586,   537,   538,   709,   710,   212,   692,   712,   583,
   711,   651,   583,   585,   585,   585,   726,   715,   700,   723,
   583,    10,   375,   588,   588,   588,   724,   583,   719,   717,
   686,   687,   647,   716,   572,   633,   359,   706,   359,   720,
   572,   729,   696,   121,   264,   665,   345,   375,   663,   585,
   375,   736,    95,   653,   738,   476,   740,   741,   732,   588,
   742,   743,   734,    97,    24,    94,    96,    93,   661,   583,
   583,   583,   212,   359,   365,   689,   310,   551,   728,   366,
   301,   127,   424,   368,   725,    67,   367,   150,    68,   144,
   143,   722,   415,   718,   150,   307,   144,   143,   616,   156,
   550,   546,   359,   126,   541,   583,   359,   314,   242,    80,
   311,   312,   313,    26,    27,    28,   536,   735,   351,   352,
    82,   157,    79,    81,    78,   275,   406,   131,   412,   388,
   731,   331,   337,   385,   131,   332,   147,   365,   148,    23,
   146,   557,   366,   147,     5,   148,   368,   146,   153,   367,
   150,   338,   144,   143,   135,   136,   168,   271,   273,   152,
   310,   135,   136,   139,   414,   140,   141,   142,   364,   115,
   446,   447,   140,   141,   142,    19,   137,   211,   310,   307,
   434,   435,   301,   403,   150,   397,   144,   143,   443,   444,
   131,   314,   242,   119,   311,   312,   313,   307,   258,   147,
   133,   148,   155,   146,   129,   172,   111,    76,   456,   314,
   242,   247,   311,   312,   313,   336,   335,   135,   136,   237,
   334,   132,   108,   461,   131,    69,   464,    91,   140,   141,
   142,   364,    75,   147,   635,   148,   310,   146,   308,   471,
   573,   473,   474,   150,    37,   144,   143,   300,   105,    48,
     2,   135,   136,   102,   356,   307,    16,   620,    22,   500,
   419,   320,   140,   141,   142,    19,   109,   314,   242,   238,
   311,   312,   313,   381,   104,   497,   225,   150,   382,   144,
   143,   223,   384,   383,   164,    99,   101,    68,    92,    77,
    98,    10,   147,    83,   148,   219,   146,    38,    39,    40,
    41,    42,    44,    45,    70,    63,    62,    54,    84,    -1,
   135,   136,   201,   202,   394,   392,   158,   535,   162,   292,
   159,   140,   141,   142,    19,    14,   147,   544,   148,   110,
   146,     8,    43,    15,   552,   145,   553,   208,   554,   376,
   138,   134,     3,   192,   110,    13,   130,    12,   161,   106,
   106,   256,   263,   191,   124,   140,   141,   142,    19,   220,
   298,   123,   666,   699,   106,   106,   688,    19,   221,   284,
   660,   380,   379,   169,   378,   377,   374,   363,   296,   262,
   282,   283,   362,   361,   317,   265,   360,   556,   154,   344,
   117,   343,   293,   279,   342,   278,   604,   231,   266,    86,
   280,   281,   270,   269,   120,   445,   612,   268,   341,   615,
   249,   518,    -1,   441,   517,   440,    30,    29,   452,   252,
   251,   244,   250,   110,   228,   178,    11,   230,     7,     6,
     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   106,     0,     0,   106,   106,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   668,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   169,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   690,
     0,     0,     0,     0,     0,     0,   697,     0,     0,   701,
     0,     0,     0,     0,     0,   707 };
static YYCONST yytabelem yypact[]={

   710,-10000000,   214,  -287,   -97,   -98,   189,-10000000,-10000000,   497,
  -287,-10000000,  -251,  -259,-10000000,  -287,   689,-10000000,  -101,-10000000,
-10000000,-10000000,-10000000,   216,-10000000,   263,-10000000,-10000000,-10000000,-10000000,
-10000000,  -126,    23,    11,    10,-10000000,    21,  -287,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,   189,   214,  -287,
-10000000,-10000000,-10000000,   297,  -268,-10000000,  -287,  -287,  -168,   479,
   479,-10000000,-10000000,   689,   106,-10000000,-10000000,-10000000,    75,-10000000,
  -231,-10000000,-10000000,-10000000,-10000000,   422,-10000000,   479,  -265,  -256,
  -256,  -287,  -287,-10000000,  -287,  -287,-10000000,   -72,-10000000,    68,
  -268,-10000000,   422,  -269,  -256,  -256,  -287,  -287,   137,-10000000,
-10000000,  -280,-10000000,  -294,   178,  -287,-10000000,-10000000,   109,   177,
  -287,-10000000,     2,     0,  -143,-10000000,   -19,-10000000,   106,   104,
   -24,-10000000,-10000000,-10000000,-10000000,-10000000,    89,  -200,    -1,   118,
   152,   645,-10000000,   -60,  -175,   679,   679,-10000000,  -226,  -246,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -200,  -200,  -200,    70,
    88,   106,    66,-10000000,   -27,   189,   185,-10000000,-10000000,-10000000,
-10000000,-10000000,   109,  -156,-10000000,    -2,-10000000,-10000000,    64,   -31,
  -256,  -157,-10000000,  -256,  -256,  -158,  -235,  -235,-10000000,   301,
   290,  -287,-10000000,  -128,-10000000,   -72,  -146,   539,   586,   586,
   586,-10000000,   645,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,   645,
   645,-10000000,-10000000,   679,   679,   679,    62,   -32,   101,-10000000,
  -104,    69,     7,-10000000,  -200,    60,    20,-10000000,   191,  -287,
   189,-10000000,   429,  -164,  -235,-10000000,-10000000,  -294,-10000000,  -235,
-10000000,-10000000,  -287,-10000000,  -136,-10000000,  -237,  -198,-10000000,-10000000,
-10000000,-10000000,    19,-10000000,   134,   497,   553,  -105,  -108,   440,
  -287,-10000000,-10000000,   497,    87,    86,-10000000,-10000000,-10000000,  -178,
  -200,  -200,-10000000,    54,-10000000,-10000000,  -118,-10000000,-10000000,-10000000,
-10000000,   489,    95,   688,   496,  -200,    -3,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -200,-10000000,  -200,-10000000,
  -200,  -282,    53,  -286,-10000000,  -287,-10000000,  -128,   286,-10000000,
   -14,   531,-10000000,    83,-10000000,  -183,  -192,   513,-10000000,-10000000,
   429,-10000000,-10000000,-10000000,-10000000,   128,-10000000,-10000000,-10000000,-10000000,
   -94,   124,  -235,   -54,-10000000,    50,  -170,  -283,  -285,   263,
-10000000,   297,   297,   553,   553,   553,   553,  -274,   288,   297,
   297,-10000000,-10000000,-10000000,   587,  -287,   106,   263,  -287,  -287,
  -200,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -109,  -111,  -197,
-10000000,-10000000,-10000000,-10000000,    70,  -200,  -287,    76,  -200,-10000000,
   688,-10000000,  -112,  -116,-10000000,   261,  -200,-10000000,-10000000,-10000000,
-10000000,  -200,  -287,  -200,  -200,   467,   586,-10000000,-10000000,-10000000,
   337,-10000000,-10000000,-10000000,  -286,  -204,-10000000,-10000000,   224,-10000000,
-10000000,   497,   429,-10000000,   -56,    49,-10000000,   429,   513,   513,
   513,   513,-10000000,-10000000,   429,    99,-10000000,   -35,   142,   128,
  -216,  -287,  -287,  -170,-10000000,-10000000,-10000000,  -235,-10000000,-10000000,
  -235,-10000000,-10000000,  -287,   553,   553,-10000000,-10000000,-10000000,-10000000,
  -287,-10000000,-10000000,-10000000,-10000000,   245,-10000000,-10000000,    75,    75,
-10000000,    45,   -37,-10000000,    44,   -40,-10000000,   489,   489,  -200,
-10000000,   530,   411,  -287,   518,-10000000,   688,   688,-10000000,  -200,
    43,   515,   404,   396,   514,   490,  -200,-10000000,  -200,-10000000,
  -200,-10000000,   248,   248,   263,-10000000,   429,-10000000,-10000000,    39,
-10000000,-10000000,-10000000,-10000000,    36,-10000000,   429,   132,   128,-10000000,
   -79,-10000000,  -125,   589,  -207,  -287,  -216,  -216,   -21,-10000000,
-10000000,-10000000,   -53,    34,   106,-10000000,-10000000,  -118,-10000000,  -214,
    38,   224,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -287,-10000000,
-10000000,  -287,-10000000,-10000000,-10000000,-10000000,   552,   552,  -200,   -65,
   106,   552,-10000000,-10000000,-10000000,   249,  -162,  -162,  -200,  -162,
  -162,  -200,   512,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -287,
-10000000,   -73,-10000000,-10000000,-10000000,-10000000,-10000000,  -287,  -216,  -137,
-10000000,-10000000,   -15,   429,   429,  -224,-10000000,    32,  -139,-10000000,
-10000000,   -20,   -93,   -21,-10000000,-10000000,-10000000,-10000000,-10000000,   -93,
    75,   297,  -287,  -200,   248,   248,-10000000,-10000000,-10000000,-10000000,
-10000000,   423,  -121,   464,   388,  -287,   -30,   306,  -287,   480,
  -123,   459,   363,   456,   310,-10000000,  -200,  -287,   -21,-10000000,
-10000000,   -21,   513,   -80,-10000000,   429,-10000000,-10000000,   -33,  -210,
    31,-10000000,   -75,   147,-10000000,   -71,  -167,-10000000,-10000000,-10000000,
-10000000,-10000000,    97,-10000000,-10000000,    74,    30,-10000000,-10000000,-10000000,
   488,  -200,   552,   417,   552,    28,  -287,   453,  -200,    70,
   431,  -200,  -162,   408,  -162,   319,   448,  -200,   467,-10000000,
  -139,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,   -93,   -93,
   -93,-10000000,   -87,-10000000,  -200,-10000000,-10000000,-10000000,   444,   552,
   507,-10000000,-10000000,   439,-10000000,   106,   329,   505,-10000000,   430,
  -162,   498,-10000000,-10000000,   427,-10000000,   325,   492,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,   -93,    26,   545,-10000000,   552,   403,
-10000000,-10000000,   552,   532,-10000000,  -162,   401,-10000000,  -162,    25,
-10000000,-10000000,   423,-10000000,   306,-10000000,   423,-10000000,   306,-10000000,
-10000000,-10000000,-10000000,-10000000 };
static YYCONST yytabelem yypgo[]={

     0,  1110,   929,   936,   924,     0,    32,   824,  1109,   938,
  1108,   819,   882,    40,  1106,   110,    49,  1105,  1102,    60,
   101,    54,    69,  1101,    23,    22,    61,  1100,  1099,    41,
  1098,    34,    31,   849,    56,    17,  1097,  1096,   528,    53,
   226,   900,   896,   895,  1095,  1094,    28,  1093,  1092,     1,
  1091,    12,    27,   891,   173,  1090,  1088,   821,  1085,    21,
  1084,   537,   873,  1079,  1070,   567,   878,    36,   839,  1068,
   662,    52,    55,  1067,    59,    45,    63,  1066,  1063,  1062,
  1057,     9,  1056,  1055,  1054,  1052,  1051,     3,    19,  1050,
     5,  1046,  1043,     2,  1042,    18,  1041,  1034,  1032,     8,
    64,   884,  1026,   901,   880,  1023,  1021,   856,  1020,   843,
   520,  1017,  1015,   857,   999,   995,    62,   994,   989,   987,
   905,   984,   912,   907,   887,   970,   969,   886,   933,   902,
   885,    42,   968,    37,   964,   961,   956,    46,   955,   954,
   928,   946,    48,   941,    68,   940,   939,    30,    13,    29,
    33,    35,    70,   937,   927,    43,    91,    15,   502,    67,
    51,   500,   918,    24,   461,    39,    10,     7,   914,     6,
    26,    20,    71,    44,    14,    25,   439,   899,   949,    47,
   836 };
static YYCONST yytabelem yyr1[]={

     0,     1,     1,     1,     1,     1,     1,     2,     2,     3,
     3,    11,    11,    12,    12,    13,    13,     8,     8,    14,
    16,     4,     4,     4,     4,     4,     4,     4,     4,    18,
    17,    17,    17,    17,    27,    29,    29,    30,    28,    31,
    31,    19,    19,    20,    20,    20,    20,    21,    21,    21,
     6,    34,    23,     7,     7,    36,    37,    37,     9,     9,
    23,    39,    39,    39,    39,    39,    39,    39,    39,    47,
    44,    44,    48,    48,    45,    45,    50,    50,    51,    51,
    38,    38,    38,    55,    53,    56,    56,    56,    56,    56,
    56,    58,    58,    58,    60,    60,    62,    62,    63,    24,
    24,    32,    33,    33,    35,    64,    66,    66,    66,    66,
    65,    65,    67,    67,    25,    25,    68,    68,    69,    69,
    69,    69,    69,    41,    40,    70,    70,    72,    72,    73,
    59,    59,    57,    42,    43,    74,    74,    74,    71,    71,
    71,    71,    71,    71,    75,    82,    82,    82,    82,    82,
    82,    87,    87,    89,    89,    91,    91,    92,    92,    77,
    83,    78,    78,    84,    84,    85,    80,    93,    93,    86,
    94,    94,    88,    88,    90,    90,    79,    95,    95,    61,
    61,    61,    96,    98,    98,    98,    98,    98,    98,    98,
    97,    99,    99,    76,    76,    76,   100,   100,   101,   101,
   102,   102,   103,   105,   105,   105,   105,   105,   105,   104,
   104,   104,   106,   106,   106,   107,   107,   107,   108,   108,
   110,   110,   111,   109,   109,   109,   109,   109,   109,   109,
   109,   109,   112,   112,   112,    15,    15,    49,    49,    81,
   114,   115,   115,   113,   113,   113,   116,   116,   118,   117,
    52,    52,    26,    26,   119,    22,   121,   120,   120,    54,
    46,    46,     5,    10,    10,   125,   122,   124,   124,   126,
   126,   126,   126,   126,   126,   123,   123,   132,   132,   132,
   132,   132,   135,   135,   134,   130,   130,   128,   128,   139,
   129,   129,   141,   142,   142,   143,   143,   138,   138,   137,
   137,   145,   145,   148,   148,   148,   146,   146,   150,   150,
   151,   151,   151,   151,   151,   133,   133,   155,   155,   154,
   154,   154,   154,   157,   157,   156,   156,   159,   159,   159,
   160,   160,   160,   161,   161,   162,   162,   162,   162,   164,
   164,   165,   165,   158,   149,   149,   149,   166,   166,   167,
   167,   168,   168,   168,   168,   171,   171,   170,   170,   170,
   173,   173,   173,   173,   173,   153,   153,   147,   147,   147,
   172,   175,   175,   169,   169,   163,   163,   163,   163,   131,
   131,   144,   144,   177,   177,   177,   179,   179,   176,   176,
   176,   180,   180,   127,   140,   140,   140,   174,   152,   152,
     5,   178,   136 };
static YYCONST yytabelem yyr2[]={

     0,     9,     7,     5,     5,     5,     3,     3,     1,     3,
     1,     3,     1,     3,     1,     3,     1,     3,     1,     5,
    11,     3,     3,     3,     3,     3,     3,     3,     3,     7,
     9,    13,     5,     5,    11,     7,     3,     5,    11,     7,
     3,     3,     1,     3,     3,     3,     1,     3,     3,     1,
    13,    11,    13,     7,     7,     7,     7,     3,     7,     1,
     5,     7,     7,     5,     5,     5,     5,    11,     1,     3,
     3,     1,     5,     1,     3,     1,    13,     9,     3,     1,
     7,     7,     1,     1,     5,     3,     3,    13,     7,    13,
     7,     3,     3,     1,     3,     3,     7,     3,     7,     3,
     1,     3,     7,     3,     5,     7,     7,     3,     5,     5,
     3,     1,     7,     5,     3,     1,     7,     3,    11,    13,
    13,     9,     9,     5,     5,     7,     7,     3,     1,     3,
     3,     1,     7,     5,     7,     7,     7,     1,     7,     3,
     3,     3,     3,     5,     5,     7,    13,     3,     3,     3,
     3,    11,     1,    11,     1,     5,     1,     5,     1,    17,
    17,    13,    17,    13,    17,    13,    15,    11,     1,    15,
    11,     1,     7,     1,     7,     1,    13,    11,     5,     3,
     3,     3,     9,     3,     3,     5,     3,     3,     3,     3,
    15,    11,     1,    11,     7,     3,     7,     3,     7,     3,
     5,     3,     7,     3,     3,     3,     3,     3,     3,     2,
     7,     7,     5,     5,     3,     7,     7,     3,     7,     3,
     7,     3,     3,     3,     3,     3,     3,     3,     3,     7,
     7,     7,     5,     3,     7,     7,     3,     9,     5,     7,
     5,     3,     1,     7,    11,     7,     5,     1,     1,     7,
     7,     3,     5,     1,     1,     5,     3,     6,     2,     5,
     3,     1,     3,    11,     9,     1,     6,     5,     1,     5,
     7,     5,     7,     9,     9,     5,     1,     5,     5,     7,
     9,     5,     5,     3,    13,     1,     5,     7,     3,     9,
     7,     3,     9,     7,     3,     3,     7,     0,     5,     5,
     3,    13,     9,     1,     5,     5,     1,     3,     7,     3,
     7,     7,     9,     5,     7,     7,     3,     7,     3,     5,
     7,     7,     3,     7,     3,     5,     3,     7,     7,     3,
     7,     7,     3,     5,     3,     3,     3,     7,     7,     1,
     3,     7,     3,     7,     1,     3,     3,     7,     3,     7,
     3,     5,     7,    11,     3,     7,     3,     5,     5,     3,
     3,     3,     3,     3,     7,     1,     5,     1,     3,     3,
     7,     1,     3,     7,     3,     3,     3,     3,     3,     7,
     3,     7,     3,     7,     3,     3,     7,     7,     5,     7,
     3,     7,     3,     7,     1,     3,     3,     7,     3,     3,
     3,     3,     0 };
static YYCONST yytabelem yychk[]={

-10000000,    -1,    -2,   312,    -6,    -7,    -8,   -10,   301,   -19,
   261,   -14,   317,   315,   295,   303,    -3,   302,    -5,   359,
   340,   340,    -9,   -11,   304,   -20,   296,   297,   298,   -36,
   -37,    -5,   -15,   358,   358,   -15,    -5,    -4,   288,   289,
   290,   291,   292,   323,   293,   294,   340,   -16,    -2,   -21,
   299,   300,   -26,   -22,  -119,   -26,   344,   333,   333,   334,
   334,    -5,    -9,    -3,   -32,   -15,   -46,   -54,   279,  -120,
  -121,   358,   -15,   -15,   342,  -122,  -124,  -126,   325,   323,
   310,   324,   321,  -122,    -4,   -24,   -63,   327,   -67,   331,
   345,  -123,  -132,   325,   323,   310,   324,   321,  -125,  -124,
   358,  -127,  -128,   331,  -139,  -140,  -178,   360,  -129,  -141,
  -140,  -127,    -5,    -5,    -5,   -33,   -35,   -64,    -5,   -62,
   -60,   -61,   334,   -96,   -97,   -76,   287,   265,  -100,  -101,
  -102,   318,  -103,  -104,  -106,   345,   346,  -107,  -108,  -109,
   356,   357,   358,   281,   280,  -112,   331,   327,   329,   -49,
   278,    -5,   -68,   332,   -69,   -12,   283,   305,  -120,  -123,
   358,  -128,  -129,    -5,  -134,    -5,   312,   359,  -180,  -178,
   306,    -5,  -130,   326,   306,    -5,   334,   334,   -17,   -22,
   344,   336,   -26,   -24,   328,   336,   331,   -61,   334,   320,
   306,  -103,  -105,   348,   349,   350,   351,   352,   353,   345,
   346,  -107,  -107,   342,   354,   355,   -52,   -61,  -111,  -110,
   -52,  -113,   -61,   -81,   331,   331,   -24,   332,   336,   -11,
   -12,  -130,   344,  -135,   334,  -136,   332,   336,  -128,   344,
  -128,  -129,   344,  -131,  -176,  -144,   331,  -177,  -178,  -152,
  -174,    -5,   359,  -131,   -23,   -19,   -38,   -53,   -54,   -55,
   -18,   -27,   -28,   -19,   257,   260,   -33,   -65,   -66,   -67,
   344,   282,   -62,   -98,   -61,   -66,   -53,   -40,   -41,   -42,
   -43,   284,   278,   285,   331,   266,  -100,  -100,  -101,  -104,
  -104,  -104,  -107,  -107,  -109,   332,   336,   328,   340,   330,
   336,   270,  -114,  -113,   332,   333,   -68,   -49,   -11,  -133,
  -154,   331,  -156,  -152,  -159,  -160,  -161,   346,  -162,  -163,
   327,   361,   362,   363,   358,   344,  -131,  -180,  -131,  -142,
  -143,    -5,   341,  -131,   332,  -179,   342,   333,   312,   -20,
   -39,   258,   262,   -40,   -41,   -42,   -43,   259,   278,   340,
   340,   -56,    -7,   -57,   -11,   286,   -15,   -20,   331,   331,
   344,   -61,   -61,   332,   -13,   340,   -70,   -71,   -54,   -76,
   -77,   -78,   -79,   -80,   359,   265,   270,   277,   274,   -40,
   285,   -74,   -75,   -54,   -82,   -49,   331,   -83,   -84,   -85,
   -86,   265,   270,   275,   274,   -61,   334,   -52,  -110,   -52,
   359,   332,  -115,  -116,  -117,   359,   -49,   -65,   273,   -16,
   -34,   -19,   335,   332,  -133,  -155,  -158,   331,   345,   346,
   342,   347,  -161,  -152,   331,  -164,  -165,  -133,  -137,  -145,
   322,   309,   338,   319,  -176,  -144,   332,   336,   332,  -144,
   331,   359,   359,   -21,   -38,   -38,   -39,   -39,   -39,   -39,
   -44,   -47,   358,   -38,   -38,   -58,   263,   264,   -15,   -24,
   -21,   -29,   -30,    -5,   -31,   -15,   -61,   340,   340,   344,
   -81,   -61,    -5,   331,   -61,   -74,   340,   340,   -26,   282,
   -52,   -61,    -5,   -61,   -61,   -99,   268,  -100,   272,  -116,
   344,   -22,   -16,   -34,   -20,  -133,   336,   332,   332,  -164,
  -159,  -159,  -160,  -160,  -133,   328,   336,  -138,   311,  -137,
  -146,  -150,  -151,  -152,    -5,   316,   318,   331,    -5,  -142,
  -144,  -179,  -131,  -131,   -32,   -39,   -39,   -45,   -50,   -49,
    -5,   273,   -16,    -6,   -25,   -67,   -25,   332,   336,   -26,
   332,   336,   -72,   -70,   -72,   -61,   266,   271,   272,   -95,
    -5,   266,   -74,   -74,   -61,   332,   266,   271,   272,   271,
   266,   267,   -61,   -61,   -61,   -59,   -73,   -57,   -59,   -21,
  -155,  -133,   332,   332,  -165,   312,  -137,   337,   339,  -149,
  -157,  -158,  -156,   331,   344,    -5,  -151,  -150,  -147,  -171,
  -172,  -170,   331,  -152,  -173,  -174,    -5,   343,  -163,   327,
   -24,   -13,   344,   331,   -16,    -6,   -26,   -26,   -29,   -26,
   -31,   -88,   -71,   -88,   -61,   336,   -24,   -88,   282,   -90,
   -75,   -90,   -61,   -90,   -90,   -61,   266,   -32,    -5,  -150,
  -153,   341,   335,  -133,  -133,   344,   332,  -148,   341,   335,
  -175,  -169,  -166,    -5,  -167,  -168,   331,  -170,  -172,  -173,
  -174,    -5,  -175,   -25,   -46,    -5,   -51,   -52,   -59,   -59,
   -87,   268,   340,   269,   271,   -95,   333,   -93,   276,   -49,
   -89,   268,   340,   269,   271,   269,   -94,   276,   -61,   -35,
  -147,  -147,  -157,  -133,  -149,   314,  -171,   332,   336,   307,
   335,   332,  -166,   328,   331,   332,   -26,   -26,   -91,   267,
   -61,   -88,   270,   -88,   332,    -5,   269,   -61,   -81,   -92,
   267,   -61,   -90,   270,   -90,   275,   269,   -61,   -99,  -148,
  -169,  -166,  -167,   332,   336,   -51,   269,   -88,   266,   269,
   -24,   274,   266,   269,   -90,   266,   269,   274,   266,  -169,
   332,   265,   -88,   270,   -88,   265,   -90,   270,   -90,   332,
   -87,   -93,   -87,   -93 };
static YYCONST yytabelem yydef[]={

    -2,    -2,    10,     0,     0,     0,    -2,     6,     7,    46,
     0,    17,     0,     0,    41,     0,     0,     9,     0,   262,
     3,     4,     5,     8,    11,    49,    43,    44,    45,    -2,
    -2,   236,    57,     0,     0,    19,   236,     0,    21,    22,
    23,    24,    25,    26,    27,    28,     2,    -2,    10,     0,
    47,    48,    53,   261,     0,    54,     0,     0,     0,   268,
   268,     1,    58,     0,   100,   101,   252,   260,     0,   255,
   258,   256,    55,   235,    56,   276,   265,   268,     0,   394,
   394,     0,     0,   264,     0,     0,    99,     0,   259,    14,
     0,   263,   276,     0,   394,   394,     0,     0,     0,   267,
   269,     0,   271,     0,   288,     0,   395,   401,   285,   291,
     0,   396,     0,     0,   254,    50,   103,   253,   100,     0,
    97,    94,    95,   179,   180,   181,     0,     0,   195,   197,
   199,     0,   201,     0,   209,     0,     0,   214,   217,   219,
   223,   224,   225,   226,   227,   228,     0,     0,     0,   233,
     0,   100,     0,   113,   117,    12,    14,    13,   257,   275,
   277,   278,   285,     0,   281,   402,   266,   270,     0,   392,
   394,     0,   272,   394,   394,     0,     0,     0,    20,    -2,
    42,     0,   104,   111,    98,     0,    83,     0,     0,     0,
     0,   200,     0,   203,   204,   205,   206,   207,   208,     0,
     0,   212,   213,     0,     0,     0,     0,   251,     0,   222,
   221,     0,     0,   232,     0,     0,   238,   112,    14,     0,
    12,   279,     0,     0,     0,   283,   393,     0,   287,     0,
   286,   290,     0,   273,     0,    -2,     0,   382,   384,   385,
   398,   399,   262,   274,     0,    46,    68,     0,     0,    12,
     0,    32,    33,    46,     0,     0,   102,   105,   110,   107,
     0,     0,    96,     0,   183,   184,    16,   186,   187,   188,
   189,     0,     0,   137,    14,     0,   194,   196,   198,   202,
   210,   211,   215,   216,   218,   229,     0,   230,     0,   231,
     0,     0,     0,   242,   234,     0,   116,   111,    -2,   280,
   316,     0,   322,   336,   326,   329,   332,     0,   334,   335,
   339,   375,   376,   377,   378,     0,   282,   391,   289,   292,
   294,   295,     0,     0,   388,     0,     0,     0,     0,    49,
    60,    -2,    -2,    68,    68,    68,    68,    71,     0,    -2,
    -2,    84,    85,    86,    93,     0,   100,    49,     0,     0,
     0,   108,   109,   182,   185,    15,   124,     0,     0,     0,
   139,   140,   141,   142,   262,     0,     0,     0,     0,   123,
   137,   133,     0,     0,    -2,     0,     0,   147,   148,   149,
   150,     0,     0,     0,     0,   192,     0,   250,   220,   243,
   245,   239,   240,   241,   247,     0,   237,   254,    -2,   121,
   122,    46,     0,   319,     0,     0,   325,   339,     0,     0,
     0,     0,   333,   336,     0,     0,   340,   342,   297,   300,
   306,     0,     0,     0,   379,   390,   383,     0,   389,   381,
     0,   397,    30,     0,    68,    68,    63,    64,    65,    66,
    75,    70,    69,    80,    81,    -2,    91,    92,   115,   115,
    29,     0,    36,    -2,     0,    40,   106,   128,   128,     0,
   143,     0,     0,     0,     0,   134,   137,   137,   144,     0,
     0,     0,     0,     0,     0,     0,     0,   193,     0,   246,
     0,   118,   131,   131,    49,   315,     0,    -2,   321,     0,
   327,   328,   330,   331,     0,   337,     0,     0,     0,   299,
     0,   307,   309,   344,   399,     0,     0,     0,   367,   293,
   296,   386,   387,     0,   100,    61,    62,    16,    74,     0,
   100,    -2,    88,    90,   132,   114,   253,   253,     0,    37,
   253,     0,   125,   127,   126,   138,   173,   173,     0,     0,
   100,   173,   135,   136,   145,     0,   175,   175,     0,   175,
   175,     0,     0,   244,   249,   119,   130,   129,   120,     0,
   317,   318,   343,   338,   341,   284,   298,     0,     0,   365,
   345,   346,   324,   339,     0,     0,   313,     0,   303,   368,
   369,   356,   371,     0,   359,    -2,    -2,   360,   361,   371,
   115,   261,     0,    79,   131,   131,    31,    34,    35,    38,
    39,   152,     0,     0,     0,     0,   178,   168,     0,   154,
     0,     0,     0,     0,   171,   190,     0,     0,   367,   308,
   310,   367,     0,     0,   311,     0,   314,   302,   344,     0,
     0,   372,   374,    -2,   348,   350,     0,   354,   357,   358,
   362,   363,     0,    52,    67,     0,     0,    78,    -2,    -2,
   156,     0,   173,     0,   173,     0,     0,     0,     0,     0,
   158,     0,   175,     0,   175,     0,     0,     0,   192,    51,
   303,   366,   323,   312,   304,   305,   355,   370,     0,     0,
     0,   351,     0,   364,    79,    77,    87,    89,     0,   173,
     0,   172,   161,     0,   176,   100,     0,     0,   146,     0,
   175,     0,   174,   163,     0,   165,     0,     0,   191,   301,
   373,   347,   349,   352,     0,     0,     0,   155,   173,     0,
   177,   166,   173,     0,   157,   175,     0,   169,   175,     0,
    76,   159,   152,   162,   168,   160,   152,   164,   168,   353,
   151,   167,   153,   170 };
typedef struct
#ifdef __cplusplus
	yytoktype
#endif
{
#ifdef __cplusplus
const
#endif
char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

yytoktype yytoks[] =
{
	"ENUMERATION",	257,
	"PUBLIC",	258,
	"EXTERNAL",	259,
	"OVERLOAD",	260,
	"IMPORT",	261,
	"PROTECTED",	262,
	"INNER",	263,
	"OUTER",	264,
	"IF",	265,
	"THEN",	266,
	"ELSE",	267,
	"ELSEIF",	268,
	"END",	269,
	"FOR",	270,
	"LOOP",	271,
	"IN",	272,
	"REPLACEABLE",	273,
	"WHEN",	274,
	"WHILE",	275,
	"ELSEWHEN",	276,
	"CONNECT",	277,
	"INITIAL",	278,
	"ANNOTATION",	279,
	"TRUE",	280,
	"FALSE",	281,
	"ASSIGN",	282,
	"REDECLARE",	283,
	"EQUATION",	284,
	"ALGORITHM",	285,
	"EXTENDS",	286,
	"CODE",	287,
	"T_class",	288,
	"T_model",	289,
	"T_record",	290,
	"T_block",	291,
	"T_connector",	292,
	"T_package",	293,
	"T_function",	294,
	"T_flow",	295,
	"T_discrete",	296,
	"T_parameter",	297,
	"T_const",	298,
	"T_input",	299,
	"T_output",	300,
	"T_encapsulated",	301,
	"T_partial",	302,
	"T_within",	303,
	"T_final",	304,
	"T_each",	305,
	"T_and",	306,
	"T_as",	307,
	"T_abstype",	308,
	"T_axiom",	309,
	"T_datatype",	310,
	"T_default",	311,
	"T_end",	312,
	"T_eqtype",	313,
	"T_fail",	314,
	"T_interface",	315,
	"T_let",	316,
	"T_module",	317,
	"T_not",	318,
	"T_of",	319,
	"T_or",	320,
	"T_relation",	321,
	"T_rule",	322,
	"T_type",	323,
	"T_val",	324,
	"T_with",	325,
	"T_withtype",	326,
	"LBRACK",	327,
	"RBRACK",	328,
	"LBRACE",	329,
	"RBRACE",	330,
	"LPAR",	331,
	"RPAR",	332,
	"DOT",	333,
	"COLON",	334,
	"COLONCOLON",	335,
	"COMMA",	336,
	"DASHES",	337,
	"PIPEBAR",	338,
	"AMPERSAND",	339,
	"SEMICOLON",	340,
	"YIELDS",	341,
	"STAR",	342,
	"WILD",	343,
	"EQUALS",	344,
	"PLUS",	345,
	"MINUS",	346,
	"DIV",	347,
	"LESS",	348,
	"LESSEQ",	349,
	"GREATER",	350,
	"GREATEREQ",	351,
	"EQEQ",	352,
	"LESSGT",	353,
	"SLASH",	354,
	"POWER",	355,
	"UNSIGNED_INTEGER",	356,
	"UNSIGNED_REAL",	357,
	"STRING",	358,
	"IDENT",	359,
	"TYVARIDENT",	360,
	"CCON",	361,
	"ICON",	362,
	"RCON",	363,
	"SCON",	364,
	"-unknown-",	-1	/* ends search */
};

#ifdef __cplusplus
const
#endif
char * yyreds[] =
{
	"-no such reduction-",
	"stored_definition : optENCAPSULATED optPARTIAL class_type ident",
	"stored_definition : T_end ident SEMICOLON",
	"stored_definition : component_clause SEMICOLON",
	"stored_definition : import_clause SEMICOLON",
	"stored_definition : opt_within_clause class_definition_list",
	"stored_definition : rml_file",
	"optENCAPSULATED : T_encapsulated",
	"optENCAPSULATED : /* empty */",
	"optPARTIAL : T_partial",
	"optPARTIAL : /* empty */",
	"optFINAL : T_final",
	"optFINAL : /* empty */",
	"optEACH : T_each",
	"optEACH : /* empty */",
	"optSEMICOLON : SEMICOLON",
	"optSEMICOLON : /* empty */",
	"opt_within_clause : within_clause",
	"opt_within_clause : /* empty */",
	"within_clause : T_within name_path",
	"class_definition : optENCAPSULATED optPARTIAL class_type ident class_specifier",
	"class_type : T_class",
	"class_type : T_model",
	"class_type : T_record",
	"class_type : T_block",
	"class_type : T_connector",
	"class_type : T_type",
	"class_type : T_package",
	"class_type : T_function",
	"base_prefix : flow_prefix variability_prefix direction_prefix",
	"class_specifier : string_comment composition T_end IDENT",
	"class_specifier : EQUALS base_prefix name_path opt_array_subscripts opt_class_modification comment",
	"class_specifier : EQUALS enumeration",
	"class_specifier : EQUALS overloading",
	"enumeration : ENUMERATION LPAR enum_list RPAR comment",
	"enum_list : enumeration_literal COMMA enum_list",
	"enum_list : enumeration_literal",
	"enumeration_literal : ident comment",
	"overloading : OVERLOAD LPAR name_path_list RPAR comment",
	"name_path_list : name_path COMMA name_path_list",
	"name_path_list : name_path",
	"flow_prefix : T_flow",
	"flow_prefix : /* empty */",
	"variability_prefix : T_discrete",
	"variability_prefix : T_parameter",
	"variability_prefix : T_const",
	"variability_prefix : /* empty */",
	"direction_prefix : T_input",
	"direction_prefix : T_output",
	"direction_prefix : /* empty */",
	"component_clause : flow_prefix variability_prefix direction_prefix type_specifier opt_array_subscripts component_list",
	"component_clause1 : flow_prefix variability_prefix direction_prefix type_specifier component_declaration",
	"composition : flow_prefix variability_prefix direction_prefix type_specifier opt_array_subscripts opt_class_modification",
	"import_clause : IMPORT explicit_import_name comment",
	"import_clause : IMPORT implicit_import_name comment",
	"explicit_import_name : ident EQUALS name_path",
	"implicit_import_name : name_path DOT STAR",
	"implicit_import_name : name_path",
	"class_definition_list : optFINAL class_definition class_definition_list",
	"class_definition_list : /* empty */",
	"composition : element_list composition_sublist",
	"composition_sublist : PUBLIC element_list composition_sublist",
	"composition_sublist : PROTECTED element_list composition_sublist",
	"composition_sublist : equation_clause composition_sublist",
	"composition_sublist : initial_equation_clause composition_sublist",
	"composition_sublist : algorithm_clause composition_sublist",
	"composition_sublist : initial_algorithm_clause composition_sublist",
	"composition_sublist : EXTERNAL opt_language_specification opt_external_function_call optSEMICOLON opt_annotation",
	"composition_sublist : /* empty */",
	"language_specification : STRING",
	"opt_language_specification : language_specification",
	"opt_language_specification : /* empty */",
	"opt_component_reference_equals : component_reference EQUALS",
	"opt_component_reference_equals : /* empty */",
	"opt_external_function_call : external_function_call",
	"opt_external_function_call : /* empty */",
	"external_function_call : component_reference EQUALS ident LPAR opt_expression_list RPAR",
	"external_function_call : ident LPAR opt_expression_list RPAR",
	"opt_expression_list : expression_list",
	"opt_expression_list : /* empty */",
	"element_list : element SEMICOLON element_list",
	"element_list : annotation SEMICOLON element_list",
	"element_list : /* empty */",
	"element : /* empty */",
	"element : element1",
	"element1 : import_clause",
	"element1 : extends_clause",
	"element1 : optFINAL inner_outer REPLACEABLE class_definition opt_constraining_clause comment",
	"element1 : optFINAL inner_outer class_definition",
	"element1 : optFINAL inner_outer REPLACEABLE component_clause opt_constraining_clause comment",
	"element1 : optFINAL inner_outer component_clause",
	"inner_outer : INNER",
	"inner_outer : OUTER",
	"inner_outer : /* empty */",
	"subscript : expression",
	"subscript : COLON",
	"subscript_list : subscript COMMA subscript_list",
	"subscript_list : subscript",
	"array_subscripts : LBRACK subscript_list RBRACK",
	"opt_array_subscripts : array_subscripts",
	"opt_array_subscripts : /* empty */",
	"type_specifier : name_path",
	"component_list : component_declaration COMMA component_list",
	"component_list : component_declaration",
	"component_declaration : declaration comment",
	"declaration : ident opt_array_subscripts opt_modification",
	"modification : class_modification EQUALS expression",
	"modification : class_modification",
	"modification : EQUALS expression",
	"modification : ASSIGN expression",
	"opt_modification : modification",
	"opt_modification : /* empty */",
	"class_modification : LPAR argument_list RPAR",
	"class_modification : LPAR RPAR",
	"opt_class_modification : class_modification",
	"opt_class_modification : /* empty */",
	"argument_list : argument COMMA argument_list",
	"argument_list : argument",
	"argument : optEACH optFINAL component_reference opt_modification string_comment",
	"argument : REDECLARE optEACH optFINAL REPLACEABLE class_definition opt_constraining_clause",
	"argument : REDECLARE optEACH optFINAL REPLACEABLE component_clause1 opt_constraining_clause",
	"argument : REDECLARE optEACH optFINAL class_definition",
	"argument : REDECLARE optEACH optFINAL component_clause1",
	"initial_equation_clause : INITIAL equation_clause",
	"equation_clause : EQUATION equation_annotation_list",
	"equation_annotation_list : equation SEMICOLON opt_equation_annotation_list",
	"equation_annotation_list : annotation SEMICOLON opt_equation_annotation_list",
	"opt_equation_annotation_list : equation_annotation_list",
	"opt_equation_annotation_list : /* empty */",
	"constraining_clause : extends_clause",
	"opt_constraining_clause : constraining_clause",
	"opt_constraining_clause : /* empty */",
	"extends_clause : EXTENDS name_path opt_class_modification",
	"algorithm_clause : ALGORITHM algorithm_clause_list",
	"initial_algorithm_clause : INITIAL ALGORITHM algorithm_clause_list",
	"algorithm_clause_list : algorithm SEMICOLON algorithm_clause_list",
	"algorithm_clause_list : annotation SEMICOLON algorithm_clause_list",
	"algorithm_clause_list : /* empty */",
	"equation : simple_expression EQUALS expression",
	"equation : conditional_equation_e",
	"equation : for_clause_e",
	"equation : connect_clause",
	"equation : when_clause_e",
	"equation : IDENT function_call",
	"algorithm : algorithm1 comment",
	"algorithm1 : component_reference ASSIGN expression",
	"algorithm1 : LPAR expression_list RPAR ASSIGN component_reference function_call",
	"algorithm1 : conditional_equation_a",
	"algorithm1 : for_clause_a",
	"algorithm1 : while_clause",
	"algorithm1 : when_clause_a",
	"equation_elseif : ELSEIF expression THEN equation_list equation_elseif",
	"equation_elseif : /* empty */",
	"algorithm_elseif : ELSEIF expression THEN algorithm_list equation_elseif",
	"algorithm_elseif : /* empty */",
	"opt_equation_else : ELSE equation_list",
	"opt_equation_else : /* empty */",
	"opt_algorithm_else : ELSE algorithm_list",
	"opt_algorithm_else : /* empty */",
	"conditional_equation_e : IF expression THEN equation_list equation_elseif opt_equation_else END IF",
	"conditional_equation_a : IF expression THEN algorithm_list algorithm_elseif opt_algorithm_else END IF",
	"for_clause_e : FOR ident LOOP equation_list END FOR",
	"for_clause_e : FOR ident IN expression LOOP equation_list END FOR",
	"for_clause_a : FOR ident LOOP algorithm_list END FOR",
	"for_clause_a : FOR ident IN expression LOOP algorithm_list END FOR",
	"while_clause : WHILE expression LOOP algorithm_list END WHILE",
	"when_clause_e : WHEN expression THEN equation_list else_when_e END WHEN",
	"else_when_e : ELSEWHEN expression THEN equation_list else_when_e",
	"else_when_e : /* empty */",
	"when_clause_a : WHEN expression THEN algorithm_list else_when_a END WHEN",
	"else_when_a : ELSEWHEN expression THEN algorithm_list else_when_e",
	"else_when_a : /* empty */",
	"equation_list : equation SEMICOLON equation_list",
	"equation_list : /* empty */",
	"algorithm_list : algorithm SEMICOLON algorithm_list",
	"algorithm_list : /* empty */",
	"connect_clause : CONNECT LPAR connector_ref COMMA connector_ref RPAR",
	"connector_ref : ident opt_array_subscripts DOT ident opt_array_subscripts",
	"connector_ref : ident opt_array_subscripts",
	"expression : code_expression",
	"expression : if_expression",
	"expression : simple_expression",
	"code_expression : CODE LPAR code_expression1 RPAR",
	"code_expression1 : expression",
	"code_expression1 : modification",
	"code_expression1 : element optSEMICOLON",
	"code_expression1 : equation_clause",
	"code_expression1 : initial_equation_clause",
	"code_expression1 : algorithm_clause",
	"code_expression1 : initial_algorithm_clause",
	"if_expression : IF expression THEN expression elseif_expression_list ELSE expression",
	"elseif_expression_list : ELSEIF expression THEN expression elseif_expression_list",
	"elseif_expression_list : /* empty */",
	"simple_expression : logical_expression COLON logical_expression COLON logical_expression",
	"simple_expression : logical_expression COLON logical_expression",
	"simple_expression : logical_expression",
	"logical_expression : logical_term T_or logical_expression",
	"logical_expression : logical_term",
	"logical_term : logical_factor T_and logical_term",
	"logical_term : logical_factor",
	"logical_factor : T_not relation",
	"logical_factor : relation",
	"relation : arithmetic_expression rel_op arithmetic_expression",
	"rel_op : LESS",
	"rel_op : LESSEQ",
	"rel_op : GREATER",
	"rel_op : GREATEREQ",
	"rel_op : EQEQ",
	"rel_op : LESSGT",
	"arithmetic_expression : unary_arithmetic_expression",
	"arithmetic_expression : unary_arithmetic_expression PLUS arithmetic_expression",
	"arithmetic_expression : unary_arithmetic_expression MINUS arithmetic_expression",
	"unary_arithmetic_expression : PLUS term",
	"unary_arithmetic_expression : MINUS term",
	"unary_arithmetic_expression : term",
	"term : factor STAR term",
	"term : factor SLASH term",
	"term : factor",
	"factor : primary POWER primary",
	"factor : primary",
	"expression_matrix_list : expression_list SEMICOLON expression_matrix_list",
	"expression_matrix_list : expression_list",
	"expression_matrix : expression_matrix_list",
	"primary : UNSIGNED_INTEGER",
	"primary : UNSIGNED_REAL",
	"primary : STRING",
	"primary : FALSE",
	"primary : TRUE",
	"primary : component_reference__function_call",
	"primary : LPAR expression_list RPAR",
	"primary : LBRACK expression_matrix RBRACK",
	"primary : LBRACE for_or_expression_list RBRACE",
	"component_reference__function_call : component_reference function_call",
	"component_reference__function_call : component_reference",
	"component_reference__function_call : INITIAL LPAR RPAR",
	"name_path : ident DOT name_path",
	"name_path : ident",
	"component_reference : ident opt_array_subscripts DOT component_reference",
	"component_reference : ident opt_array_subscripts",
	"function_call : LPAR function_arguments RPAR",
	"function_arguments : for_or_expression_list opt_named_arguments",
	"opt_named_arguments : named_arguments",
	"opt_named_arguments : /* empty */",
	"for_or_expression_list : expression COMMA expression_list",
	"for_or_expression_list : expression FOR IDENT IN expression",
	"for_or_expression_list : expression FOR IDENT",
	"named_arguments : named_argument named_arguments",
	"named_arguments : /* empty */",
	"named_arguments2 : /* empty */",
	"named_argument : IDENT EQUALS expression",
	"expression_list : expression COMMA expression_list",
	"expression_list : expression",
	"comment : string_comment opt_annotation",
	"comment : /* empty */",
	"string_comment : /* empty */",
	"string_comment : string_concats",
	"string_comment_part : STRING",
	"string_concats : string_comment_part PLUS string_concats",
	"string_concats : string_comment_part",
	"annotation : ANNOTATION class_modification",
	"opt_annotation : annotation",
	"opt_annotation : /* empty */",
	"ident : IDENT",
	"rml_file : T_module STRING COLON rml_interface rml_definitions",
	"rml_file : T_interface STRING COLON rml_interface",
	"rml_interface : rml_interface_item_star",
	"rml_interface : rml_interface_item_star T_end",
	"rml_interface_item_star : rml_interface_item rml_interface_item_star",
	"rml_interface_item_star : /* empty */",
	"rml_interface_item : T_with STRING",
	"rml_interface_item : T_type tyvarparseq IDENT",
	"rml_interface_item : T_type typbind_plus",
	"rml_interface_item : T_datatype datbind_plus withbind",
	"rml_interface_item : T_val ident COLON ty",
	"rml_interface_item : T_relation ident COLON ty",
	"rml_definitions : rml_definition_item rml_definitions",
	"rml_definitions : /* empty */",
	"rml_definition_item : T_with STRING",
	"rml_definition_item : T_type typbind_plus",
	"rml_definition_item : T_datatype datbind_plus withbind",
	"rml_definition_item : T_val ident EQUALS rml_expression",
	"rml_definition_item : T_relation relbind",
	"opt_type : COLON ty",
	"opt_type : empty",
	"relbind : ident opt_type EQUALS clause_plus default_opt T_end",
	"withbind : /* empty */",
	"withbind : T_withtype typbind_plus",
	"typbind_plus : typbind T_and typbind_plus",
	"typbind_plus : typbind",
	"typbind : tyvarseq ident EQUALS ty",
	"datbind_plus : datbind T_and datbind_plus",
	"datbind_plus : datbind",
	"datbind : tyvarseq ident EQUALS conbind_plus",
	"conbind_plus : conbind PIPEBAR conbind_plus",
	"conbind_plus : conbind",
	"conbind : ident",
	"conbind : ident T_of tuple_ty",
	"default_opt : /* empty */",
	"default_opt : T_default clause_plus",
	"clause_plus : clause clause_plus",
	"clause_plus : clause",
	"clause : T_rule conjunctive_goal_opt DASHES ident seq_pat result",
	"clause : T_axiom ident seq_pat result",
	"result : /* empty */",
	"result : YIELDS seq_exp",
	"result : YIELDS T_fail",
	"conjunctive_goal_opt : /* empty */",
	"conjunctive_goal_opt : conjunctive_goal",
	"conjunctive_goal : atomic_goal AMPERSAND conjunctive_goal",
	"conjunctive_goal : atomic_goal",
	"atomic_goal : longorshortid seq_exp res_pat",
	"atomic_goal : ident EQUALS rml_expression",
	"atomic_goal : T_let ident EQUALS rml_expression",
	"atomic_goal : T_not atomic_goal",
	"atomic_goal : LPAR conjunctive_goal RPAR",
	"rml_expression : rml_exp_a COLONCOLON rml_expression",
	"rml_expression : rml_exp_a",
	"rml_expression_list : rml_expression COMMA rml_expression_list",
	"rml_expression_list : rml_expression",
	"rml_exp_a : LPAR RPAR",
	"rml_exp_a : LPAR rml_expression RPAR",
	"rml_exp_a : LPAR rml_expression_list RPAR",
	"rml_exp_a : rml_exp_c",
	"rml_exp_b : rml_exp_c COLONCOLON rml_exp_b",
	"rml_exp_b : rml_exp_c",
	"rml_exp_c : longorshortid rml_exp_star",
	"rml_exp_c : rml_addsub",
	"rml_addsub : rml_muldiv PLUS rml_addsub",
	"rml_addsub : rml_muldiv MINUS rml_addsub",
	"rml_addsub : rml_muldiv",
	"rml_muldiv : rml_unary STAR rml_muldiv",
	"rml_muldiv : rml_unary DIV rml_muldiv",
	"rml_muldiv : rml_unary",
	"rml_unary : MINUS rml_unary",
	"rml_unary : rml_primary",
	"rml_primary : rml_literal",
	"rml_primary : longorshortid",
	"rml_primary : LBRACK rml_exp_comma_star RBRACK",
	"rml_primary : LPAR rml_expression RPAR",
	"rml_exp_comma_star : /* empty */",
	"rml_exp_comma_star : rml_exp_comma_plus",
	"rml_exp_comma_plus : rml_expression COMMA rml_exp_comma_plus",
	"rml_exp_comma_plus : rml_expression",
	"rml_exp_star : LPAR rml_exp_comma_star RPAR",
	"seq_exp : /* empty */",
	"seq_exp : rml_exp_b",
	"seq_exp : rml_exp_star",
	"pat : ident T_as pat",
	"pat : pat_a",
	"pat_a : pat_b COLONCOLON pat_a",
	"pat_a : pat_b",
	"pat_b : LPAR RPAR",
	"pat_b : LPAR pat RPAR",
	"pat_b : LPAR pat COMMA pat_comma_plus RPAR",
	"pat_b : pat_d",
	"pat_c : pat_d COLONCOLON pat_c",
	"pat_c : pat_d",
	"pat_d : longorshortid pat_star",
	"pat_d : longorshortid pat_e",
	"pat_d : pat_e",
	"pat_e : WILD",
	"pat_e : rml_literal",
	"pat_e : longid",
	"pat_e : ident",
	"pat_e : LBRACK pat_comma_star RBRACK",
	"res_pat : /* empty */",
	"res_pat : YIELDS seq_pat",
	"seq_pat : /* empty */",
	"seq_pat : pat_c",
	"seq_pat : pat_star",
	"pat_star : LPAR pat_comma_star RPAR",
	"pat_comma_star : /* empty */",
	"pat_comma_star : pat_comma_plus",
	"pat_comma_plus : pat COMMA pat_comma_plus",
	"pat_comma_plus : pat",
	"rml_literal : CCON",
	"rml_literal : ICON",
	"rml_literal : RCON",
	"rml_literal : STRING",
	"ty : seq_ty YIELDS seq_ty",
	"ty : tuple_ty",
	"tuple_ty : ty_sans_star STAR tuple_ty",
	"tuple_ty : ty_sans_star",
	"ty_sans_star : LPAR ty RPAR",
	"ty_sans_star : tyvar",
	"ty_sans_star : longorshortid",
	"ty_comma_seq2 : ty COMMA ty_comma_seq2",
	"ty_comma_seq2 : ty COMMA ty",
	"seq_ty : LPAR RPAR",
	"seq_ty : LPAR ty_comma_seq2 RPAR",
	"seq_ty : tuple_ty",
	"tyvarseq1 : tyvar COMMA tyvarseq1",
	"tyvarseq1 : tyvar",
	"tyvarparseq : LPAR tyvarseq1 RPAR",
	"tyvarseq : /* empty */",
	"tyvarseq : tyvar",
	"tyvarseq : tyvarparseq",
	"longid : IDENT DOT IDENT",
	"longorshortid : longid",
	"longorshortid : ident",
	"ident : IDENT",
	"tyvar : TYVARIDENT",
	"empty : /* empty */",
};
#endif /* YYDEBUG */
# line	1 "/usr/ccs/bin/yaccpar"
/*
 * Copyright (c) 1993 by Sun Microsystems, Inc.
 */

#pragma ident	"@(#)yaccpar	6.16	99/01/20 SMI"

/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( "syntax error - cannot backup" );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#define YYNEW(type)	malloc(sizeof(type) * yynewmax)
#define YYCOPY(to, from, type) \
	(type *) memcpy(to, (char *) from, yymaxdepth * sizeof (type))
#define YYENLARGE( from, type) \
	(type *) realloc((char *) from, yynewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-10000000)

/*
** global variables used by the parser
*/
YYSTYPE *yypv;			/* top of value stack */
int *yyps;			/* top of state stack */

int yystate;			/* current state */
int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */
int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */



#ifdef YYNMBCHARS
#define YYLEX()		yycvtok(yylex())
/*
** yycvtok - return a token if i is a wchar_t value that exceeds 255.
**	If i<255, i itself is the token.  If i>255 but the neither 
**	of the 30th or 31st bit is on, i is already a token.
*/
#if defined(__STDC__) || defined(__cplusplus)
int yycvtok(int i)
#else
int yycvtok(i) int i;
#endif
{
	int first = 0;
	int last = YYNMBCHARS - 1;
	int mid;
	wchar_t j;

	if(i&0x60000000){/*Must convert to a token. */
		if( yymbchars[last].character < i ){
			return i;/*Giving up*/
		}
		while ((last>=first)&&(first>=0)) {/*Binary search loop*/
			mid = (first+last)/2;
			j = yymbchars[mid].character;
			if( j==i ){/*Found*/ 
				return yymbchars[mid].tvalue;
			}else if( j<i ){
				first = mid + 1;
			}else{
				last = mid -1;
			}
		}
		/*No entry in the table.*/
		return i;/* Giving up.*/
	}else{/* i is already a token. */
		return i;
	}
}
#else/*!YYNMBCHARS*/
#define YYLEX()		yylex()
#endif/*!YYNMBCHARS*/

/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int yyparse(void)
#else
int yyparse()
#endif
{
	register YYSTYPE *yypvt = 0;	/* top of value stack for $vars */

#if defined(__cplusplus) || defined(lint)
/*
	hacks to please C++ and lint - goto's inside
	switch should never be executed
*/
	static int __yaccpar_lint_hack__ = 0;
	switch (__yaccpar_lint_hack__)
	{
		case 1: goto yyerrlab;
		case 2: goto yynewstate;
	}
#endif

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

#if YYMAXDEPTH <= 0
	if (yymaxdepth <= 0)
	{
		if ((yymaxdepth = YYEXPAND(0)) <= 0)
		{
			yyerror("yacc initialization error");
			YYABORT;
		}
	}
#endif

	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */
	goto yystack;	/* moved from 6 lines above to here to please C++ */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			long yyps_index = (yy_ps - yys);
			long yypv_index = (yy_pv - yyv);
			long yypvt_index = (yypvt - yyv);
			int yynewmax;
#ifdef YYEXPAND
			yynewmax = YYEXPAND(yymaxdepth);
#else
			yynewmax = 2 * yymaxdepth;	/* double table size */
			if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
			{
				char *newyys = (char *)YYNEW(int);
				char *newyyv = (char *)YYNEW(YYSTYPE);
				if (newyys != 0 && newyyv != 0)
				{
					yys = YYCOPY(newyys, yys, int);
					yyv = YYCOPY(newyyv, yyv, YYSTYPE);
				}
				else
					yynewmax = 0;	/* failed */
			}
			else				/* not first time */
			{
				yys = YYENLARGE(yys, int);
				yyv = YYENLARGE(yyv, YYSTYPE);
				if (yys == 0 || yyv == 0)
					yynewmax = 0;	/* failed */
			}
#endif
			if (yynewmax <= yymaxdepth)	/* tables not expanded */
			{
				yyerror( "yacc stack overflow" );
				YYABORT;
			}
			yymaxdepth = yynewmax;

			yy_ps = yys + yyps_index;
			yy_pv = yyv + yypv_index;
			yypvt = yyv + yypvt_index;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
#endif
		if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			printf( "Received token " );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
#endif
			if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
				yychar = 0;		/* reached EOF */
#if YYDEBUG
			if ( yydebug && yytmp )
			{
				register int yy_i;

				printf( "Received token " );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register YYCONST int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
				yyerror( "syntax error" );
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
			skip_init:
				yynerrs++;
				/* FALLTHRU */
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
#endif
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					printf( "Error recovery discards " );
					if ( yychar == 0 )
						printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
#endif
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
case 1:
# line 40 "parser.y"
{
	  yypvt[-4] = Absyn__BEGIN_5fDEFINITION(Absyn__IDENT(yypvt[-0]), yypvt[-1], yypvt[-2], yypvt[-3]);
	} break;
case 2:
# line 45 "parser.y"
{
          yypvt[-3] = Absyn__END_5fDEFINITION(yypvt[-1]);
	} break;
case 3:
# line 50 "parser.y"
{
	  yypvt[-2] = Absyn__COMP_5fDEFINITION(yypvt[-1],mk_none());
	} break;
case 4:
# line 55 "parser.y"
{
	  yypvt[-2] = Absyn__IMPORT_5fDEFINITION(yypvt[-1],mk_none());
	} break;
case 5:
# line 60 "parser.y"
{
	  yypvt[-2] = Absyn__PROGRAM(yypvt[-0],yypvt[-1]);
        } break;
case 6:
# line 65 "parser.y"
{
	  yypvt[-1] = yypvt[-0];
	} break;
case 7:
# line 72 "parser.y"
{ yypvt[-1] = RML_PRIM_MKBOOL(1);} break;
case 8:
# line 74 "parser.y"
{ yypvt[-0] = RML_PRIM_MKBOOL(0);} break;
case 9:
# line 78 "parser.y"
{ yypvt[-1] = RML_PRIM_MKBOOL(1);} break;
case 10:
# line 80 "parser.y"
{ yypvt[-0] = RML_PRIM_MKBOOL(0);} break;
case 11:
# line 84 "parser.y"
{ yypvt[-1] = RML_TRUE;} break;
case 12:
# line 86 "parser.y"
{ yypvt[-0] = RML_FALSE;} break;
case 13:
# line 90 "parser.y"
{ yypvt[-1] = Absyn__EACH;} break;
case 14:
# line 92 "parser.y"
{ yypvt[-0] = Absyn__NON_5fEACH;} break;
case 15:
# line 96 "parser.y"
{ yypvt[-1] = 1;} break;
case 16:
# line 98 "parser.y"
{ yypvt[-0] = 0;} break;
case 17:
# line 102 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 18:
# line 104 "parser.y"
{ yypvt[-0] = Absyn__TOP;} break;
case 19:
# line 110 "parser.y"
{ yypvt[-2] = Absyn__WITHIN(yypvt[-0]);} break;
case 20:
# line 116 "parser.y"
{
	  /* FIXME: need to distinguish whether FINAL or not from
	   * invocation.
	   */
	  yypvt[-5] = Absyn__CLASS(yypvt[-1],
				yypvt[-3],
				RML_FALSE /* FINAL */,
				yypvt[-4],
				yypvt[-2],
				yypvt[-0]);
	} break;
case 21:
# line 131 "parser.y"
{ yypvt[-1] = Absyn__R_5fCLASS;} break;
case 22:
# line 132 "parser.y"
{ yypvt[-1] = Absyn__R_5fMODEL;} break;
case 23:
# line 133 "parser.y"
{ yypvt[-1] = Absyn__R_5fMODEL;} break;
case 24:
# line 134 "parser.y"
{ yypvt[-1] = Absyn__R_5fBLOCK;} break;
case 25:
# line 135 "parser.y"
{ yypvt[-1] = Absyn__R_5fCONNECTOR;} break;
case 26:
# line 136 "parser.y"
{ yypvt[-1] = Absyn__R_5fTYPE;} break;
case 27:
# line 137 "parser.y"
{ yypvt[-1] = Absyn__R_5fPACKAGE;} break;
case 28:
# line 138 "parser.y"
{ yypvt[-1] = Absyn__R_5fFUNCTION;} break;
case 29:
# line 143 "parser.y"
{ yypvt[-3] = Absyn__ATTR(yypvt[-2], yypvt[-1], yypvt[-0], mk_nil());} break;
case 30:
# line 148 "parser.y"
{
	  yypvt[-4] = Absyn__PARTS(yypvt[-2], yypvt[-3]);
	} break;
case 31:
# line 157 "parser.y"
{
	  yypvt[-6] = Absyn__DERIVED(yypvt[-3], /* name path */
		              yypvt[-2], /* array subscripts */
                              yypvt[-4], /* prefix attributes */
                              yypvt[-1], /* class modification */
                              yypvt[-0]); /* comment */
	} break;
case 32:
# line 166 "parser.y"
{ yypvt[-2] = yypvt[-1];} break;
case 33:
# line 169 "parser.y"
{ yypvt[-2] = yypvt[-1];} break;
case 34:
# line 175 "parser.y"
{ yypvt[-5] = Absyn__ENUMERATION(yypvt[-2],yypvt[-0]);} break;
case 35:
# line 180 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 36:
# line 183 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 37:
# line 188 "parser.y"
{ yypvt[-2] = Absyn__ENUMLITERAL(yypvt[-1],yypvt[-0]);} break;
case 38:
# line 193 "parser.y"
{ yypvt[-5] = Absyn__OVERLOAD(yypvt[-2], yypvt[-0]);} break;
case 39:
# line 198 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2],yypvt[-0]);} break;
case 40:
# line 201 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0],mk_nil());} break;
case 41:
# line 206 "parser.y"
{ yypvt[-1] = RML_PRIM_MKBOOL(1);} break;
case 42:
# line 208 "parser.y"
{ yypvt[-0] = RML_PRIM_MKBOOL(0);} break;
case 43:
# line 212 "parser.y"
{ yypvt[-1] = Absyn__DISCRETE;} break;
case 44:
# line 213 "parser.y"
{ yypvt[-1] = Absyn__PARAM;} break;
case 45:
# line 214 "parser.y"
{ yypvt[-1] = Absyn__CONST;} break;
case 46:
# line 215 "parser.y"
{ yypvt[-0] = Absyn__VAR;} break;
case 47:
# line 219 "parser.y"
{ yypvt[-1] = Absyn__INPUT;} break;
case 48:
# line 220 "parser.y"
{ yypvt[-1] = Absyn__OUTPUT;} break;
case 49:
# line 221 "parser.y"
{ yypvt[-0] = Absyn__BIDIR;} break;
case 50:
# line 227 "parser.y"
{
		yypvt[-6] = Absyn__COMPONENTS(Absyn__ATTR(yypvt[-5],yypvt[-4],yypvt[-3],yypvt[-1]),yypvt[-2],yypvt[-0]);
	} break;
case 51:
# line 235 "parser.y"
{
		yypvt[-5] = Absyn__COMPONENTS(Absyn__ATTR(yypvt[-4],yypvt[-3],yypvt[-2],mk_nil()),yypvt[-1],yypvt[-0]);
	} break;
case 52:
# line 243 "parser.y"
{ /* FIXME */ } break;
case 53:
# line 248 "parser.y"
{ yypvt[-3] = Absyn__IMPORT(yypvt[-1],yypvt[-0]);} break;
case 54:
# line 251 "parser.y"
{ yypvt[-3] = Absyn__IMPORT(yypvt[-1],yypvt[-0]);} break;
case 55:
# line 256 "parser.y"
{ yypvt[-3] = Absyn__NAMED_5fIMPORT(yypvt[-2],yypvt[-0]);} break;
case 56:
# line 261 "parser.y"
{ yypvt[-3] = Absyn__UNQUAL_5fIMPORT(yypvt[-2]);} break;
case 57:
# line 264 "parser.y"
{ yypvt[-1] = Absyn__QUAL_5fIMPORT(yypvt[-0]);} break;
case 58:
# line 269 "parser.y"
{ yypvt[-3] = yypvt[-2] ? mk_cons(yypvt[-1],yypvt[-0]) : yypvt[-0]; /* FIXME: Correct? */ } break;
case 59:
# line 271 "parser.y"
{ yypvt[-0] = 	mk_nil();} break;
case 60:
# line 276 "parser.y"
{
		yypvt[-2] = mk_cons(Absyn__PUBLIC(yypvt[-1]), yypvt[-0]);
	} break;
case 61:
# line 283 "parser.y"
{ yypvt[-3] = mk_cons(Absyn__PUBLIC(yypvt[-2]), yypvt[-1]);} break;
case 62:
# line 286 "parser.y"
{ yypvt[-3] = mk_cons(Absyn__PROTECTED(yypvt[-2]), yypvt[-1]);} break;
case 63:
# line 289 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 64:
# line 292 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 65:
# line 295 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 66:
# line 298 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 67:
# line 305 "parser.y"
{ /* an external_clause must be the last composition item, so
	   * we don't have composition_sublist at the end of this rule.
	   * This also means we must add the NIL at the end of the list
	   * ourselves.
	   */

	  /*FIXME: the language specification data should probably be part
     	   * of the external function call data, so opt_language_specification
	   * should probably be inside opt_external_function_call rule?
	   */ 

	  /* FIXME: handle annotation. */

		yypvt[-5] = mk_cons(yypvt[-2], mk_nil());
	} break;
case 68:
# line 321 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 69:
# line 326 "parser.y"
{ yypvt[-1] = to_rml_string(yypvt[-0]);} break;
case 70:
# line 331 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 71:
# line 333 "parser.y"
{ yypvt[-0] = 0;} break;
case 72:
# line 338 "parser.y"
{ yypvt[-2] = yypvt[-1];} break;
case 73:
# line 340 "parser.y"
{ yypvt[-0] = 0;} break;
case 74:
# line 345 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 75:
# line 347 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 76:
# line 352 "parser.y"
{
	  yypvt[-6] = Absyn__EXTERNAL(Absyn__EXTERNALDECL(mk_some(yypvt[-3]),
			mk_none() /*lang?*/, 
			yypvt[-5],
			yypvt[-1]),
			mk_none() /* annotation? */
			);

	} break;
case 77:
# line 363 "parser.y"
{
	  yypvt[-4] = Absyn__EXTERNAL(Absyn__EXTERNALDECL(mk_some(yypvt[-3]),
			mk_none() /*lang?*/, 
			mk_none() /*no component reference here*/,
			yypvt[-1]),
			mk_none() /* annotation? */
			);
	  /* FIXME: annotations? */
	} break;
case 78:
# line 375 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 79:
# line 377 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 80:
# line 382 "parser.y"
{ yypvt[-3] = mk_cons(Absyn__ELEMENTITEM(yypvt[-2]), yypvt[-0]);} break;
case 81:
# line 385 "parser.y"
{ yypvt[-3] = mk_cons(Absyn__ANNOTATIONITEM(yypvt[-2]), yypvt[-0]);} break;
case 82:
# line 387 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 83:
# line 391 "parser.y"
{ positionPush();} break;
case 84:
# line 393 "parser.y"
{
		  yypvt[-2] = yypvt[-1];
		  positionPop();
		} break;
case 85:
# line 401 "parser.y"
{
	  yypvt[-1] = Absyn__ELEMENT(RML_FALSE,RML_FALSE,Absyn__UNSPECIFIED,
				mk_scon("import"),yypvt[-0],
				mk_scon(positionFileName()),
				mk_icon(positionLineNo()),mk_none());
	} break;
case 86:
# line 409 "parser.y"
{
	  yypvt[-1] = Absyn__ELEMENT(RML_FALSE,RML_FALSE,Absyn__UNSPECIFIED,
				mk_scon("extends"),yypvt[-0],
				mk_scon(positionFileName()),
				mk_icon(positionLineNo()),mk_none());
	} break;
case 87:
# line 418 "parser.y"
{ yypvt[-6] = parser_make_element(yypvt[-5], yypvt[-4],  1, yypvt[-2],  0,  yypvt[-1], yypvt[-0]);} break;
case 88:
# line 421 "parser.y"
{ yypvt[-3] = parser_make_element(yypvt[-2], yypvt[-1],  0, yypvt[-0],  0,   0,  0);} break;
case 89:
# line 425 "parser.y"
{ yypvt[-6] = parser_make_element(yypvt[-5], yypvt[-4],  1,  0,  yypvt[-2], yypvt[-1], yypvt[-0]);} break;
case 90:
# line 428 "parser.y"
{ yypvt[-3] = parser_make_element(yypvt[-2], yypvt[-1],  0,  0,  yypvt[-0],  0, 0);} break;
case 91:
# line 432 "parser.y"
{ yypvt[-1] = Absyn__INNER;} break;
case 92:
# line 433 "parser.y"
{ yypvt[-1] = Absyn__OUTER;} break;
case 93:
# line 434 "parser.y"
{ yypvt[-0] = Absyn__UNSPECIFIED;} break;
case 94:
# line 439 "parser.y"
{ yypvt[-1] = Absyn__SUBSCRIPT(yypvt[-0]);} break;
case 95:
# line 442 "parser.y"
{ yypvt[-1] = Absyn__NOSUB;} break;
case 96:
# line 447 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2],yypvt[-0]);} break;
case 97:
# line 450 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0],mk_nil());} break;
case 98:
# line 455 "parser.y"
{ yypvt[-3] = yypvt[-2];} break;
case 99:
# line 460 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 100:
# line 462 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 101:
# line 467 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 102:
# line 472 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 103:
# line 475 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 104:
# line 480 "parser.y"
{ yypvt[-2] = Absyn__COMPONENTITEM(yypvt[-1], yypvt[-0]);} break;
case 105:
# line 485 "parser.y"
{ 
	  yypvt[-3] = Absyn__COMPONENT(yypvt[-2], yypvt[-1], yypvt[-0]);
	} break;
case 106:
# line 493 "parser.y"
{ yypvt[-3] = Absyn__CLASSMOD(yypvt[-2], mk_some(yypvt[-0]));} break;
case 107:
# line 496 "parser.y"
{ yypvt[-1] = Absyn__CLASSMOD(yypvt[-0], mk_none());} break;
case 108:
# line 499 "parser.y"
{ yypvt[-2] = Absyn__CLASSMOD(mk_nil(), mk_some(yypvt[-0]));} break;
case 109:
# line 502 "parser.y"
{ yypvt[-2] = Absyn__CLASSMOD(mk_nil(), mk_some(yypvt[-0]));} break;
case 110:
# line 507 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 111:
# line 509 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 112:
# line 514 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 113:
# line 517 "parser.y"
{ yypvt[-2] = mk_nil();} break;
case 114:
# line 522 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 115:
# line 524 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 116:
# line 529 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 117:
# line 532 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 118:
# line 537 "parser.y"
{
	  /* element_modification */
	  yypvt[-5] = Absyn__MODIFICATION(yypvt[-4], yypvt[-3], yypvt[-2], yypvt[-1], yypvt[-0]);
	} break;
case 119:
# line 544 "parser.y"
{
	  yypvt[-6] = Absyn__REDECLARATION(yypvt[-4], yypvt[-3],
			Absyn__CLASSDEF(RML_TRUE,yypvt[-1]), yypvt[-0]);
	} break;
case 120:
# line 551 "parser.y"
{
	  yypvt[-6] = Absyn__REDECLARATION(yypvt[-4], yypvt[-3], yypvt[-1], yypvt[-0]);
	} break;
case 121:
# line 556 "parser.y"
{
	  yypvt[-4] = Absyn__REDECLARATION(yypvt[-2], yypvt[-1],
		Absyn__CLASSDEF(RML_FALSE,yypvt[-0]), mk_none());
	} break;
case 122:
# line 562 "parser.y"
{
	  yypvt[-4] = Absyn__REDECLARATION(yypvt[-2], yypvt[-1], yypvt[-0], mk_none());
	} break;
case 123:
# line 570 "parser.y"
{ yypvt[-2] = Absyn__INITIALEQUATIONS(yypvt[-0]);} break;
case 124:
# line 575 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 125:
# line 580 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 126:
# line 583 "parser.y"
{ yypvt[-3] = mk_cons(Absyn__EQUATIONITEMANN(yypvt[-2]), yypvt[-0]);} break;
case 127:
# line 588 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 128:
# line 590 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 129:
# line 595 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 130:
# line 600 "parser.y"
{ yypvt[-1] = mk_some(yypvt[-0]);} break;
case 131:
# line 602 "parser.y"
{ yypvt[-0] = mk_none();} break;
case 132:
# line 607 "parser.y"
{
	  yypvt[-3] = Absyn__EXTENDS(yypvt[-1], yypvt[-0]);
	} break;
case 133:
# line 614 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 134:
# line 619 "parser.y"
{ yypvt[-3] = Absyn__INITIALALGORITHMS(yypvt[-0]);} break;
case 135:
# line 624 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 136:
# line 627 "parser.y"
{ yypvt[-3] = mk_cons(Absyn__ALGORITHMITEMANN(yypvt[-2]), yypvt[-0]);} break;
case 137:
# line 629 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 138:
# line 634 "parser.y"
{
	  /* Comment handling? Unclear what the ANTLR parser does; the
	   * walker seems to look for comments in the parse tree, but
	   * the parser doesn't seem to put any comment nodes in the
	   * parse tree...? For now, do mk_none() for all comments; this
	   * goes for all alternatives in this rule. */
	  yypvt[-3] = Absyn__EQUATIONITEM(Absyn__EQ_5fEQUALS(yypvt[-2],yypvt[-0]), mk_none());
	} break;
case 139:
# line 644 "parser.y"
{ yypvt[-1] = Absyn__EQUATIONITEM(yypvt[-0], mk_none());} break;
case 140:
# line 647 "parser.y"
{ yypvt[-1] = Absyn__EQUATIONITEM(yypvt[-0], mk_none());} break;
case 141:
# line 650 "parser.y"
{ yypvt[-1] = Absyn__EQUATIONITEM(yypvt[-0], mk_none());} break;
case 142:
# line 653 "parser.y"
{ yypvt[-1] = Absyn__EQUATIONITEM(yypvt[-0], mk_none());} break;
case 143:
# line 656 "parser.y"
{
	  yypvt[-2] = Absyn__EQUATIONITEM(Absyn__EQ_5fNORETCALL(yypvt[-1],yypvt[-0]), mk_none());
	} break;
case 144:
# line 663 "parser.y"
{ yypvt[-2] = Absyn__ALGORITHMITEM(yypvt[-1], yypvt[-0]);} break;
case 145:
# line 668 "parser.y"
{ yypvt[-3] = Absyn__ALG_5fASSIGN(yypvt[-2],yypvt[-0]);} break;
case 146:
# line 671 "parser.y"
{
	  yypvt[-6] = Absyn__ALG_5fTUPLE_5fASSIGN(Absyn__TUPLE(yypvt[-4]),
					Absyn__CALL(yypvt[-1],yypvt[-0]));
	} break;
case 147:
# line 677 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 148:
# line 680 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 149:
# line 683 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 150:
# line 686 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 151:
# line 691 "parser.y"
{ yypvt[-5] = mk_cons(mk_box2(0,yypvt[-3],yypvt[-1]), yypvt[-0]);} break;
case 152:
# line 693 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 153:
# line 698 "parser.y"
{ yypvt[-5] = mk_cons(mk_box2(0,yypvt[-3],yypvt[-1]), yypvt[-0]);} break;
case 154:
# line 700 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 155:
# line 705 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 156:
# line 707 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 157:
# line 712 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 158:
# line 714 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 159:
# line 723 "parser.y"
{ yypvt[-8] = Absyn__EQ_5fIF(yypvt[-7],yypvt[-4],yypvt[-3],yypvt[-2]);} break;
case 160:
# line 732 "parser.y"
{ yypvt[-8] = Absyn__ALG_5fIF(yypvt[-7],yypvt[-4],yypvt[-3],yypvt[-2]);} break;
case 161:
# line 737 "parser.y"
{ yypvt[-6] = Absyn__EQ_5fFOR(yypvt[-4],mk_nil(),yypvt[-0]);} break;
case 162:
# line 740 "parser.y"
{ yypvt[-8] = Absyn__EQ_5fFOR(yypvt[-6],yypvt[-4],yypvt[-2]);} break;
case 163:
# line 745 "parser.y"
{ yypvt[-6] = Absyn__ALG_5fFOR(yypvt[-4],mk_nil(),yypvt[-0]);} break;
case 164:
# line 748 "parser.y"
{ yypvt[-8] = Absyn__ALG_5fFOR(yypvt[-6],yypvt[-4],yypvt[-2]);} break;
case 165:
# line 753 "parser.y"
{ yypvt[-6] = Absyn__ALG_5fWHILE(yypvt[-4],yypvt[-2]);} break;
case 166:
# line 758 "parser.y"
{ yypvt[-7] = Absyn__EQ_5fWHEN_5fE(yypvt[-5],yypvt[-3],yypvt[-2]);} break;
case 167:
# line 763 "parser.y"
{ yypvt[-5] = mk_cons(mk_box2(0,yypvt[-3],yypvt[-1]), yypvt[-0]);} break;
case 168:
# line 765 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 169:
# line 770 "parser.y"
{ yypvt[-7] = Absyn__ALG_5fWHEN_5fA(yypvt[-5],yypvt[-3],yypvt[-2]);} break;
case 170:
# line 775 "parser.y"
{ yypvt[-5] = mk_cons(mk_box2(0,yypvt[-3],yypvt[-1]), yypvt[-0]);} break;
case 171:
# line 777 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 172:
# line 782 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2],yypvt[-0]);} break;
case 173:
# line 784 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 174:
# line 789 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2],yypvt[-0]);} break;
case 175:
# line 791 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 176:
# line 796 "parser.y"
{ yypvt[-6] = Absyn__EQ_5fCONNECT(yypvt[-3],yypvt[-1]);} break;
case 177:
# line 801 "parser.y"
{ yypvt[-5] = Absyn__CREF_5fQUAL(yypvt[-4],yypvt[-3],Absyn__CREF_5fIDENT(yypvt[-1],yypvt[-0]));} break;
case 178:
# line 804 "parser.y"
{ yypvt[-2] = Absyn__CREF_5fIDENT(yypvt[-1],yypvt[-0]);} break;
case 179:
# line 809 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 180:
# line 812 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 181:
# line 815 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 182:
# line 820 "parser.y"
{ yypvt[-4] = yypvt[-1];} break;
case 183:
# line 825 "parser.y"
{ yypvt[-1] = Absyn__CODE(Absyn__C_5fEXPRESSION(yypvt[-0]));} break;
case 184:
# line 828 "parser.y"
{ yypvt[-1] = Absyn__CODE(Absyn__C_5fMODIFICATION(yypvt[-0]));} break;
case 185:
# line 831 "parser.y"
{ yypvt[-2] = Absyn__CODE(Absyn__C_5fELEMENT(yypvt[-1]));} break;
case 186:
# line 834 "parser.y"
{
	  yypvt[-1] = Absyn__CODE(Absyn__C_5fEQUATIONSECTION(RML_FALSE,
				RML_FETCH(RML_OFFSET(RML_UNTAGPTR(yypvt[-0]),1))));
	} break;
case 187:
# line 840 "parser.y"
{
	  yypvt[-1] = Absyn__CODE(Absyn__C_5fEQUATIONSECTION(RML_TRUE,
				RML_FETCH(RML_OFFSET(RML_UNTAGPTR(yypvt[-0]),1))));
	} break;
case 188:
# line 846 "parser.y"
{
	  yypvt[-1] = Absyn__CODE(Absyn__C_5fALGORITHMSECTION(RML_FALSE,
				RML_FETCH(RML_OFFSET(RML_UNTAGPTR(yypvt[-0]),1))));
	} break;
case 189:
# line 852 "parser.y"
{
	  yypvt[-1] = Absyn__CODE(Absyn__C_5fALGORITHMSECTION(RML_TRUE,
				RML_FETCH(RML_OFFSET(RML_UNTAGPTR(yypvt[-0]),1))));
	} break;
case 190:
# line 860 "parser.y"
{ yypvt[-7] = Absyn__IFEXP(yypvt[-5],yypvt[-3],yypvt[-0],yypvt[-2]);} break;
case 191:
# line 865 "parser.y"
{ yypvt[-5] = mk_cons(mk_box2(0,yypvt[-3],yypvt[-1]), yypvt[-0]);} break;
case 192:
# line 867 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 193:
# line 872 "parser.y"
{ yypvt[-5] = Absyn__RANGE(yypvt[-4],mk_some(yypvt[-2]),yypvt[-0]);} break;
case 194:
# line 875 "parser.y"
{ yypvt[-3] = Absyn__RANGE(yypvt[-2],mk_none(),yypvt[-0]);} break;
case 195:
# line 878 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 196:
# line 883 "parser.y"
{ yypvt[-3] = Absyn__LBINARY(yypvt[-2],Absyn__OR,yypvt[-0]);} break;
case 197:
# line 886 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 198:
# line 891 "parser.y"
{ yypvt[-3] = Absyn__LBINARY(yypvt[-2],Absyn__AND,yypvt[-0]);} break;
case 199:
# line 894 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 200:
# line 899 "parser.y"
{ yypvt[-2] = Absyn__LUNARY(Absyn__NOT,yypvt[-0]);} break;
case 201:
# line 902 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 202:
# line 907 "parser.y"
{ yypvt[-3] = Absyn__RELATION(yypvt[-2],yypvt[-1],yypvt[-0]);} break;
case 203:
# line 911 "parser.y"
{ yypvt[-1] = Absyn__LESS;} break;
case 204:
# line 912 "parser.y"
{ yypvt[-1] = Absyn__LESSEQ;} break;
case 205:
# line 913 "parser.y"
{ yypvt[-1] = Absyn__GREATER;} break;
case 206:
# line 914 "parser.y"
{ yypvt[-1] = Absyn__GREATEREQ;} break;
case 207:
# line 915 "parser.y"
{ yypvt[-1] = Absyn__EQUAL;} break;
case 208:
# line 916 "parser.y"
{ yypvt[-1] = Absyn__NEQUAL;} break;
case 210:
# line 924 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2],Absyn__ADD,yypvt[-0]);} break;
case 211:
# line 927 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2],Absyn__SUB,yypvt[-0]);} break;
case 212:
# line 931 "parser.y"
{ yypvt[-2] = Absyn__UNARY(Absyn__UPLUS,yypvt[-0]);} break;
case 213:
# line 933 "parser.y"
{ yypvt[-2] = Absyn__UNARY(Absyn__UMINUS,yypvt[-0]);} break;
case 214:
# line 935 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 215:
# line 939 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2],Absyn__MUL,yypvt[-0]);} break;
case 216:
# line 941 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2],Absyn__DIV,yypvt[-0]);} break;
case 217:
# line 943 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 218:
# line 947 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2],Absyn__POW,yypvt[-0]);} break;
case 219:
# line 949 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 220:
# line 954 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 221:
# line 957 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 222:
# line 962 "parser.y"
{ yypvt[-1] = Absyn__MATRIX(yypvt[-0]);} break;
case 223:
# line 966 "parser.y"
{ yypvt[-1] = Absyn__INTEGER(mk_icon(str_to_int(yypvt[-0])));} break;
case 224:
# line 968 "parser.y"
{ yypvt[-1] = Absyn__REAL(mk_rcon(str_to_double(yypvt[-0])));} break;
case 225:
# line 970 "parser.y"
{ yypvt[-1] = Absyn__STRING(to_rml_str(yypvt[-0]));} break;
case 226:
# line 972 "parser.y"
{ yypvt[-1] = Absyn__BOOL(RML_FALSE);} break;
case 227:
# line 974 "parser.y"
{ yypvt[-1] = Absyn__BOOL(RML_TRUE);} break;
case 228:
# line 976 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 229:
# line 978 "parser.y"
{ yypvt[-3] = yypvt[-2];} break;
case 230:
# line 980 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 231:
# line 982 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 232:
# line 987 "parser.y"
{ yypvt[-2] = Absyn__CALL(yypvt[-1], yypvt[-0]);} break;
case 233:
# line 990 "parser.y"
{ yypvt[-1] = Absyn__CREF(yypvt[-0]);} break;
case 234:
# line 993 "parser.y"
{ yypvt[-3] = Absyn__CALL(Absyn__CREF_5fIDENT(
					mk_scon("initial"), mk_nil()),
				   Absyn__FUNCTIONARGS(mk_nil(), mk_nil()));
 		} break;
case 235:
# line 1000 "parser.y"
{ yypvt[-3] = Absyn__QUALIFIED(yypvt[-2], yypvt[-0]);} break;
case 236:
# line 1002 "parser.y"
{ yypvt[-1] = Absyn__IDENT(yypvt[-0]);} break;
case 237:
# line 1007 "parser.y"
{ yypvt[-4] = Absyn__CREF_5fQUAL(yypvt[-3],yypvt[-2],yypvt[-0]);} break;
case 238:
# line 1010 "parser.y"
{ yypvt[-2] = Absyn__CREF_5fIDENT(yypvt[-1],yypvt[-0]);} break;
case 239:
# line 1015 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 240:
# line 1021 "parser.y"
{ /* FIXME */;} break;
case 241:
# line 1026 "parser.y"
{ /* FIXME */; } break;
case 242:
# line 1028 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 243:
# line 1033 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2],yypvt[-1]);} break;
case 244:
# line 1036 "parser.y"
{ yypvt[-5] = Absyn__FOR_5fITER_5fFARG(yypvt[-4],yypvt[-2],yypvt[-0]);} break;
case 245:
# line 1039 "parser.y"
{ yypvt[-3] = Absyn__FOR_5fITER_5fFARG(yypvt[-2],yypvt[-0],mk_nil());} break;
case 246:
# line 1044 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1],yypvt[-0]);} break;
case 247:
# line 1046 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 248:
# line 1049 "parser.y"
{ /* ANTLR relic? should this rule do anything? */} break;
case 249:
# line 1053 "parser.y"
{ yypvt[-3] = Absyn__NAMEDARG(to_rml_str(yypvt[-2]),yypvt[-0]);} break;
case 250:
# line 1058 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2],yypvt[-0]);} break;
case 251:
# line 1061 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0],mk_nil());} break;
case 252:
# line 1066 "parser.y"
{ yypvt[-2] = mk_some(Absyn__COMMENT(yypvt[-0], yypvt[-1]));} break;
case 253:
# line 1068 "parser.y"
{ yypvt[-0] = mk_none();} break;
case 254:
# line 1072 "parser.y"
{ parserCommentBuffer[0] = 0;} break;
case 255:
# line 1074 "parser.y"
{ yypvt[-2] = mk_some(to_rml_str(parserCommentBuffer));} break;
case 256:
# line 1079 "parser.y"
{
		    if (strlen(yaccCommentBuffer)+strlen(yypvt[-0]) < MAXCOMMENT)
			strcat(yaccCommentBuffer, yypvt[-0]);
		} break;
case 259:
# line 1093 "parser.y"
{ yypvt[-2] = Absyn__ANNOTATION(yypvt[-0]);} break;
case 260:
# line 1098 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 261:
# line 1100 "parser.y"
{ yypvt[-0] = mk_none();} break;
case 262:
# line 1105 "parser.y"
{ yypvt[-1] = to_rml_string(yypvt[-0]);} break;
case 263:
# line 1114 "parser.y"
{ yypvt[-5] = Absyn__RML_5fFILE(yypvt[-3], yypvt[-1], yypvt[-0]);} break;
case 264:
# line 1117 "parser.y"
{ yypvt[-4] = Absyn__RML_5fFILE(yypvt[-2], yypvt[-0], mk_nil());} break;
case 265:
# line 1122 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 267:
# line 1128 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 268:
# line 1130 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 269:
# line 1135 "parser.y"
{ yypvt[-2] = Absyn__WITH(yypvt[-0]);} break;
case 270:
# line 1138 "parser.y"
{ yypvt[-3] = mk_nil(); /* FIXME!! */;} break;
case 271:
# line 1141 "parser.y"
{ yypvt[-2] = yypvt[-1];} break;
case 272:
# line 1144 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 273:
# line 1147 "parser.y"
{ yypvt[-4] = Absyn__VALINTERFACE(yypvt[-2], yypvt[-0]);} break;
case 274:
# line 1150 "parser.y"
{ yypvt[-4] = Absyn__RELATION_5fINTERFACE(yypvt[-2], yypvt[-0]);} break;
case 275:
# line 1155 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 276:
# line 1157 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 277:
# line 1162 "parser.y"
{ yypvt[-2] = Absyn__WITH(yypvt[-0]);} break;
case 278:
# line 1165 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 279:
# line 1168 "parser.y"
{ yypvt[-3] = yypvt[-1]; /* FIXME: support withbind */} break;
case 280:
# line 1171 "parser.y"
{ yypvt[-4] = Absyn__VALDEF(yypvt[-2], yypvt[-0]);} break;
case 281:
# line 1174 "parser.y"
{ yypvt[-2] = yypvt[-1];} break;
case 282:
# line 1179 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 283:
# line 1182 "parser.y"
{ yypvt[-1] = mk_nil();} break;
case 284:
# line 1187 "parser.y"
{ yypvt[-6] = Absyn__RELATION_5fDEFINITION(yypvt[-5], yypvt[-4], yypvt[-2]);} break;
case 285:
# line 1191 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 286:
# line 1194 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 287:
# line 1199 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 288:
# line 1202 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 289:
# line 1207 "parser.y"
{ yypvt[-4] = mk_nil(); /* FIXME! */ } break;
case 290:
# line 1212 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 291:
# line 1215 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 292:
# line 1220 "parser.y"
{ yypvt[-4] = Absyn__DATATYPE(yypvt[-2], yypvt[-1]); /* FIXME: $1 */ } break;
case 293:
# line 1225 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 294:
# line 1228 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 295:
# line 1233 "parser.y"
{ yypvt[-1] = Absyn__DTCONS(yypvt[-0], mk_nil());} break;
case 296:
# line 1236 "parser.y"
{ yypvt[-3] = Absyn__DTCONS(yypvt[-2], yypvt[-0]);} break;
case 298:
# line 1243 "parser.y"
{ /* FIXME */} break;
case 299:
# line 1248 "parser.y"
{ yypvt[-2] = mk_cons(yypvt[-1], yypvt[-0]);} break;
case 300:
# line 1251 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 301:
# line 1256 "parser.y"
{ yypvt[-6] = Absyn__RMLRULE(yypvt[-2], yypvt[-1], yypvt[-4], yypvt[-0]);} break;
case 302:
# line 1259 "parser.y"
{ yypvt[-4] = Absyn__RMLRULE(yypvt[-2], yypvt[-1], mk_nil(), yypvt[-0]);} break;
case 303:
# line 1264 "parser.y"
{ yypvt[-0] = Absyn__RMLNoResult;} break;
case 304:
# line 1267 "parser.y"
{ yypvt[-2] = Absyn__RMLResultExp(yypvt[-0]);} break;
case 305:
# line 1270 "parser.y"
{ yypvt[-2] = Absyn__RMLResultFail;} break;
case 306:
# line 1275 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 307:
# line 1278 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 308:
# line 1283 "parser.y"
{ yypvt[-3] = mkcons(yypvt[-2], yypvt[-0]);} break;
case 309:
# line 1286 "parser.y"
{ yypvt[-1] = mkcons(yypvt[-0], mk_nil());} break;
case 310:
# line 1291 "parser.y"
{ yypvt[-3] = Absyn__RMLGOAL_5fRELATION(yypvt[-2], yypvt[-1], yypvt[-0]);} break;
case 311:
# line 1294 "parser.y"
{ yypvt[-3] = Absyn__RMLGOAL_5fEQUAL(yypvt[-2], yypvt[-0]);} break;
case 312:
# line 1297 "parser.y"
{ yypvt[-4] = Absyn__RMLGOAL_5fLET(yypvt[-2], yypvt[-0]);} break;
case 313:
# line 1300 "parser.y"
{ yypvt[-2] = Absyn__RMLGOAL_5fNOT(yypvt[-0]);} break;
case 314:
# line 1303 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 315:
# line 1310 "parser.y"
{ yypvt[-3] = Absyn__RMLCONS(yypvt[-2], yypvt[-1]);} break;
case 316:
# line 1313 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 317:
# line 1318 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 318:
# line 1321 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 319:
# line 1326 "parser.y"
{ yypvt[-2] = mk_nil();} break;
case 320:
# line 1329 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 321:
# line 1332 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 322:
# line 1335 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 323:
# line 1340 "parser.y"
{ yypvt[-3] = Absyn__RMLCONS(yypvt[-2], yypvt[-0]);} break;
case 324:
# line 1343 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 325:
# line 1348 "parser.y"
{ yypvt[-2] = Absyn__RMLCALL(yypvt[-1], yypvt[-0]);} break;
case 326:
# line 1351 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 327:
# line 1356 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2], Absyn__ADD, yypvt[-0]);} break;
case 328:
# line 1359 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2], Absyn__SUB, yypvt[-0]);} break;
case 329:
# line 1362 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 330:
# line 1367 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2], Absyn__MUL, yypvt[-0]);} break;
case 331:
# line 1370 "parser.y"
{ yypvt[-3] = Absyn__BINARY(yypvt[-2], Absyn__DIV, yypvt[-0]);} break;
case 332:
# line 1373 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 333:
# line 1378 "parser.y"
{ yypvt[-2] = Absyn__UNARY(Absyn__UMINUS, yypvt[-0]);} break;
case 334:
# line 1381 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 335:
# line 1386 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 336:
# line 1389 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 337:
# line 1392 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 338:
# line 1395 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 339:
# line 1400 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 340:
# line 1403 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 341:
# line 1408 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 342:
# line 1411 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 343:
# line 1416 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 344:
# line 1421 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 345:
# line 1424 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 346:
# line 1427 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 347:
# line 1434 "parser.y"
{ yypvt[-3] = Absyn__RMLPAT_5fAS(yypvt[-2], yypvt[-0]);} break;
case 348:
# line 1437 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 349:
# line 1442 "parser.y"
{ yypvt[-3] = Absyn__RMLPAT_5fCONS(yypvt[-2], yypvt[-0]);} break;
case 350:
# line 1445 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 351:
# line 1450 "parser.y"
{ yypvt[-2] = Absyn__RMLPAT_5fNIL;} break;
case 352:
# line 1453 "parser.y"
{ yypvt[-3] = yypvt[-2];} break;
case 353:
# line 1456 "parser.y"
{ yypvt[-5] = Absyn__RMLPAT_5fSTRUCT(mk_cons(yypvt[-3], yypvt[-1]));} break;
case 354:
# line 1459 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 355:
# line 1464 "parser.y"
{ yypvt[-3] = Absyn__RMLPAT_5fCONS(yypvt[-2], yypvt[-0]);} break;
case 356:
# line 1467 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 357:
# line 1472 "parser.y"
{ yypvt[-2] = Absyn__RMLPAT_5fCALL(yypvt[-1], yypvt[-0]);} break;
case 358:
# line 1475 "parser.y"
{ yypvt[-2] = Absyn__RMLPAT_5fCALL(yypvt[-1], yypvt[-0]);} break;
case 359:
# line 1478 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 360:
# line 1483 "parser.y"
{ yypvt[-1] = Absyn__RMLPAT_5fWILDCARD;} break;
case 361:
# line 1486 "parser.y"
{ yypvt[-1] = Absyn__RMLPAT_5fLITERAL(yypvt[-0]);} break;
case 362:
# line 1489 "parser.y"
{ yypvt[-1] = Absyn__RMLPAT_5fIDENT(yypvt[-0]);} break;
case 363:
# line 1492 "parser.y"
{ yypvt[-1] = Absyn__RMLPAT_5fIDENT(yypvt[-0]);} break;
case 364:
# line 1495 "parser.y"
{ yypvt[-3] = yypvt[-2]; /* CHECKME */} break;
case 365:
# line 1500 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 366:
# line 1503 "parser.y"
{ yypvt[-2] = yypvt[-0];} break;
case 367:
# line 1508 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 368:
# line 1511 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 369:
# line 1514 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 370:
# line 1519 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 371:
# line 1524 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 372:
# line 1527 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 373:
# line 1532 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 374:
# line 1535 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 375:
# line 1542 "parser.y"
{ yypvt[-1] = Absyn__RMLLIT_5fCHAR(mk_ccon(yypvt[-0]));} break;
case 376:
# line 1545 "parser.y"
{ yypvt[-1] = Absyn__RMLLIT_5fINTEGER(mk_icon(yypvt[-0]));} break;
case 377:
# line 1548 "parser.y"
{ yypvt[-1] = Absyn__RMLLIT_5fREAL(mk_rcon(yypvt[-0]));} break;
case 378:
# line 1551 "parser.y"
{ yypvt[-1] = Absyn__RMLLIT_5fSTRING(mk_scon(yypvt[-0]));} break;
case 379:
# line 1558 "parser.y"
{ yypvt[-3] = Absyn__RMLTYPE_5fSIGNATURE(
                              Absyn__CALLSIGN(yypvt[-2], yypvt[-0]));} break;
case 380:
# line 1562 "parser.y"
{ yypvt[-1] = Absyn__RMLTYPE_5fTUPLE(yypvt[-0]);} break;
case 381:
# line 1567 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 382:
# line 1570 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 383:
# line 1581 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 384:
# line 1584 "parser.y"
{ yypvt[-1] = Absyn__RMLTYPE_5fTYVAR(yypvt[-0]);} break;
case 385:
# line 1587 "parser.y"
{ yypvt[-1] = Absyn__RMLTYPE_5fUSERDEFINED(yypvt[-0]);} break;
case 386:
# line 1592 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 387:
# line 1595 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], mk_cons(yypvt[-0], mk_nil()));} break;
case 388:
# line 1600 "parser.y"
{ yypvt[-2] = mk_nil();} break;
case 389:
# line 1603 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 390:
# line 1606 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 391:
# line 1611 "parser.y"
{ yypvt[-3] = mk_cons(yypvt[-2], yypvt[-0]);} break;
case 392:
# line 1614 "parser.y"
{ yypvt[-1] = mk_cons(yypvt[-0], mk_nil());} break;
case 393:
# line 1619 "parser.y"
{ yypvt[-3] = yypvt[-1];} break;
case 394:
# line 1624 "parser.y"
{ yypvt[-0] = mk_nil();} break;
case 395:
# line 1627 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 396:
# line 1630 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 397:
# line 1637 "parser.y"
{ yypvt[-3] = Absyn__RMLLONGID(mk_scon(yypvt[-2]), mk_scon(yypvt[-0]));} break;
case 398:
# line 1642 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 399:
# line 1645 "parser.y"
{ yypvt[-1] = yypvt[-0];} break;
case 400:
# line 1650 "parser.y"
{ yypvt[-1] = mk_scon(yypvt[-0]);} break;
case 401:
# line 1655 "parser.y"
{ yypvt[-1] = mk_scon(yypvt[-0]);} break;
# line	531 "/usr/ccs/bin/yaccpar"
	}
	goto yystack;		/* reset registers in driver code */
}

