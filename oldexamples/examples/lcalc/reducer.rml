
module reducer:
  datatype  Term      =  TRUE
                      |  FALSE
                      |  ZERO
                      |  VAR     of  string
                      |  SUCC    of  Term
                      |  PRED    of  Term
                      |  ISZERO  of  Term
                      |  IF      of  Term * Term * Term
                      |  LAMBDA  of  string * Term * Option
                      |  APPLY   of  Term * Term
                      |  DEF     of  string * Term
                      |  SEQ     of  Term * Term

  datatype  Option    =  OPEN
                      |  LOCKED

  relation  exec:     Term => ()
  relation  debug:    Term => ()
end



(******************************************************************************)
(*                                 DISPLAYER                                  *)
(******************************************************************************)


(* As you long you do not add new syntax (and that is not really necessary
before exercise 5.1) you do not need to edit this part of the code. *)


relation exec: Term => () =

  rule  reduce t => t' &
        exec t'
       ------------------
        exec t

  rule  is_value v &
        display v &
        print "\n"
       ------------
        exec v

  rule  display v &
        print " <Stuck term!>\n"
       -------------------------
        exec v

end

(******************************************************************************)

relation debug: Term => () =

  rule  reduce t => t' &
        display t &
        print "\n\n" &
        debug t'
       ------------------
        debug t

  rule  is_value v &
        display v &
        print " <Done!>\n"
       ------------
        debug v

  rule  display v &
        print " <Stuck term!>\n"
       -------------------------
        debug v

end

(******************************************************************************)

relation is_lrterm: Term => () =

  axiom is_lrterm ZERO

  axiom is_lrterm TRUE
  
  axiom is_lrterm FALSE

  axiom is_lrterm VAR(x)

end

(******************************************************************************)

relation is_lhead: Term => () =

  rule  is_lhead b
       --------------------------
        is_lhead LAMBDA(x, b, p)

  rule  is_lrterm t
       -------------
        is_lhead t

end

(******************************************************************************)

relation is_head: Term => () =

  axiom is_head LAMBDA(x, b, p)

  rule  is_lrterm t
       -------------
        is_head t

end

(******************************************************************************)

relation safe_to_display: Term => () =

  rule  is_lhead b
       ---------------------------------
        safe_to_display LAMBDA(x, b, p)

  rule  is_lrterm t
       ------------------
        safe_to_display t

  axiom safe_to_display APPLY(t1, APPLY(t2, t3))

end

(******************************************************************************)

relation pdisplay: Term  => () =
  (* Displays terms with parantheses where necessary. *)

  rule  safe_to_display t &
        display t
       ---------------
        pdisplay t

  rule  pdisplay t1 &
        print " " &
        pdisplay t2
       ------------------------
        pdisplay APPLY(t1, t2)

  rule  print "(" &
        display t &
        print ")"
       -------------
        pdisplay t

end

(******************************************************************************)

relation display: Term  => () =

  rule  print "false"
       ---------------
        display FALSE

  rule  print "true"
       --------------
        display TRUE

  rule  print "0"
       --------------
        display ZERO

  rule  print x
       ---------------
        display VAR x 

  rule  print "succ " &
        display t
       -----------------
        display SUCC t

  rule  print "pred " &
        display t
       -----------------
        display PRED t

  rule  print "iszero " &
        display t
       -----------------
        display ISZERO t

  rule  print "if " &
        display t1 &
        print " then " &
        display t2 &
        print " else " &
        display t3
       ------------------------
        display IF(t1, t2, t3)

  rule  is_head b &
        print "#" &
        print x &
        print "." &
        display b
       -----------------------------
        display LAMBDA(x, b, OPEN)

  rule  print "#" &
        print x &
        print ". " &
        display b
       ----------------------------
        display LAMBDA(x, b, OPEN)

  rule  print "#" &
        display LAMBDA(x, b, OPEN) 
       ------------------------------
        display LAMBDA(x, b, LOCKED)

  rule  pdisplay t1 &
        print " (" &
        display APPLY(t2, t3) &
        print ")"
       ----------------------------------
        display APPLY(t1, APPLY(t2, t3))

  rule  pdisplay t1 &
        print " " &
        display t2
       ----------------------
        display APPLY(t1, t2)

  rule  print x &
        print " = " &
        display t
       -------------------
        display DEF(x, t)

  rule  display t1 &
        print "; " &
        display t2
       -------------------
        display SEQ(t1, t2)

  rule  print "?"
       -----------
        display t

end



(******************************************************************************)
(*                                  REDUCER                                   *)
(******************************************************************************)


relation is_value: Term => () =
  (* Enter your rules here! The relation should fail iff the given term is not a
     value. *)
  rule print "relation should be implemented by student!\n"
       ----------------------------------------------------
       is_value(_) => fail
end

(******************************************************************************)

relation is_nat: Term => () =
  (* Enter your rules here! The relation should fail iff the given term is not a
     numeric value. *)
  rule print "relation should be implemented by student!\n"
       ----------------------------------------------------
       is_nat(_) => fail
end

(******************************************************************************)

relation not_free_in: (string, Term) => () =

  (* Enter your rules here! Given the name of a varible X as a string and a term
     T, this relation should fail iff X is not free in T. *)

  rule  x = y &
        not_free_in(x, d)
       -----------------------------------
        not_free_in(x, SEQ(DEF(y, d), t))

  rule  not x = y &
        not_free_in(x, d) &
        not_free_in(x, t)
       -----------------------------------
        not_free_in(x, SEQ(DEF(y, d), t))

end

(******************************************************************************)

relation subst: (string, Term, Term) => Term =

  (* Enter your rules here! Given the name of a variable X as a string, a term A
     and a term T, this relation is supposed to return the result of
     substituting X with A in T. *)

  rule  x = y &
        subst(x, a, d) => d'
       ------------------------------------------------------
        subst(x, a, SEQ(DEF(y, d), t)) => SEQ(DEF(y, d'), t)

  rule  not x = y &
        subst(x, a, d) => d' &
        not_free_in(y, a) &
        subst(x, a, t) => t'
       ------------------------------------------------------
        subst(x, a, SEQ(DEF(y, d), t)) => SEQ(DEF(y, d'), t')

end

(******************************************************************************)

relation reduce: Term => Term =

(* Enter your rules here! This relation is supposed to do one evaulation step.
   To begin with, treat open lambdas and closed lambdas equally. But after a
   while, you will probably see why we need two kinds of lambdas. *)

  axiom reduce SEQ(DEF(x, t), s) => APPLY(LAMBDA(x, s, OPEN), t)

  axiom reduce SEQ(t1, t2) => t2
                                                
end
