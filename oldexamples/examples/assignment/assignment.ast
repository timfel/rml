module assignment:
type Value = int
type Ident = string
type VarBnd = Ident*Value
type Env = (VarBnd)list
datatype UnOp 
	= NEG
datatype BinOp 
	= ADD
	| SUB
	| MUL
	| DIV
datatype Exp 
	= INT of int
	| BINARY of Exp*BinOp*Exp
	| UNARY of UnOp*Exp
	| ASSIGN of Ident*Exp
	| IDENT of Ident
datatype Program 
	= PROGRAM of (Exp)list*Exp
relation evalprogram: (Program) => (int)
end
relation apply_unop: (UnOp,int) => (int) =
	rule	int_neg(v) => (v2)
		----------------
		apply_unop(NEG,v) => (v2)

end
relation apply_binop: (BinOp,int,int) => (int) =
	rule	int_add(v1,v2) => (v3)
		----------------
		apply_binop(ADD,v1,v2) => (v3)

	rule	int_sub(v1,v2) => (v3)
		----------------
		apply_binop(SUB,v1,v2) => (v3)

	rule	int_mul(v1,v2) => (v3)
		----------------
		apply_binop(MUL,v1,v2) => (v3)

	rule	int_div(v1,v2) => (v3)
		----------------
		apply_binop(DIV,v1,v2) => (v3)

end
relation update: (Env,Ident,Value) => (Env) =
	rule	
		----------------
		update(env,id,value) => (RML.cons((id,value),env))

end
relation lookup: (Env,Ident) => (Value) =
	rule	id = id2
		----------------
		lookup(RML.cons((id2,value),_),id) => (value)

	rule	not id = id2 &
		lookup(rest,id) => (value)
		----------------
		lookup(RML.cons((id2,_),rest),id) => (value)

end
relation lookupextend: (Env,Ident) => (Env,Value) =
	rule	not lookup(env,id) => (v)
		----------------
		lookupextend(env,id) => (RML.cons((id,0),env),0)

	rule	lookup(env,id) => (value)
		----------------
		lookupextend(env,id) => (env,value)

end
relation eval: (Env,Exp) => (Env,int) =
	rule	
		----------------
		eval(env,INT(ival)) => (env,ival)

	rule	lookupextend(env,id) => (env2,value) &
		int_string(value) => (s) &
		print("lookup: ") => () &
		print(s) => () &
		print("\n") => ()
		----------------
		eval(env,IDENT(id)) => (env2,value)

	rule	eval(env,exp) => (env2,value) &
		update(env2,id,value) => (env3)
		----------------
		eval(env,ASSIGN(id,exp)) => (env3,value)

	rule	eval(env1,e1) => (env2,v1) &
		eval(env2,e2) => (env3,v2) &
		apply_binop(binop,v1,v2) => (v3)
		----------------
		eval(env1,BINARY(e1,binop,e2)) => (env3,v3)

	rule	eval(env1,e) => (env2,v1) &
		apply_unop(unop,v1) => (v2)
		----------------
		eval(env1,UNARY(unop,e)) => (env2,v2)

end
relation evals: (Env,(Exp)list) => (Env) =
	rule	
		----------------
		evals(e,RML.nil) => (e)

	rule	eval(env,exp) => (env2,v) &
		int_string(v) => (s) &
		print("v: ") => () &
		print(s) => () &
		print("\n") => () &
		evals(env2,expl) => (env3)
		----------------
		evals(env,RML.cons(exp,expl)) => (env3)

end
relation evalprogram: (Program) => (int) =
	rule	print("evp1\n") => () &
		list_reverse(assignments) => (assignments') &
		print("evp2\n") => () &
		evals(RML.nil,assignments') => (env2) &
		print("evp3\n") => () &
		eval(env2,exp) => (_,value) &
		print("evp4\n") => ()
		----------------
		evalprogram(PROGRAM(assignments,exp)) => (value)

end
